###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-LIB\lib_mem.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-LIB\lib_mem.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\lib_mem.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\lib_mem.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is 
     11          *               illegal to distribute this source code to any third party unless you receive 
     12          *               written permission by an authorized Micrium representative.  Knowledge of 
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest 
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                     STANDARD MEMORY OPERATIONS
     26          *
     27          * Filename      : lib_mem.c
     28          * Version       : V1.35.00
     29          * Programmer(s) : ITJ
     30          *                 FGK
     31          *********************************************************************************************************
     32          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     33          *
     34          *                     (a) ALL standard library functions are implemented in the custom library modules :
     35          *
     36          *                         (1) \<Custom Library Directory>\lib_*.*
     37          *
     38          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     39          *
     40          *                               where
     41          *                                       <Custom Library Directory>      directory path for custom library software
     42          *                                       <cpu>                           directory name for specific processor (CPU)
     43          *                                       <compiler>                      directory name for specific compiler
     44          *
     45          *                     (b) Product-specific library functions are implemented in individual products.
     46          *********************************************************************************************************
     47          */
     48          
     49          
     50          /*
     51          *********************************************************************************************************
     52          *                                            INCLUDE FILES
     53          *********************************************************************************************************
     54          */
     55          
     56          #define    LIB_MEM_MODULE
     57          #include  <lib_mem.h>
     58          
     59          
     60          /*$PAGE*/
     61          /*
     62          *********************************************************************************************************
     63          *                                            LOCAL DEFINES
     64          *********************************************************************************************************
     65          */
     66          
     67          
     68          /*
     69          *********************************************************************************************************
     70          *                                           LOCAL CONSTANTS
     71          *********************************************************************************************************
     72          */
     73          
     74          
     75          /*
     76          *********************************************************************************************************
     77          *                                          LOCAL DATA TYPES
     78          *********************************************************************************************************
     79          */
     80          
     81          
     82          /*
     83          *********************************************************************************************************
     84          *                                            LOCAL TABLES
     85          *********************************************************************************************************
     86          */
     87          
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                       LOCAL GLOBAL VARIABLES
     92          *********************************************************************************************************
     93          */
     94          
     95          #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
     96          MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
     97          MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
     98          
     99          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
    100          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
    101          #endif
    102          #endif
    103          
    104          
    105          /*
    106          *********************************************************************************************************
    107          *                                      LOCAL FUNCTION PROTOTYPES
    108          *********************************************************************************************************
    109          */
    110          
    111          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
    112          
    113          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    114          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL    *pmem_pool,
    115                                                       void        *pmem_blk);
    116          #endif
    117          
    118          
    119          static  CPU_SIZE_T    Mem_PoolSegCalcTotSize(void        *pmem_addr,
    120                                                       CPU_SIZE_T   blk_nbr,
    121                                                       CPU_SIZE_T   blk_size,
    122                                                       CPU_SIZE_T   blk_align);
    123          
    124          static  void         *Mem_PoolSegAlloc      (MEM_POOL    *pmem_pool,
    125                                                       CPU_SIZE_T   size,
    126                                                       CPU_SIZE_T   align);
    127          
    128          #endif
    129          
    130          
    131          /*
    132          *********************************************************************************************************
    133          *                                     LOCAL CONFIGURATION ERRORS
    134          *********************************************************************************************************
    135          */
    136          
    137          
    138          /*$PAGE*/
    139          /*
    140          *********************************************************************************************************
    141          *                                           Mem_Init()
    142          *
    143          * Description : (1) Initialize Memory Management Module :
    144          *
    145          *                   (a) Initialize heap memory pool
    146          *                   (b) Initialize      memory pool table
    147          *
    148          *
    149          * Argument(s) : none.
    150          *
    151          * Return(s)   : none.
    152          *
    153          * Caller(s)   : Application.
    154          *
    155          * Note(s)     : none.
    156          *********************************************************************************************************
    157          */
    158          
    159          void  Mem_Init (void)
    160          {
    161          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    162              MEM_POOL  *pmem_pool;
    163          
    164                                                                                  /* --------- INIT MEM HEAP SEG / POOL --------- */
    165              pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    166              pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
    167              pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
    168              pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
    169              pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
    170              pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
    171              pmem_pool->PoolAddrStart    = (void       *) 0;
    172              pmem_pool->PoolAddrEnd      = (void       *) 0;
    173              pmem_pool->PoolPtrs         = (void      **) 0;
    174              pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
    175              pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
    176              pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
    177          
    178          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    179              pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    180              pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    181          #else
    182              pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
    183              pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
    184          #endif
    185          
    186              pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    187              pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    188          
    189                                                                                  /* ------------ INIT MEM POOL TBL ------------- */
    190              Mem_PoolTbl = &Mem_PoolHeap;
    191          #endif
    192          }
    193          
    194          
    195          /*$PAGE*/
    196          /*
    197          *********************************************************************************************************
    198          *                                              Mem_Clr()
    199          *
    200          * Description : Clear data buffer (see Note #2).
    201          *
    202          * Argument(s) : pmem        Pointer to memory buffer to clear.
    203          *
    204          *               size        Number of data buffer octets to clear (see Note #1).
    205          *
    206          * Return(s)   : none.
    207          *
    208          * Caller(s)   : Application.
    209          *
    210          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    211          *
    212          *                   See also 'Mem_Set()  Note #1'.
    213          *
    214          *               (2) Clear data by setting each data octet to 0.
    215          *********************************************************************************************************
    216          */
    217          
    218          void  Mem_Clr (void        *pmem,
    219                         CPU_SIZE_T   size)
    220          {
    221              Mem_Set(pmem,
    222                      0u,                                                 /* See Note #2.                                         */
    223                      size);
    224          }
    225          
    226          
    227          /*$PAGE*/
    228          /*
    229          *********************************************************************************************************
    230          *                                              Mem_Set()
    231          *
    232          * Description : Fill data buffer with specified data octet.
    233          *
    234          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    235          *
    236          *               data_val    Data fill octet value.
    237          *
    238          *               size        Number of data buffer octets to fill (see Note #1).
    239          *
    240          * Return(s)   : none.
    241          *
    242          * Caller(s)   : Application.
    243          *
    244          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    245          *
    246          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    247          *                   words.
    248          *
    249          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    250          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    251          *                       addresses.
    252          *
    253          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    254          *                   address boundary.
    255          *
    256          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus,
    257          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    258          *                  'mem_align_mod' arithmetic operation.
    259          *********************************************************************************************************
    260          */
    261          
    262          void  Mem_Set (void        *pmem,
    263                         CPU_INT08U   data_val,
    264                         CPU_SIZE_T   size)
    265          {
    266              CPU_SIZE_T   size_rem;
    267              CPU_ALIGN    data_align;
    268              CPU_ALIGN   *pmem_align;
    269              CPU_INT08U  *pmem_08;
    270              CPU_DATA     mem_align_mod;
    271              CPU_DATA     i;
    272          
    273          
    274              if (size < 1) {                                             /* See Note #1.                                         */
    275                  return;
    276              }
    277              if (pmem == (void *)0) {
    278                  return;
    279              }
    280          
    281          
    282              data_align = 0u;
    283              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
    284                  data_align <<=  DEF_OCTET_NBR_BITS;
    285                  data_align  |= (CPU_ALIGN)data_val;
    286              }
    287          
    288              size_rem      =  size;
    289              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
    290          
    291              pmem_08 = (CPU_INT08U *)pmem;
    292              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
    293                  i = mem_align_mod;
    294                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    295                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    296                     *pmem_08++ = data_val;
    297                      size_rem -= sizeof(CPU_INT08U);
    298                      i++;
    299                  }
    300              }
    301          
    302              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    303              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    304                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
    305                  size_rem    -= sizeof(CPU_ALIGN);
    306              }
    307          
    308              pmem_08 = (CPU_INT08U *)pmem_align;
    309              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    310                 *pmem_08++   = data_val;
    311                  size_rem   -= sizeof(CPU_INT08U);
    312              }
    313          }
    314          
    315          
    316          /*$PAGE*/
    317          /*
    318          *********************************************************************************************************
    319          *                                             Mem_Copy()
    320          *
    321          * Description : Copy data octets from one memory buffer to another memory buffer.
    322          *
    323          * Argument(s) : pdest       Pointer to destination memory buffer.
    324          *
    325          *               psrc        Pointer to source      memory buffer.
    326          *
    327          *               size        Number of data buffer octets to copy (see Note #1).
    328          *
    329          * Return(s)   : none.
    330          *
    331          * Caller(s)   : Application.
    332          *
    333          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    334          *
    335          *               (2) Memory buffers NOT checked for overlapping.
    336          *
    337          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if 
    338          *                       copying takes place between objects that overlap, the behavior is undefined".
    339          *
    340          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD 
    341          *                       successfully copy to a destination memory buffer at a lower  address value even 
    342          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU 
    343          *                       word copy overlaps.
    344          *
    345          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or 
    346          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses 
    347          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can 
    348          *                       ever overlap.
    349          *
    350          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory 
    351          *                       buffers as long as the source memory buffer is at a higher address value than the 
    352          *                       destination memory buffer.
    353          *
    354          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    355          *                   words.
    356          *
    357          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    358          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    359          *                       addresses.
    360          *
    361          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    362          *                   address boundary.
    363          *
    364          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus,
    365          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    366          *                  'mem_align_mod' arithmetic operation.
    367          *********************************************************************************************************
    368          */
    369          /*$PAGE*/
    370          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    371          void  Mem_Copy (       void        *pdest,
    372                          const  void        *psrc,
    373                                 CPU_SIZE_T   size)
    374          {
    375                     CPU_SIZE_T    size_rem;
    376                     CPU_ALIGN    *pmem_align_dest;
    377              const  CPU_ALIGN    *pmem_align_src;
    378                     CPU_INT08U   *pmem_08_dest;
    379              const  CPU_INT08U   *pmem_08_src;
    380                     CPU_DATA      i;
    381                     CPU_DATA      mem_align_mod_dest;
    382                     CPU_DATA      mem_align_mod_src;
    383                     CPU_BOOLEAN   mem_aligned;
    384          
    385          
    386              if (size < 1) {                                             /* See Note #1.                                         */
    387                  return;
    388              }
    389              if (pdest == (void *)0) {
    390                  return;
    391              }
    392              if (psrc  == (void *)0) {
    393                  return;
    394              }
    395          
    396          
    397              size_rem           =  size;
    398          
    399              pmem_08_dest       = (      CPU_INT08U *)pdest;
    400              pmem_08_src        = (const CPU_INT08U *)psrc;
    401                                                                          /* See Note #4.                                         */
    402              mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    403              mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    404          
    405              mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    406          
    407              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    408                                                                          /* ... optimize copy for mem buf alignment.             */
    409                  if (mem_align_mod_dest != 0u) {                         /* If leading octets avail,                   ...       */
    410                      i = mem_align_mod_dest;
    411                      while ((size_rem   >  0) &&                         /* ... start mem buf copy with leading octets ...       */
    412                             (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
    413                         *pmem_08_dest++ = *pmem_08_src++;
    414                          size_rem      -=  sizeof(CPU_INT08U);
    415                          i++;
    416                      }
    417                  }
    418          
    419                  pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;      /* See Note #3a.                                        */
    420                  pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    421                  while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    422                     *pmem_align_dest++ = *pmem_align_src++;              /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    423                      size_rem         -=  sizeof(CPU_ALIGN);
    424                  }
    425          
    426                  pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    427                  pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    428              }
    429          
    430              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    431                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    432                  size_rem      -=  sizeof(CPU_INT08U);
    433              }
    434          }
    435          #endif
    436          
    437          
    438          /*$PAGE*/
    439          /*
    440          *********************************************************************************************************
    441          *                                              Mem_Cmp()
    442          *
    443          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    444          *
    445          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    446          *
    447          *               p2_mem      Pointer to second memory buffer.
    448          *
    449          *               size        Number of data buffer octets to compare (see Note #1).
    450          *
    451          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    452          *
    453          *               DEF_NO,  otherwise.
    454          *
    455          * Caller(s)   : Application.
    456          *
    457          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate 
    458          *                   identical null compare.
    459          *
    460          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    461          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    462          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    463          *                   on dissimilar memory buffers that vary only in the least significant octets.
    464          *
    465          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    466          *                   data words.
    467          *
    468          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    469          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    470          *                       addresses.
    471          *
    472          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    473          *                   address boundary.
    474          *
    475          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus,
    476          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    477          *                  'mem_align_mod' arithmetic operation.
    478          ********************************************************************************************************
    479          */
    480          /*$PAGE*/
    481          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    482                                const  void        *p2_mem,
    483                                       CPU_SIZE_T   size)
    484          {
    485                     CPU_SIZE_T    size_rem;
    486                     CPU_ALIGN    *p1_mem_align;
    487                     CPU_ALIGN    *p2_mem_align;
    488              const  CPU_INT08U   *p1_mem_08;
    489              const  CPU_INT08U   *p2_mem_08;
    490                     CPU_DATA      i;
    491                     CPU_DATA      mem_align_mod_1;
    492                     CPU_DATA      mem_align_mod_2;
    493                     CPU_BOOLEAN   mem_aligned;
    494                     CPU_BOOLEAN   mem_cmp;
    495          
    496          
    497              if (size < 1) {                                             /* See Note #1.                                         */
    498                  return (DEF_YES);
    499              }
    500              if (p1_mem == (void *)0) {
    501                  return (DEF_NO);
    502              }
    503              if (p2_mem == (void *)0) {
    504                  return (DEF_NO);
    505              }
    506          
    507          
    508              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
    509              size_rem        =  size;
    510                                                                          /* Start @ end of mem bufs (see Note #2).               */
    511              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
    512              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
    513                                                                          /* See Note #4.                                         */
    514              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
    515              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
    516          
    517              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
    518          
    519              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    520                                                                          /* ... optimize cmp for mem buf alignment.              */
    521                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
    522                      i = mem_align_mod_1;
    523                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    524                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    525                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    526                          p1_mem_08--;
    527                          p2_mem_08--;
    528                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
    529                               mem_cmp = DEF_NO;
    530                          }
    531                          size_rem -= sizeof(CPU_INT08U);
    532                          i--;
    533                      }
    534                  }
    535          
    536                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
    537                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
    538                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
    539          
    540                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    541                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    542                          p1_mem_align--;
    543                          p2_mem_align--;
    544                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
    545                               mem_cmp = DEF_NO;
    546                          }
    547                          size_rem -= sizeof(CPU_ALIGN);
    548                      }
    549          
    550                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    551                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
    552                  }
    553              }
    554          
    555              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    556                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
    557                  p1_mem_08--;
    558                  p2_mem_08--;
    559                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
    560                       mem_cmp = DEF_NO;
    561                  }
    562                  size_rem -= sizeof(CPU_INT08U);
    563              }
    564          
    565              return (mem_cmp);
    566          }
    567          
    568          
    569          /*$PAGE*/
    570          /*
    571          *********************************************************************************************************
    572          *                                           Mem_HeapAlloc()
    573          *
    574          * Description : Allocate a memory block from the heap memory pool.
    575          *
    576          * Argument(s) : size            Size      of memory block to allocate (in octets).
    577          *
    578          *               align           Alignment of memory block to specific word boundary (in octets).
    579          *
    580          *               poctets_reqd    Optional pointer to a variable to ... :
    581          *
    582          *                                   (a) Return the number of octets required to successfully
    583          *                                           allocate the memory block, if any error(s);
    584          *                                   (b) Return 0, otherwise.
    585          *
    586          *               perr        Pointer to variable that will receive the return error code from this function :
    587          *
    588          *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
    589          *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
    590          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    591          *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available 
    592          *                                                                   memory from heap.
    593          *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
    594          *
    595          * Return(s)   : Pointer to memory block, if NO error(s).
    596          *
    597          *               Pointer to NULL,         otherwise.
    598          *
    599          * Caller(s)   : Application.
    600          *
    601          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other 
    602          *                   validation or function handling in case of any error(s).
    603          *
    604          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    605          *********************************************************************************************************
    606          */
    607          /*$PAGE*/
    608          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    609          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    610                                CPU_SIZE_T   align,
    611                                CPU_SIZE_T  *poctets_reqd,
    612                                LIB_ERR     *perr)
    613          {
    614              MEM_POOL    *pmem_pool_heap;
    615              void        *pmem_addr;
    616              void        *pmem_blk;
    617              CPU_SIZE_T   octets_reqd_unused;
    618              CPU_SIZE_T   size_rem;
    619              CPU_SIZE_T   size_req;
    620              CPU_SR_ALLOC();
    621          
    622          
    623          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    624              if (perr == (LIB_ERR *)0) {
    625                  CPU_SW_EXCEPTION((void *)0);
    626              }
    627          #endif
    628          
    629                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    630              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
    631                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
    632                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    633              }
    634             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
    635          
    636          
    637          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    638              if (size < 1) {
    639                 *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
    640                  return ((void *)0);
    641              }
    642          
    643              if (align < 1) {
    644                 *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
    645                  return ((void *)0);
    646              }
    647          #endif
    648          
    649                                                                              /* -------------- ALLOC HEAP MEM BLK -------------- */
    650              pmem_pool_heap = &Mem_PoolHeap;
    651          
    652              CPU_CRITICAL_ENTER();
    653          
    654              pmem_addr = pmem_pool_heap->SegAddrNextAvail;
    655              size_rem  = pmem_pool_heap->SegSizeRem;
    656              size_req  = Mem_PoolSegCalcTotSize(pmem_addr,
    657                                                 1u,                          /* Calc alloc for single mem blk from heap.         */
    658                                                 size,
    659                                                 align);
    660          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    661              if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
    662                  CPU_CRITICAL_EXIT();
    663                 *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
    664                 *perr         = LIB_MEM_ERR_HEAP_OVF;
    665                  return ((void *)0);
    666              }
    667          #endif
    668          
    669              if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
    670                  CPU_CRITICAL_EXIT();
    671                 *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
    672                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    673                  return ((void *)0);
    674              }
    675          
    676              pmem_blk = Mem_PoolSegAlloc(pmem_pool_heap, size, align);
    677              if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
    678                  CPU_CRITICAL_EXIT();
    679                 *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
    680                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    681                  return ((void *)0);
    682              }
    683          
    684              CPU_CRITICAL_EXIT();
    685          
    686             *perr =  LIB_MEM_ERR_NONE;
    687          
    688              return (pmem_blk);
    689          }
    690          #endif
    691          
    692          
    693          /*$PAGE*/
    694          /*
    695          *********************************************************************************************************
    696          *                                            Mem_PoolClr()
    697          *
    698          * Description : Clear a memory pool (see Note #1).
    699          *
    700          * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
    701          *
    702          *               perr        Pointer to variable that will receive the return error code from this function :
    703          *
    704          *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
    705          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    706          *
    707          * Return(s)   : none.
    708          *
    709          * Caller(s)   : Application,
    710          *               Mem_PoolCreate().
    711          *
    712          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be 
    713          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
    714          *
    715          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the 
    716          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since 
    717          *                       this will likely corrupt the memory pool management.
    718          *
    719          *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
    720          *********************************************************************************************************
    721          */
    722          
    723          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    724          void  Mem_PoolClr (MEM_POOL  *pmem_pool,
    725                             LIB_ERR   *perr)
    726          {
    727          
    728          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
    729              if (perr == (LIB_ERR *)0) {
    730                  CPU_SW_EXCEPTION(;);
    731              }
    732          #endif
    733          
    734                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
    735              if (pmem_pool == (MEM_POOL *)0) {
    736                 *perr = LIB_MEM_ERR_NULL_PTR;
    737                  return;
    738              }
    739          
    740          
    741              pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
    742              pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
    743              pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
    744              pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
    745              pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
    746              pmem_pool->PoolAddrStart    = (void       *)0;
    747              pmem_pool->PoolAddrEnd      = (void       *)0;
    748              pmem_pool->PoolPtrs         = (void      **)0;
    749              pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
    750              pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
    751              pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
    752              pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
    753              pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
    754              pmem_pool->SegAddr          = (void       *)0;
    755              pmem_pool->SegAddrNextAvail = (void       *)0;
    756              pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
    757              pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
    758          
    759          
    760             *perr = LIB_MEM_ERR_NONE;
    761          }
    762          #endif
    763          
    764          
    765          /*$PAGE*/
    766          /*
    767          *********************************************************************************************************
    768          *                                          Mem_PoolCreate()
    769          *
    770          * Description : (1) Create a memory pool :
    771          *
    772          *                   (a) Create    memory pool from heap or dedicated memory
    773          *                   (b) Allocate  memory pool memory blocks
    774          *                   (c) Update    memory pool table
    775          *                   (d) Configure memory pool
    776          *
    777          *
    778          *               (2) Memory pools are indexed by the Memory Segments they use.
    779          *
    780          *                   (a) The memory pool table is composed by a two-dimensional list :
    781          *
    782          *                       (1) Memory segments manage the following memory segment/pool information :
    783          *
    784          *                           (A) Memory segment base           address
    785          *                           (B) Memory segment next available address
    786          *                           (C) Memory segment total     size
    787          *                           (D) Memory segment remaining size
    788          *
    789          *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
    790          *                           segment information.  To access the memory segment information, the head
    791          *                           memory segment must be accessed.
    792          *
    793          *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
    794          *                       memory segment for the memory blocks they have.  The heads of the memory pool are
    795          *                       linked horizontally to form a memory pool table.
    796          *
    797          *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
    798          *
    799          *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
    800          *                           form the list of memory segments.
    801          *
    802          *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
    803          *                           each memory segment.
    804          *
    805          *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
    806          *                       Segments Primary List.  The point of insertion is such to keep ascended order by
    807          *                       memory segment base address.
    808          *
    809          *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
    810          *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
    811          *
    812          *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
    813          *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
    814          *                           memory pool.
    815          *
    816          *
    817          *                                        |                                                                 |
    818          *                                        |<----------------------- Memory Segments ----------------------->|
    819          *                                        |                         (see Note #2a1)                         |
    820          *
    821          *                                 Lowest Memory Segment                                      Highest Memory Segment
    822          *                                     Base Address                                                Base Address
    823          *                                    (see Note #2c)                                              (see Note #2c)
    824          *
    825          *                                           |             SegNextPtr             Heap Memory Pool       |
    826          *                                           |          (see Note #2b2)            (see Note #2d)        |
    827          *                                           |                     |                                     |
    828          *                                           v                     |                      |              v
    829          *                                                                 |                      v
    830          *        ---          Head of Memory     -------        -------   v    -------        -------        -------
    831          *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
    832          *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
    833          *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
    834          *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
    835          *         |                              |     |        |     |   |    |     |        |  P  |        |     |
    836          *         |                              |     |        |     |   |    |     |        |     |        |     |
    837          *         |                              -------        -------   |    -------        -------        -------
    838          *         |                                | ^                    |      | ^
    839          *         |                                | |            SegPrevPtr     | |
    840          *         |                                v |         (see Note #2b2)   v |
    841          *         |                              -------                       -------
    842          *                                        |     |                       |     |
    843          *    Memory Pools                        |     |                       |     |
    844          *  (see Note #2a2)                       |     |                       |     |
    845          *                                        |     |                       |     |
    846          *         |                              |     |                       |     |
    847          *         |                              -------                       -------
    848          *         |                                | ^
    849          *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
    850          *         |             (see Note #2b3)    v |    (see Note #2b3)
    851          *         |                              -------
    852          *         |                              |     |
    853          *         |                              |     |
    854          *         |                              |     |
    855          *         |                              |     |
    856          *         v                              |     |
    857          *        ---                             -------
    858          *
    859          *$PAGE*
    860          * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
    861          *
    862          *               pmem_base_addr      Memory pool base address :
    863          *
    864          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
    865          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
    866          *                                                                   specified by its base address.
    867          *
    868          *               mem_size            Size      of memory pool segment          (in octets).
    869          *
    870          *               blk_nbr             Number    of memory pool blocks to create.
    871          *
    872          *               blk_size            Size      of memory pool blocks to create (in octets).
    873          *
    874          *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
    875          *
    876          *               poctets_reqd        Optional pointer to a variable to ... :
    877          *
    878          *                                       (a) Return the number of octets required to successfully
    879          *                                               allocate the memory pool, if any error(s);
    880          *                                       (b) Return 0, otherwise.
    881          *
    882          *               perr        Pointer to variable that will receive the return error code from this function :
    883          *
    884          *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
    885          *
    886          *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
    887          *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available 
    888          *                                                                       memory from heap.
    889          *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
    890          *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available 
    891          *                                                                       memory from segment for memory pools.
    892          *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
    893          *
    894          *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
    895          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
    896          *                                                                       segment(s) in memory pool table.
    897          *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
    898          *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
    899          *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
    900          *
    901          *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
    902          *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
    903          *
    904          * Return(s)   : none.
    905          *
    906          * Caller(s)   : Application.
    907          *
    908          * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
    909          *
    910          *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other 
    911          *                   validation or function handling in case of any error(s).
    912          *
    913          *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    914          *********************************************************************************************************
    915          */
    916          /*$PAGE*/
    917          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    918          void  Mem_PoolCreate (MEM_POOL    *pmem_pool,
    919                                void        *pmem_base_addr,
    920                                CPU_SIZE_T   mem_size,
    921                                CPU_SIZE_T   blk_nbr,
    922                                CPU_SIZE_T   blk_size,
    923                                CPU_SIZE_T   blk_align,
    924                                CPU_SIZE_T  *poctets_reqd,
    925                                LIB_ERR     *perr)
    926          {
    927              MEM_POOL     *pmem_pool_heap;
    928              MEM_POOL     *pmem_pool_prev;
    929              MEM_POOL     *pmem_pool_next;
    930              MEM_POOL     *pmem_pool_blk;
    931              void        **ppool_ptr;
    932              void         *pmem_blk;
    933              CPU_INT08U   *pmem_addr_ptrs;
    934              CPU_INT08U   *pmem_addr_pool;
    935              CPU_INT08U   *pmem_base_addr_start;
    936              CPU_INT08U   *pmem_base_addr_end;
    937              CPU_INT08U   *pmem_seg_addr_start;
    938              CPU_INT08U   *pmem_seg_addr_end;
    939              CPU_SIZE_T    octets_reqd_unused;
    940              CPU_SIZE_T    size_tot;
    941              CPU_SIZE_T    size_tot_ptrs;
    942              CPU_SIZE_T    size_tot_pool;
    943              CPU_SIZE_T    size_rem;
    944              CPU_SIZE_T    size_pool_ptrs;
    945              CPU_SIZE_T    blk_rem;
    946              CPU_SIZE_T    i;
    947              CPU_SR_ALLOC();
    948          
    949          
    950          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    951              if (perr == (LIB_ERR *)0) {
    952                  CPU_SW_EXCEPTION(;);
    953              }
    954          #endif
    955          
    956                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    957              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
    958                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
    959                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    960              }
    961             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
    962          
    963          
    964          
    965              Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
    966              if (*perr != LIB_MEM_ERR_NONE) {
    967                   return;
    968              }
    969          
    970          
    971                                                                              /* ----------- VALIDATE MEM POOL CREATE ----------- */
    972          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    973              if (pmem_base_addr != (void *)0) {
    974                  if (mem_size < 1) {
    975                     *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
    976                      return;
    977                  }
    978              }
    979          
    980              if (blk_nbr < 1) {
    981                 *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
    982                  return;
    983              }
    984          
    985              if (blk_size < 1) {
    986                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
    987                  return;
    988              }
    989          
    990              if (blk_align < 1) {
    991                 *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
    992                  return;
    993              }
    994          #endif
    995          
    996          
    997                                                                              /* ------------ VALIDATE MEM POOL TBL ------------- */
    998              if (Mem_PoolTbl == (MEM_POOL *)0) {
    999                 *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
   1000                  return;
   1001              }
   1002          
   1003          
   1004          
   1005          /*$PAGE*/
   1006                                                                              /* ---------------- CREATE MEM POOL --------------- */
   1007              pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
   1008              size_tot       = (CPU_SIZE_T) 0u;
   1009          
   1010              CPU_CRITICAL_ENTER();
   1011          
   1012              if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
   1013                  pmem_pool_blk   =  pmem_pool_heap;
   1014                  pmem_pool_prev  =  pmem_pool_heap;
   1015                  pmem_pool_next  =  pmem_pool_heap;
   1016          
   1017                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1018                                                                              /* Calc tot mem   size for mem pool ptrs.           */
   1019                  pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1020                  size_tot_ptrs   =  Mem_PoolSegCalcTotSize((void     *)pmem_addr_ptrs,
   1021                                                            (CPU_SIZE_T)blk_nbr,
   1022                                                            (CPU_SIZE_T)sizeof(void *),
   1023                                                            (CPU_SIZE_T)sizeof(void *));
   1024          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1025                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1026                      CPU_CRITICAL_EXIT();
   1027                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1028                      return;
   1029                  }
   1030          #endif
   1031                                                                              /* Calc tot mem   size for mem blks.                */
   1032                  pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
   1033                  size_tot_pool   =  Mem_PoolSegCalcTotSize((void     *)pmem_addr_pool,
   1034                                                            (CPU_SIZE_T)blk_nbr,
   1035                                                            (CPU_SIZE_T)blk_size,
   1036                                                            (CPU_SIZE_T)blk_align);
   1037          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1038                  if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
   1039                      CPU_CRITICAL_EXIT();
   1040                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1041                      return;
   1042                  }
   1043          #endif
   1044          
   1045                  size_tot = size_tot_ptrs + size_tot_pool;
   1046          
   1047          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1048                  if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
   1049                      (size_tot < size_tot_pool)) {
   1050                      CPU_CRITICAL_EXIT();
   1051                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1052                      return;
   1053                  }
   1054          #endif
   1055          
   1056                  size_rem = pmem_pool_heap->SegSizeRem;
   1057                  if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
   1058                      CPU_CRITICAL_EXIT();
   1059                     *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
   1060                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1061                      return;
   1062                  }
   1063          
   1064          /*$PAGE*/
   1065              } else {                                                        /* Else cfg mem pool from dedicated mem.            */
   1066                                                                              /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
   1067                  pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
   1068                  pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
   1069          
   1070          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1071                  if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
   1072                      CPU_CRITICAL_EXIT();
   1073                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1074                      return;
   1075                  }
   1076          #endif
   1077          
   1078                  pmem_pool_blk  = (MEM_POOL *)0;
   1079                  pmem_pool_prev = (MEM_POOL *)0;
   1080                  pmem_pool_next =  Mem_PoolTbl;
   1081          
   1082                  while (pmem_pool_next != (MEM_POOL *)0) {                   /* Srch tbl for mem seg with same base addr/size.   */
   1083          
   1084                      if ((pmem_base_addr == pmem_pool_next->SegAddr) &&      /* If same base addr/size found, ...                */
   1085                          (mem_size       == pmem_pool_next->SegSizeTot)) {
   1086          
   1087                           pmem_pool_blk   = pmem_pool_next;
   1088                           pmem_pool_prev  = pmem_pool_next;
   1089                           break;                                             /* ... prev mem seg    found in tbl.                */
   1090          
   1091                      } else {
   1092                          pmem_seg_addr_start = (CPU_INT08U *)pmem_pool_next->SegAddr;
   1093                          pmem_seg_addr_end   = (CPU_INT08U *)pmem_pool_next->SegAddr + pmem_pool_next->SegSizeTot - 1;
   1094          
   1095                                                                              
   1096                          if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
   1097                              break;                                          /* ... new mem seg NOT avail in tbl.                */
   1098          
   1099                                                                              /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
   1100                          } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
   1101                                      (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
   1102                                     ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
   1103                                      (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
   1104                                     ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
   1105                                      (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
   1106                              CPU_CRITICAL_EXIT();
   1107                             *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
   1108                              return;
   1109                          }
   1110                      }
   1111                                                                              /* If mem seg NOT found, adv to next mem seg.       */
   1112                      pmem_pool_prev = pmem_pool_next;
   1113                      pmem_pool_next = pmem_pool_next->SegNextPtr;
   1114                  }
   1115          
   1116                  if (pmem_pool_blk == (MEM_POOL *)0) {                       /* If mem seg NOT found, add    new  mem seg.       */
   1117                      pmem_pool_blk               = pmem_pool;
   1118                      pmem_pool->SegAddr          = pmem_base_addr;
   1119                      pmem_pool->SegAddrNextAvail = pmem_base_addr;
   1120                      pmem_pool->SegSizeTot       = mem_size;
   1121                      pmem_pool->SegSizeRem       = mem_size;
   1122                  }
   1123          
   1124          /*$PAGE*/
   1125                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1126                                                                              /* Calc tot mem size for mem pool ptrs.             */
   1127                  pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1128                  size_tot_ptrs  =  Mem_PoolSegCalcTotSize((void     *)pmem_addr_ptrs,
   1129                                                           (CPU_SIZE_T)blk_nbr,
   1130                                                           (CPU_SIZE_T)sizeof(void *),
   1131                                                           (CPU_SIZE_T)sizeof(void *));
   1132          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1133                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1134                      CPU_CRITICAL_EXIT();
   1135                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1136                      return;
   1137                  }
   1138          #endif
   1139          
   1140                  size_rem = pmem_pool_heap->SegSizeRem;
   1141                  if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
   1142                      CPU_CRITICAL_EXIT();
   1143                     *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
   1144                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1145                      return;
   1146                  }
   1147          
   1148                                                                              /* Calc tot mem size for mem blks.                  */
   1149                  pmem_addr_pool = (CPU_INT08U *)pmem_pool_blk->SegAddrNextAvail;
   1150                  size_tot_pool  =  Mem_PoolSegCalcTotSize((void     *)pmem_addr_pool,
   1151                                                           (CPU_SIZE_T)blk_nbr,
   1152                                                           (CPU_SIZE_T)blk_size,
   1153                                                           (CPU_SIZE_T)blk_align);
   1154          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1155                  if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
   1156                      CPU_CRITICAL_EXIT();
   1157                     *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
   1158                      return;
   1159                  }
   1160          #endif
   1161          
   1162                  size_rem = pmem_pool_blk->SegSizeRem;
   1163                  if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
   1164                      CPU_CRITICAL_EXIT();
   1165                     *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
   1166                     *perr         = LIB_MEM_ERR_SEG_EMPTY;
   1167                      return;
   1168                  }
   1169              }
   1170          
   1171          
   1172          /*$PAGE*/
   1173                                                                              /* ---------------- ALLOC MEM BLKs ---------------- */
   1174              size_pool_ptrs =  blk_nbr * sizeof(void *);
   1175                                                                              /* Alloc stk of ptrs for mem blks from heap.        */
   1176              ppool_ptr      = (void **)Mem_PoolSegAlloc((MEM_POOL *)pmem_pool_heap,
   1177                                                         (CPU_SIZE_T)size_pool_ptrs,
   1178                                                         (CPU_SIZE_T)sizeof(void *));
   1179              if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
   1180                  size_rem = pmem_pool_heap->SegSizeRem;
   1181                  CPU_CRITICAL_EXIT();
   1182                                                                              /* ... rtn add'l heap size needed.                  */
   1183                  if (pmem_base_addr == (void *)0) {
   1184                      if (size_tot > size_rem) {
   1185                         *poctets_reqd = size_tot       - size_rem;
   1186                      } else {
   1187                         *poctets_reqd = size_tot;
   1188                      }
   1189                  } else {
   1190                      if (size_pool_ptrs > size_rem) {
   1191                         *poctets_reqd = size_pool_ptrs - size_rem;
   1192                      } else {
   1193                         *poctets_reqd = size_pool_ptrs;
   1194                      }
   1195                  }
   1196                 *perr = LIB_MEM_ERR_HEAP_EMPTY;
   1197                  return;
   1198              }
   1199          
   1200              for (i = 0u; i < blk_nbr; i++) {                                /* Alloc mem blks from blk seg ptr.                 */
   1201                  pmem_blk = (void *)Mem_PoolSegAlloc(pmem_pool_blk, blk_size, blk_align);
   1202                  if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
   1203                      pmem_addr_pool = (CPU_INT08U *)pmem_pool_blk->SegAddrNextAvail;
   1204                      size_rem       = (CPU_SIZE_T  )pmem_pool_blk->SegSizeRem;
   1205                      CPU_CRITICAL_EXIT();
   1206                      blk_rem        =  blk_nbr - i;
   1207                      size_tot       =  Mem_PoolSegCalcTotSize((void     *)pmem_addr_pool,
   1208                                                               (CPU_SIZE_T)blk_rem,
   1209                                                               (CPU_SIZE_T)blk_size,
   1210                                                               (CPU_SIZE_T)blk_align);
   1211                                                                              /* ... rtn add'l seg  size needed.                  */
   1212                      if (size_tot > size_rem) {
   1213                         *poctets_reqd = size_tot - size_rem;
   1214                      } else {
   1215                         *poctets_reqd = size_tot;
   1216                      }
   1217                     *perr = LIB_MEM_ERR_SEG_EMPTY;
   1218                      return;
   1219                  }
   1220                  ppool_ptr[i] = pmem_blk;
   1221              }
   1222          
   1223          
   1224          /*$PAGE*/
   1225                                                                              /* ------------- UPDATE MEM POOL TBL -------------- */
   1226              if (pmem_pool_prev == pmem_pool_next) {                         /* Add new mem seg  to list.                        */
   1227          
   1228                  pmem_pool_next             = pmem_pool_blk->PoolNextPtr;
   1229                  pmem_pool->PoolPrevPtr     = pmem_pool_blk;
   1230                  pmem_pool->PoolNextPtr     = pmem_pool_next;
   1231                  pmem_pool_blk->PoolNextPtr = pmem_pool;
   1232                  if (pmem_pool_next != (MEM_POOL *)0) {
   1233                      pmem_pool_next->PoolPrevPtr = pmem_pool;
   1234                  }
   1235          
   1236              } else {                                                        /* Add new mem pool to mem seg.                     */
   1237          
   1238                  pmem_pool->SegPrevPtr = pmem_pool_prev;
   1239                  pmem_pool->SegNextPtr = pmem_pool_next;
   1240          
   1241                  if (pmem_pool_prev != (MEM_POOL *)0) {                      /* Update prev mem pool link.                       */
   1242                      pmem_pool_prev->SegNextPtr = pmem_pool;
   1243                  } else {
   1244                      Mem_PoolTbl                = pmem_pool;                 /* Update      mem pool head.                       */
   1245                  }
   1246          
   1247                  if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
   1248                      pmem_pool_next->SegPrevPtr = pmem_pool;
   1249                  }
   1250              }
   1251          
   1252          
   1253                                                                              /* ----------------- CFG MEM POOL ----------------- */
   1254              pmem_pool->Type          = (LIB_MEM_TYPE) LIB_MEM_TYPE_POOL;
   1255              pmem_pool->PoolAddrStart = (void       *) pmem_addr_pool;
   1256              pmem_pool->PoolAddrEnd   = (void       *)(pmem_addr_pool + size_tot_pool - 1);
   1257              pmem_pool->PoolPtrs      = (void      **) ppool_ptr;
   1258              pmem_pool->PoolSize      = (CPU_SIZE_T  ) size_tot_pool;
   1259              pmem_pool->BlkAlign      = (CPU_SIZE_T  ) blk_align;
   1260              pmem_pool->BlkSize       = (CPU_SIZE_T  ) blk_size;
   1261              pmem_pool->BlkNbr        = (CPU_SIZE_T  ) blk_nbr;
   1262              pmem_pool->BlkIx         = (MEM_POOL_IX ) blk_nbr;
   1263          
   1264          
   1265              CPU_CRITICAL_EXIT();
   1266          
   1267             *perr = LIB_MEM_ERR_NONE;
   1268          }
   1269          #endif
   1270          
   1271          
   1272          /*$PAGE*/
   1273          /*
   1274          *********************************************************************************************************
   1275          *                                          Mem_PoolBlkGet()
   1276          *
   1277          * Description : Get a memory block from memory pool.
   1278          *
   1279          * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
   1280          *
   1281          *               size        Size of requested memory (in octets).
   1282          *
   1283          *               perr        Pointer to variable that will receive the return error code from this function :
   1284          *
   1285          *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
   1286          *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1287          *
   1288          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1289          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1290          *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1291          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1292          *
   1293          * Return(s)   : Pointer to memory block, if NO error(s).
   1294          *
   1295          *               Pointer to NULL,         otherwise.
   1296          *
   1297          * Caller(s)   : Application.
   1298          *
   1299          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1300          *********************************************************************************************************
   1301          */
   1302          /*$PAGE*/
   1303          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1304          void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
   1305                                 CPU_SIZE_T   size,
   1306                                 LIB_ERR     *perr)
   1307          {
   1308              void  *pmem_blk;
   1309              CPU_SR_ALLOC();
   1310          
   1311          
   1312          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1313              if (perr == (LIB_ERR *)0) {
   1314                  CPU_SW_EXCEPTION((void *)0);
   1315              }
   1316          #endif
   1317          
   1318                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1319          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     
   1320              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   1321                 *perr = LIB_MEM_ERR_NULL_PTR;
   1322                  return ((void *)0);
   1323              }
   1324          
   1325              if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
   1326                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1327                  return ((void *)0);
   1328              }
   1329          #endif
   1330          
   1331              CPU_CRITICAL_ENTER();
   1332          
   1333          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1334              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1335                  CPU_CRITICAL_EXIT();
   1336                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1337                  return ((void *)0);
   1338              }
   1339          
   1340              if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
   1341                  CPU_CRITICAL_EXIT();
   1342                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1343                  return ((void *)0);
   1344              }
   1345          #endif
   1346          
   1347             (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
   1348          
   1349              if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
   1350                  CPU_CRITICAL_EXIT();
   1351                 *perr = LIB_MEM_ERR_POOL_EMPTY;
   1352                  return ((void *)0);
   1353              }
   1354          
   1355              if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
   1356                  CPU_CRITICAL_EXIT();
   1357                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1358                  return ((void *)0);
   1359              }
   1360          
   1361                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1362              pmem_pool->BlkIx--;
   1363              pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   1364          
   1365              CPU_CRITICAL_EXIT();
   1366          
   1367             *perr =  LIB_MEM_ERR_NONE;
   1368          
   1369              return (pmem_blk);
   1370          }
   1371          #endif
   1372          
   1373          
   1374          /*$PAGE*/
   1375          /*
   1376          *********************************************************************************************************
   1377          *                                          Mem_PoolBlkFree()
   1378          *
   1379          * Description : Free a memory block to memory pool.
   1380          *
   1381          * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
   1382          *
   1383          *               pmem_blk    Pointer to memory block address to free.
   1384          *
   1385          *               perr        Pointer to variable that will receive the return error code from this function :
   1386          *
   1387          *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
   1388          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1389          *                                                                           memory pool.
   1390          *
   1391          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1392          *                                                                           a NULL pointer.
   1393          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1394          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1395          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1396          *                                                                            in memory pool.
   1397          *
   1398          * Return(s)   : none.
   1399          *
   1400          * Caller(s)   : Application.
   1401          *
   1402          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1403          *********************************************************************************************************
   1404          */
   1405          /*$PAGE*/
   1406          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1407          void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
   1408                                 void      *pmem_blk,
   1409                                 LIB_ERR   *perr)
   1410          {
   1411          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1412              CPU_BOOLEAN  addr_valid;
   1413              MEM_POOL_IX  i;
   1414          #endif
   1415              CPU_SR_ALLOC();
   1416          
   1417          
   1418          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1419              if (perr == (LIB_ERR *)0) {
   1420                  CPU_SW_EXCEPTION(;);
   1421              }
   1422          #endif
   1423          
   1424                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   1425          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   1426              if (pmem_pool == (MEM_POOL *)0) {
   1427                 *perr = LIB_MEM_ERR_NULL_PTR;
   1428                  return;
   1429              }
   1430          
   1431              if (pmem_blk == (void *)0) {
   1432                 *perr = LIB_MEM_ERR_NULL_PTR;
   1433                  return;
   1434              }
   1435          #endif
   1436          
   1437              CPU_CRITICAL_ENTER();
   1438          
   1439          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1440              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1441                  CPU_CRITICAL_EXIT();
   1442                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1443                  return;
   1444              }
   1445          
   1446              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   1447              if (addr_valid != DEF_OK) {
   1448                  CPU_CRITICAL_EXIT();
   1449                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1450                  return;
   1451              }
   1452          
   1453              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   1454                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   1455                      CPU_CRITICAL_EXIT();
   1456                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   1457                      return;
   1458                  }
   1459              }
   1460          #endif
   1461          
   1462              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
   1463                  CPU_CRITICAL_EXIT();
   1464                 *perr = LIB_MEM_ERR_POOL_FULL;
   1465                  return;
   1466              }
   1467          
   1468                                                                              /* ------------- FREE MEM BLK TO POOL ------------- */
   1469              pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
   1470              pmem_pool->BlkIx++;
   1471          
   1472              CPU_CRITICAL_EXIT();
   1473          
   1474             *perr = LIB_MEM_ERR_NONE;
   1475          }
   1476          #endif
   1477          
   1478          
   1479          /*$PAGE*/
   1480          /*
   1481          *********************************************************************************************************
   1482          *********************************************************************************************************
   1483          *                                           LOCAL FUNCTIONS
   1484          *********************************************************************************************************
   1485          *********************************************************************************************************
   1486          */
   1487          
   1488          /*
   1489          *********************************************************************************************************
   1490          *                                      Mem_PoolBlkIsValidAddr()
   1491          *
   1492          * Description : Calculates if a given memory block address is valid for the memory pool.
   1493          *
   1494          * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
   1495          *               ---------   Argument validated in Mem_PoolBlkFree().
   1496          *
   1497          *               pmem_blk    Pointer to memory block address to validate.
   1498          *               --------    Argument validated in Mem_PoolBlkFree().
   1499          *
   1500          * Return(s)   : DEF_YES, if valid memory pool block address.
   1501          *
   1502          *               DEF_NO,  otherwise.
   1503          *
   1504          * Caller(s)   : Mem_PoolBlkFree().
   1505          *
   1506          * Note(s)     : none.
   1507          *********************************************************************************************************
   1508          */
   1509          
   1510          #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
   1511               (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))
   1512          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
   1513                                                       void      *pmem_blk)
   1514          {
   1515              CPU_INT08U   *ppool_addr_first;
   1516              void         *ppool_addr_start;
   1517              void         *ppool_addr_end;
   1518              CPU_SIZE_T    align_offset;
   1519              CPU_SIZE_T    blk_align;
   1520              CPU_SIZE_T    blk_align_offset;
   1521              CPU_SIZE_T    blk_size;
   1522              CPU_SIZE_T    mem_align;
   1523              CPU_SIZE_T    mem_align_offset;
   1524              CPU_SIZE_T    mem_diff;
   1525              CPU_BOOLEAN   addr_valid;
   1526          
   1527          
   1528              ppool_addr_start = pmem_pool->PoolAddrStart;
   1529              ppool_addr_end   = pmem_pool->PoolAddrEnd;
   1530          
   1531              if ((pmem_blk < ppool_addr_start) ||
   1532                  (pmem_blk > ppool_addr_end)) {
   1533                  return (DEF_NO);
   1534              }
   1535          
   1536              blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
   1537              align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
   1538              if (align_offset != 0u) {
   1539                  mem_align_offset = blk_align - align_offset;
   1540              } else {
   1541                  mem_align_offset = 0u;
   1542              }
   1543          
   1544              blk_size     = pmem_pool->BlkSize;
   1545              align_offset = blk_size % blk_align;
   1546              if (align_offset != 0u) {
   1547                  blk_align_offset = blk_align - align_offset;
   1548              } else {
   1549                  blk_align_offset = 0u;
   1550              }
   1551          
   1552              ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
   1553              mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
   1554              mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
   1555          
   1556              addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
   1557          
   1558              return (addr_valid);
   1559          }
   1560          #endif
   1561          
   1562          
   1563          /*$PAGE*/
   1564          /*
   1565          *********************************************************************************************************
   1566          *                                      Mem_PoolSegCalcTotSize()
   1567          *
   1568          * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
   1569          *
   1570          *
   1571          *                       -----                     ======================  ---
   1572          *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
   1573          *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
   1574          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
   1575          *                         |                       |  /  /  /  /  /  /  |   v
   1576          *                         |                       ======================  ---
   1577          *                         |                       |                    |   ^
   1578          *                         |                       |                    |   |
   1579          *                         |                       |     Mem Blk #1     |   |        Blk Size
   1580          *                         |                       |                    |   |     (see Note #1c)
   1581          *                         |                       |                    |   v
   1582          *                         |                       ----------------------  ---
   1583          *                         |                       |  /  /  /  /  /  /  |   ^
   1584          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   1585          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   1586          *                         |                       |  /  /  /  /  /  /  |   v
   1587          *                         |                       ======================  ---
   1588          *                                                 |         .          |
   1589          *                     Total Size                  |         .          |
   1590          *                   (see Note #2c)                |         .          |
   1591          *                                                 ======================  ---
   1592          *                         |                       |                    |   ^
   1593          *                         |                       |                    |   |
   1594          *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
   1595          *                         |                       |                    |   |     (see Note #1c)
   1596          *                         |                       |                    |   v
   1597          *                         |                       ----------------------  ---
   1598          *                         |                       |  /  /  /  /  /  /  |   ^
   1599          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   1600          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   1601          *                         |                       |  /  /  /  /  /  /  |   v
   1602          *                         |                       ======================  ---
   1603          *                         |                       |                    |   ^
   1604          *                         |                       |                    |   |
   1605          *                         |                       |     Mem Blk #N     |   |        Blk Size
   1606          *                         |                       |                    |   |     (see Note #1c)
   1607          *                         v                       |                    |   v
   1608          *                       -----                     ======================  ---
   1609          *
   1610          *               where
   1611          *
   1612          *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
   1613          *
   1614          *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
   1615          *
   1616          *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
   1617          *
   1618          *                   (d) Align               Required block memory alignment     ('blk_align')
   1619          *
   1620          *                   (e) Mem Align Offset    Offset required to align first memory block
   1621          *
   1622          *                   (f) Blk Align Offset    Offset required to align every memory block
   1623          *
   1624          *
   1625          *               (2) The total size is calculated based on the following equations :
   1626          *
   1627          *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
   1628          *                   (a) Mem Align Offset  =  {
   1629          *                                            { (2) 0                          , if memory address is     aligned
   1630          *
   1631          *
   1632          *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
   1633          *                   (b) Blk Align Offset  =  {
   1634          *                                            { (2) 0                          , if memory block   is     aligned
   1635          *
   1636          *
   1637          *                   (c) Total Size        =   Mem Align Offset
   1638          *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
   1639          *                                         +   Blk Size
   1640          *
   1641          *
   1642          * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
   1643          *
   1644          *               blk_nbr     Number of memory blocks to allocate.
   1645          *               -------     Argument checked in Mem_HeapAlloc(),
   1646          *                                               Mem_PoolCreate().
   1647          *
   1648          *               blk_size    Size   of memory block  to allocate.
   1649          *               --------    Argument checked in Mem_HeapAlloc(),
   1650          *                                               Mem_PoolCreate().
   1651          *
   1652          *               blk_align   Required block word-boundary memory alignment (in octets).
   1653          *               ---------   Argument checked in Mem_HeapAlloc(),
   1654          *                                               Mem_PoolCreate().
   1655          *
   1656          * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
   1657          *
   1658          *               0,                                                                  otherwise.
   1659          *$PAGE*
   1660          * Caller(s)   : Mem_HeapAlloc(),
   1661          *               Mem_PoolCreate().
   1662          *
   1663          * Note(s)     : none.
   1664          *********************************************************************************************************
   1665          */
   1666          
   1667          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1668          static  CPU_SIZE_T  Mem_PoolSegCalcTotSize (void        *pmem_addr,
   1669                                                      CPU_SIZE_T   blk_nbr,
   1670                                                      CPU_SIZE_T   blk_size,
   1671                                                      CPU_SIZE_T   blk_align)
   1672          {
   1673          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1674              CPU_SIZE_T  blk_size_mem_aligned;
   1675              CPU_SIZE_T  blk_size_aligned;
   1676              CPU_SIZE_T  blk_size_aligned_nbr;
   1677              CPU_SIZE_T  blk_size_tot;
   1678          #endif
   1679              CPU_SIZE_T  align_offset;
   1680              CPU_SIZE_T  mem_align_offset;
   1681              CPU_SIZE_T  blk_align_offset;
   1682              CPU_SIZE_T  size_tot;
   1683          
   1684                                                                              /* Calc mem align (see Note #2a).                   */
   1685              align_offset = (CPU_ADDR)pmem_addr % blk_align;
   1686              if (align_offset != 0u) {
   1687                  mem_align_offset = blk_align - align_offset;
   1688              } else {
   1689                  mem_align_offset = 0u;
   1690              }
   1691                                                                              /* Calc blk align (see Note #2b).                   */
   1692              align_offset = blk_size % blk_align;
   1693              if (align_offset != 0u) {
   1694                  blk_align_offset = blk_align - align_offset;
   1695              } else {
   1696                  blk_align_offset = 0u;
   1697              }
   1698                                                                              /* Calc tot size  (see Note #2c).                   */
   1699              size_tot = mem_align_offset + ((blk_size + blk_align_offset) * (blk_nbr - 1)) + blk_size;
   1700          
   1701          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
   1702              blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
   1703              if ((blk_size_mem_aligned < mem_align_offset) ||
   1704                  (blk_size_mem_aligned < blk_size)) {
   1705                  return (0u);
   1706              }
   1707          
   1708              if (blk_nbr > 1) {
   1709                  blk_size_aligned = blk_size + blk_align_offset;
   1710                  if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
   1711                      (blk_size_aligned < blk_size)) {
   1712                      return (0u);
   1713                  }
   1714          
   1715                  blk_size_aligned_nbr = blk_size_aligned * (blk_nbr - 1);
   1716                  if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
   1717                      (blk_size_aligned_nbr < blk_align_offset) ||
   1718                      (blk_size_aligned_nbr < blk_size)) {
   1719                      return (0u);
   1720                  }
   1721          
   1722                  blk_size_tot = blk_size_aligned_nbr + blk_size;
   1723                  if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
   1724                      (blk_size_tot < blk_size)) {
   1725                      return (0u);
   1726                  }
   1727          
   1728                  if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
   1729                      (size_tot < blk_size_aligned_nbr) ||
   1730                      (size_tot < blk_size_tot)) {
   1731                      return (0u);
   1732                  }
   1733              }
   1734          #endif
   1735          
   1736              return (size_tot);
   1737          }
   1738          #endif
   1739          
   1740          
   1741          /*$PAGE*/
   1742          /*
   1743          *********************************************************************************************************
   1744          *                                         Mem_PoolSegAlloc()
   1745          *
   1746          * Description : Allocates memory from specific segment.
   1747          *
   1748          * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
   1749          *               ---------   Argument validated in Mem_HeapAlloc(),
   1750          *                                                 Mem_PoolCreate().
   1751          *
   1752          *               size        Size of memory to allocate.
   1753          *               ----        Argument validated in Mem_HeapAlloc(),
   1754          *                                                 Mem_PoolCreate().
   1755          *
   1756          *               align       Required starting word-boundary memory alignment (in octets).
   1757          *               -----       Argument validated in Mem_HeapAlloc(),
   1758          *                                                 Mem_PoolCreate().
   1759          *
   1760          * Return(s)   : Pointer to allocated memory, if NO error(s).
   1761          *
   1762          *               Pointer to NULL,             otherwise.
   1763          *
   1764          * Caller(s)   : Mem_HeapAlloc(),
   1765          *               Mem_PoolCreate().
   1766          *
   1767          * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
   1768          *
   1769          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1770          *
   1771          *                   (a) However, this function is already called within critical sections.
   1772          *********************************************************************************************************
   1773          */
   1774          
   1775          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1776          static  void  *Mem_PoolSegAlloc (MEM_POOL    *pmem_pool,
   1777                                           CPU_SIZE_T   size,
   1778                                           CPU_SIZE_T   align)
   1779          {
   1780              CPU_INT08U  *pmem_addr;
   1781              CPU_INT08U  *pmem_addr_next;
   1782              CPU_SIZE_T   mem_align;
   1783              CPU_SIZE_T   align_offset;
   1784              CPU_SIZE_T   size_tot;
   1785          
   1786          
   1787              pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
   1788          
   1789              mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
   1790          
   1791              if (mem_align != 0u) {
   1792                  align_offset = align - mem_align;
   1793              } else {
   1794                  align_offset = 0u;
   1795              }
   1796          
   1797              size_tot = align_offset + size;
   1798              if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficiemt mem seg size rem, ...            */
   1799                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   1800              }
   1801          
   1802          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1803              if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
   1804                  (size_tot < size)) {
   1805                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   1806              }
   1807          #endif
   1808          
   1809              pmem_addr_next = pmem_addr + size_tot;
   1810          
   1811          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1812              if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
   1813                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   1814              }
   1815          #endif
   1816          
   1817              pmem_addr += align_offset;                                      /* Align mem addr.                                  */
   1818          
   1819              pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
   1820              pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
   1821          
   1822              return ((void *)pmem_addr);
   1823          }
   1824          #endif
   1825          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Mem_Clr
         0   -> Mem_Set
      12   Mem_Cmp
       0   Mem_Init
       4   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  Mem_Clr
     148  Mem_Cmp
       2  Mem_Init
      80  Mem_Set

 
 234 bytes in section .text
 
 234 bytes of CODE memory

Errors: none
Warnings: none
