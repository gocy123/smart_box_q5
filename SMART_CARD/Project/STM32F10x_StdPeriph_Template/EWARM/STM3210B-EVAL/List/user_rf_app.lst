###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:43:45
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\rf\user_rf_app.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\rf\user_rf_app.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\user_rf_app.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\user_rf_app.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\rf\user_rf_app.c
      1          //static head file
      2          #include <stdio.h>
      3          #include <stdarg.h>
      4          #include <string.h>
      5          #include <stdint.h>
      6          #include <math.h>
      7          
      8          //porting head files
      9          #include "heads.h"
     10          
     11          #include "stm32f10x_iwdg.h"
     12          
     13          
     14          #include "user_debug_app.h"
     15          #include "user_internal_flash.h"
     16          #include "os.h"
     17          #include "os_cfg_app.h"
     18          #include "user_rf_app.h"
     19          
     20          #include "Encoding.h"
     21          #include "Encoding_v8.h"
     22          
     23          
     24          
     25          
     26          
     27          //#define UHFFILTER             	(0x0014)  //40us
     28          #define UHFFILTER             	(0x0014)  //40us
     29          #define UHFPLUSE_V7           	(0x0127)  //590us
     30          #define UHFMAST_V7            	(0x00C4)  //
     31          
     32          #define REMOTE_MARK_V8			(0xE3)
     33          #define REMOTE_MARK_V7			(0xC1)
     34          
     35          volatile bool TIM2_counting_now_flag = FALSE; //TIM2定时器工作标志
     36          static u8 	Data[15];        		//RF接收数据保存
     37          static REMOTE_STATUS 		Remote={0}; 
     38          static u8 ClearKeyValueCount = 0;
     39          static u8 RemoteLastData = 0;  //遥控器数据长帧与短帧的共同数据
     40          static u16 RemoteKeyValue = 0; //遥控器键值
     41          static CAR_POWER_STATUS 	car_power=CAR_OFF;
     42          static u8  smart_card_need_dly_pwr_off_flag=0;
     43          static u8  smart_card_pwr_status=0;
     44          static u32 remote_pwr_on_card_timestamp=0;
     45          static u8 key_sn=0;
     46          static uint32_t MCURegID=0;
     47          static uint32_t factory_trace_id=0;
     48          static u8 on_change_flag=0xFF;
     49          static uint8_t on_status=0;
     50          static u8 remote_started_flag=0;
     51          
     52          
     53          static uint32_t KEY_TRUNK_L_time_stamp=0;
     54          static uint32_t KEY_UNLOCK_L_time_stamp=0;
     55          static uint32_t KEY_LOCK_L_time_stamp=0;
     56          
     57          
     58          #if 1
     59          #define  CHECK_BUF_LEN 20
     60          static uint8_t	 check_bat_vol_ok_flag=0xFF;
     61          static uint16_t check_bat_vol_buf[CHECK_BUF_LEN]={0};
     62          static uint8_t	 check_bat_vol_buf_offset=0;
     63          static uint8_t	 bat_cali_ok_flag=0;
     64          static uint32_t bat_off_average=0;
     65          static uint32_t bat_engined_average=0;
     66          static uint32_t bat_current=0;
     67          static uint32_t start_calibrate_bat_timestamp=0;
     68          static uint32_t bat_dif_val=0;
     69          #endif
     70          
     71          
     72          
     73          
     74          
     75          
     76          void TIM2_IRQHandler(void)
     77          {
     78          	if(TIM_GetITStatus(TIM2, TIM_IT_Update)!=RESET) 
     79          	{
     80          		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
     81          		TIM_Cmd(TIM2, DISABLE);//禁能定时器
     82          		TIM2_counting_now_flag = FALSE;
     83          	}
     84          }
     85          
     86          void DelayXms(vu32 nTime)
     87          {
     88          	OS_ERR os_err;
     89          	OSTimeDly(nTime, OS_OPT_TIME_DLY, &os_err);
     90          }
     91          
     92          void power_on_smart_card(void)
     93          {
     94          	OS_ERR os_err;
     95          	
     96          	InfoPrintf("power_on_smart card()\r\n");
     97          	KEY_PWR_ON;
     98          	smart_card_pwr_status=1;
     99          	remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
    100          	smart_card_need_dly_pwr_off_flag=1;
    101          }
    102          
    103          void power_off_smart_card(void)
    104          {
    105          	InfoPrintf("power_off_smart card()\r\n");
    106          	KEY_PWR_OFF;
    107          	smart_card_need_dly_pwr_off_flag=0;
    108          	smart_card_pwr_status=0;
    109          }
    110          
    111          
    112          /*******************************************************************************
    113          * Function Name  : DriveAlarm
    114          * Description    : 设备蜂鸣器鸣叫
    115          * Input          : index - 鸣叫次数
    116                             time - 鸣叫持续时间
    117          * Output         : None
    118          * Return         : None 
    119          *******************************************************************************/
    120          void DriveAlarm(u8 index, u16 time) 
    121          {
    122          	while(index) 
    123          	{
    124          		BEEP_ON;   
    125          		DelayXms(time);  
    126          		BEEP_OFF; 
    127          		
    128          		if(--index == 0) 
    129          		{
    130          			break; //鸣叫结束
    131          		}
    132          		else
    133          		{
    134          			DelayXms(time);  //延时，下次鸣叫
    135          		}
    136          		IWDG_ReloadCounter();
    137          	}
    138          }
    139          
    140          void AddTimeDriveAlarm(u8 index, u16 time) 
    141          {
    142          	while(index) 
    143          	{
    144          		BEEP_ON; 
    145          		//LED_ON;
    146          		DelayXms(time);  
    147          		BEEP_OFF; 
    148          		//LED_OFF;
    149          		
    150          		if(--index == 0) 
    151          		{
    152          			break; //鸣叫结束
    153          		}
    154          		else
    155          		{
    156          			DelayXms(time);  //延时，下次鸣叫
    157          		}
    158          	}
    159          }
    160          
    161          void LED_flash(u8 index, u16 time) 
    162          {
    163          	while(index) 
    164          	{
    165          		//LED_ON;
    166          		DelayXms(time);  
    167          		//LED_OFF;
    168          		
    169          		if(--index == 0) 
    170          		{
    171          			break; //鸣叫结束
    172          		}
    173          		else
    174          		{
    175          			DelayXms(time);  //延时，下次鸣叫
    176          		}
    177          	}
    178          }
    179          
    180          void control_car_power(CAR_POWER_STATUS ctl) 
    181          {
    182          	OS_ERR os_err;
    183          	
    184          	InfoPrintf("control_car_power(%d)\r\n",ctl);
    185          	switch(ctl)
    186          	{
    187          		case CAR_OFF: //OFF档
    188          			CAR_START_KEY_ON;
    189          			DelayXms(1000);
    190          			CAR_START_KEY_OFF;
    191          			DelayXms(100);
    192          			CAR_START_KEY_ON;
    193          			DelayXms(300);
    194          			CAR_START_KEY_OFF;
    195          			break; 
    196          		case CAR_ACC: //ACC档
    197          			//START_OFF; 
    198          			//ON_OFF; 
    199          			//ACC_ON; 
    200          			DelayXms(50);
    201          			break;  
    202          		case CAR_ON : //ON档
    203          			//ACC_ON; 
    204          			//ON_ON;  
    205          			DelayXms(700);
    206          			//START_OFF; 
    207          			break;  
    208          		case CAR_RUN: //点火
    209          			CAR_START_KEY_ON;
    210          			DelayXms(800);
    211          			CAR_START_KEY_OFF;
    212          			DelayXms(100);
    213          			break; 
    214          		default: 
    215          			break;
    216            	}
    217          }
    218          
    219          
    220          /*******************************************************************************
    221          * Function Name  : ctl_car_remote_start_or_stop
    222          * Description    : 设置汽车遥控点火
    223          * Input          : None
    224          * Output         : None
    225          * Return         : None 
    226          *******************************************************************************/
    227          void ctl_car_remote_start(void) 
    228          {	
    229          	OS_ERR os_err;
    230          	InfoPrintf("ctl_car_remote_start\r\n");
    231          
    232          	if(car_power != CAR_RUN)  	//未发动
    233          	{
    234          		if(smart_card_pwr_status!=1)
    235          		{
    236          			power_on_smart_card();//智能卡2秒钟后要断电，防止砸玻璃偷车开走
    237          		}
    238          		
    239          		DelayXms(300);
    240          		InfoPrintf("车辆未发动\r\n");		
    241          		InfoPrintf("模拟踩刹车\r\n");
    242          		BREAK_ON;
    243          		KEY_LOCK_ON;
    244          		DelayXms(600);
    245          		KEY_LOCK_OFF;
    246          		InfoPrintf("远程发动!!!!!!\r\n");
    247          		control_car_power(CAR_RUN);
    248          		InfoPrintf("模拟踩刹车释放!!\r\n");
    249          		DelayXms(400);//这个延时必须有
    250          		BREAK_OFF;
    251          		InfoPrintf("远程启动OK\r\n\r\n");
    252          		remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
    253          	}
    254          	else
    255          	{
    256          		InfoPrintf("车辆已启动，无需再次启动\r\n\r\n");
    257          	}
    258          }
    259          
    260          void ctl_car_remote_stop(void) 
    261          {	
    262          	InfoPrintf("ctl_car_remote_stop...\r\n");
    263          	control_car_power(CAR_OFF);
    264          	DelayXms(200);	
    265          	InfoPrintf("熄火成功\r\n");
    266          
    267          }
    268          
    269          
    270          
    271          void GPIO_Configuration(void)
    272          {
    273          	#if 1
    274          	GPIO_InitTypeDef GPIO_InitStructure;
    275          
    276          	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  //失能JTAG,使能SWD
    277          
    278          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    279          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    280          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    281          	GPIO_Init(GPIOA, &GPIO_InitStructure); 
    282          	GPIO_Init(GPIOB, &GPIO_InitStructure); 
    283          
    284          
    285          	//A口 输入
    286          	#ifdef EN_ADC1_CHN1
    287          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_BAT_CHECK;
    288          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    289          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    290          	#else
    291          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_ON_DETECT;
    292          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    293          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    294          	#endif
    295          	//A口 上拉输入
    296          	GPIO_InitStructure.GPIO_Pin =  GPIO_PIN_RX_MISO ;
    297          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    298          	GPIO_Init(GPIOA, &GPIO_InitStructure); 
    299          	
    300          	//A口 悬浮输入
    301          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_RX_RX|GPIO_PIN_CHECK_BREAK; 
    302          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    303          	GPIO_Init(GPIOA, &GPIO_InitStructure); 
    304          	
    305          	//A口 推挽输出
    306          	GPIO_InitStructure.GPIO_Pin= GPIO_PIN_RX_SCK
    307          								|GPIO_PIN_RX_SEL
    308          								|GPIO_PIN_RX_MOSI;
    309          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    310          	GPIO_Init(GPIOA, &GPIO_InitStructure); 
    311          
    312          	//A口 上啦输入
    313          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_RX_RX; 
    314          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    315          	GPIO_Init(GPIOA, &GPIO_InitStructure); 
    316          	
    317          	//A口 复用推挽输出
    318          
    319          
    320          	
    321          
    322          	//B口 下拉输入
    323          	//GPIO_InitStructure.GPIO_Pin = GPIO_PIN_STARTKEY;
    324          	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
    325          	//GPIO_Init(GPIOB, &GPIO_InitStructure);
    326          	
    327          	//B口 上拉输入
    328          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_ACC_DETECT|GPIO_PIN_STUDYKEY;
    329          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    330          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    331          
    332          	//B口 悬浮输入
    333          	
    334          	//B口 开漏输出
    335          	//GPIO_InitStructure.GPIO_Pin = GPIO_PIN_LED;
    336          	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    337          	//GPIO_Init(GPIOB, &GPIO_InitStructure); 
    338          	
    339          	//B口 推挽输出
    340          	GPIO_InitStructure.GPIO_Pin =   GPIO_PIN_START_KEY|GPIO_PIN_BREAK_OUT |GPIO_PIN_BEEP|
    341          	                                GPIO_PIN_KEY_PWR|KEY_PIN_UNLOCK|KEY_PIN_LOCK|KEY_PIN_TRUNK|KEY_PIN_ALARM;
    342          	GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;
    343          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    344          	
    345          	//B口 复用推挽输出
    346          	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_125KL| GPIO_PIN_125KR;
    347          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    348          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    349          	
    350          	KEY_UNLOCK_OFF;
    351          	KEY_LOCK_OFF;;
    352          	KEY_TRUNK_OFF;
    353          	KEY_ALARM_OFF;
    354          	CAR_START_KEY_OFF;
    355          	BEEP_OFF;
    356          	#endif
    357          }
    358          
    359          
    360          uc8 BasePlus[42] = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0};	//LF信号引导
    361          u16 lf_dst_WUPA=0x4148;
    362          u16 lf_dst_WUPB=0x0000;
    363          u8  main_key_sn=0;
    364          u8 enable_lf_tx_flag=1;
    365          /*******************************************************************************
    366          * Function Name : LFSendData
    367          * Description 	: 低频编码发送物理层函数
    368          * Input         : lfdata - 发送的数据指针
    369                            lfcount - 发送的数据字节数
    370                            outchannel - 选择发送的通道号
    371          * Output        : None
    372          * Return        : None
    373          *******************************************************************************/
    374          void LFSendData(u8 *lfdata, u8 lfcount, u16 outchannel) 
    375          {
    376          	//#define LFSendData_print
    377          	u8 index = 0;
    378          	u16 t2cycle = 64;
    379          	u8  DataPlus[96]={0};
    380          	//u32 i;
    381          	u8 a,b;
    382          	OS_ERR os_err;
    383          
    384          	//return;
    385          
    386          	OSSchedLock(&os_err);
    387          
    388          	#ifdef LFSendData_print
    389          	InfoPrintf("LFSendData(");
    390          	for(a=0;a<lfcount;a++)
    391          	{
    392          		InfoPrintf("%02X,",lfdata[a]);
    393          	}
    394          	InfoPrintf(")\r\n");
    395          	#else
    396          	//InfoPrintf(".");
    397          	#endif
    398          	
    399          	/*
    400          	字节内是大端(高位在前)方式传送，字节间是小端方式
    401          	*/
    402          
    403          	//每个字节的数据需要用16位的bit流来表示,所以需要乘以16
    404          	//(曼码:一位需要一高一低的电平,所以一个字节8位,8x2==16); zgc add
    405          	lfcount = lfcount << 4; 			
    406          	for(index = 0; index < lfcount; ) 	//将发送的数据，转化成比特流数组
    407          	{
    408          		a=lfdata[index >> 4];
    409          		b=(1 << (7 - ((index >> 1) & 0x07)));
    410          	
    411          		//if((lfdata[index >> 4] & (1 << (7 - ((index >> 1) & 0x07)))) != 0) 
    412          		if((a & b) != 0) 
    413          		{
    414          			DataPlus[index++] = 0;
    415          			DataPlus[index++] = 1;
    416          		}
    417          		else 
    418          		{
    419          			DataPlus[index++] = 1;
    420          			DataPlus[index++] = 0;
    421          		}
    422          	}
    423          	
    424          	TIM2_counting_now_flag = TRUE;
    425          	TIM_Cmd(TIM2, ENABLE);
    426          	//NVIC_SETFAULTMASK();
    427          	TIM_Cmd(LF125K_TIMx, ENABLE);
    428          	TIM_CtrlPWMOutputs(LF125K_TIMx, ENABLE);	//开启定时器计数
    429          	TIM_CCxCmd(LF125K_TIMx, LF125KR_Channelx, TIM_CCx_Disable);
    430          	TIM_CCxCmd(LF125K_TIMx, LF125KL_Channelx, TIM_CCx_Disable);
    431          	TIM_SetCounter(TIM2, 0);//清零  
    432          	__disable_irq();
    433          	
    434          	//发送引导脉冲
    435          	for(index = 0; index < 42; index++) 	
    436          	{
    437          		if(index == 0) 
    438          		{
    439          			TIM_CCxCmd(LF125K_TIMx, outchannel, BasePlus[index] == 0 ? TIM_CCx_Disable : TIM_CCx_Enable);
    440          		}
    441          		else 
    442          		{
    443          			if(BasePlus[index] == 0) 
    444          			{
    445          				TIM_CCxCmd(LF125K_TIMx, outchannel, TIM_CCx_Disable);
    446          			}
    447          			else if(BasePlus[index - 1] == 0) //连续两个1，中间不再重新启动PWM，防止波形畸变
    448          			{
    449          				TIM_CCxCmd(LF125K_TIMx, outchannel, TIM_CCx_Enable);
    450          			}
    451          		}
    452          		
    453          		while(TIM_GetCounter(TIM2) < t2cycle && TIM2_counting_now_flag == TRUE) 
    454          		{
    455          		}
    456          		
    457          		t2cycle += 64;  //2*64=128us
    458          	}
    459          
    460          	#if 1
    461          	//发送数据脉冲
    462          	for(index = 0; index < lfcount; index++) 	
    463          	{
    464          		if(index == 0) 
    465          		{
    466          			TIM_CCxCmd(LF125K_TIMx, outchannel, DataPlus[index] == 0 ? TIM_CCx_Disable : TIM_CCx_Enable);
    467          		}
    468          		else 
    469          		{
    470          			if(DataPlus[index] == 0) 
    471          			{
    472          				TIM_CCxCmd(LF125K_TIMx, outchannel, TIM_CCx_Disable);
    473          			}
    474          			else if(DataPlus[index - 1] == 0)//连续两个1，中间不再重新启动PWM，防止波形畸变 
    475          			{
    476          				TIM_CCxCmd(LF125K_TIMx, outchannel, TIM_CCx_Enable);
    477          			}
    478          		}
    479          		
    480          		while(TIM_GetCounter(TIM2) < t2cycle && TIM2_counting_now_flag == TRUE) 
    481          		{
    482          		}
    483          		
    484          		t2cycle += 64;	//2*64=128us
    485          	}
    486          	#endif
    487          	__enable_irq();
    488          	
    489          	TIM_CCxCmd(LF125K_TIMx, outchannel, TIM_CCx_Disable);
    490          	TIM_Cmd(TIM2, DISABLE);
    491          	//while(1);
    492          
    493          
    494          	
    495          	TIM_Cmd(LF125K_TIMx, DISABLE);
    496          	TIM2_counting_now_flag = FALSE;
    497          
    498          	
    499          	
    500          	OSSchedUnlock(&os_err);
    501          
    502          	
    503          }
    504          
    505          void SendAwakeLF(void) 
    506          {
    507          	u8 LFData[6];
    508          	#if 0
    509          	//static u8 cnt=0;
    510          	//cnt++;
    511          	//if(cnt%3!=0)return;
    512          	
    513          	if(enable_lf_tx_flag==0)
    514          	{
    515          		InfoPrintf(".");
    516          		return;
    517          	}
    518          	
    519          	if((READ_STUDYKEY == Bit_RESET))//&&(StudyTime<STUDY_TIME*2))   //按住学习键，停发LF
    520          	{
    521          		return;
    522          	}
    523          	
    524          	if(car_power == CAR_RUN)// && Car->remote_started == FALSE)  //按键发动状态,停发LF
    525          	{
    526          		//InfoPrintf("车已本地启动，不发WAKE UP 帧\r\n");
    527          		return;
    528          	}
    529          	
    530          	if(Remote.Index > 2) 
    531          	{
    532          		Remote.Index = 0;
    533          	}
    534          	#endif
    535          
    536          	//InfoPrintf("发送低频侦测数据:\r\n");
    537          	LFData[0] = (u8)(lf_dst_WUPA>>8);
    538          	LFData[1] = (u8)lf_dst_WUPA;
    539          	//LFData[0] = (u8)(0x5555>>8);
    540          	//LFData[1] = (u8)0x5555;	
    541          	LFData[2] = main_key_sn;
    542          	LFData[3] = 0x88;
    543          
    544          	//LFData[4] = 0x55;
    545          	//LFData[5] = 0xa5;
    546          
    547          	{
    548          	static u8 cnt=0;
    549          	cnt++;
    550          	if(cnt%8==0)
    551          	InfoPrintf("AWAKE:(KEY total:%d)(ID:%02X,%02X)(DATA:%02X,%02X)\r\n",Remote.Totle,LFData[0],LFData[1],LFData[2],LFData[3]);	
    552          	}
    553          
    554          	LFSendData(LFData, 4, LF125KR_Channelx);	//LF通道1发送，2字节
    555          	//LFSendData(LFData, 4, LF125KR_Channelx);	//LF通道1发送，2字节
    556          	//DelayXms(5);
    557          	//LFSendData(LFData, 4, LF125KL_Channelx);	//LF通道2发送，2字节
    558          	LFSendData(LFData, 4, LF125KL_Channelx);	//LF通道2发送，2字节
    559          	//DelayXms(5);
    560          }
    561          
    562          /*
    563          通过0000ID 发送唤醒ID给钥匙，钥匙接收到此唤醒ID后，保存，并配置此ID到channel 1,
    564          之后主板将循环发送此ID，以唤醒钥匙。
    565          */
    566          u8 SendStudyLF(void) 
    567          {
    568          	u8 LFData[6];
    569          	u8 sn;
    570          	//InfoPrintf("-");	
    571          	IWDG_ReloadCounter();	//喂狗
    572          	if(car_power == CAR_RUN )//&& Car->remote_started == FALSE)  //按键发动状态,停发LF
    573          	{
    574          		InfoPrintf("cancel B\r\n");
    575          		return 1;
    576          	}
    577          	
    578          	if(Remote.Index > 2) 
    579          	{
    580          		Remote.Index = 0;
    581          	}
    582          
    583          	LFData[0]=0x00;
    584          	LFData[1]=0x00;
    585          	LFData[2] = (u8)(lf_dst_WUPA>>8);
    586          	LFData[3] = (u8)lf_dst_WUPA;
    587          	
    588          	LFData[4] = key_sn;	
    589          
    590          	LFData[5] = ~key_sn;	
    591          	
    592          	InfoPrintf("发送低频学习按键命令:(%02X,%02X,%02X,%02X,%02X)\r\n",LFData[0],LFData[1],LFData[2],LFData[3],LFData[4]);
    593          	LFSendData(LFData, 5, LF125KR_Channelx);	//LF通道1发送，2字节
    594          	LFSendData(LFData, 5, LF125KL_Channelx);	//LF通道2发送，2字节
    595          	LFSendData(LFData, 5, LF125KR_Channelx);	//LF通道1发送，2字节
    596          	LFSendData(LFData, 5, LF125KL_Channelx);	//LF通道2发送，2字节
    597          
    598          	return 0;
    599          }
    600          u8 	RangData[4] = {0,0,0,0};//START_KEY LF随机数组
    601          void RangVlue(u8* rangdata) 
    602          {
    603          	OS_ERR os_err;
    604            u32 rtcvlue = user_get_os_time();//获取当前RTC时间
    605            
    606            rangdata[0] = (u8)((rtcvlue>>24) ^ (rtcvlue>>16) ^ (rtcvlue>>8) ^ rtcvlue ^ (MCURegID>>8) ^ MCURegID);
    607            rangdata[1] = rangdata[0] ^ rangdata[1] ^ rangdata[2] ^ 0xEC;
    608            rangdata[2] = Cal_crc8(rangdata, 2);
    609            rangdata[3] = 0x00;
    610          }
    611          
    612          void SendStartLF(void) 
    613          {
    614          	#define SendStartLF_print
    615          	u8 LFData[6];
    616          
    617          
    618          	LFData[0] = ~(u8)(lf_dst_WUPA>>8);
    619          	LFData[1] = ~(u8)lf_dst_WUPA;
    620          	
    621          	RangVlue(RangData); //生成随机数
    622          	RangData[3]=main_key_sn;
    623          	
    624          	*(u32 *)(&LFData[2]) = *(u32 *)(&RangData[0]);
    625          	InfoPrintf("发送启动校验...%02X,%02X,%02X,%02X,%02X,%02X\r\n",LFData[0],LFData[1],LFData[2],LFData[3],LFData[4],LFData[5]);	
    626          	LFSendData(LFData, 6, LF125KR_Channelx); //LF通道1发送，6字节
    627          	LFSendData(LFData, 6, LF125KL_Channelx); //LF通道2发送，6字节
    628          }
    629          
    630          
    631          /*******************************************************************************
    632          * Function Name : ValueRange
    633          * Description 	: 判断某数值是否在给定数值之间
    634          * Input         : compare - 待判定的值
    635                            original - 给定比较的值
    636                            power - 判定精度，1--50%内，2--25%内，3--12.5%内
    637          * Output        : None
    638          * Return        : bool - 在指定范围内TRUE
    639          *******************************************************************************/
    640          static bool ValueRange(u16 compare, u16 original, u8 power) 
    641          {
    642          	u16 finally = 0;
    643          	original = original >> 1;	//定时器TIM2为2us基本单位，如40ms = 20000
    644          	finally = original >> power;
    645          	if(compare > (original + finally) || compare < (original - finally)) 
    646          	{
    647          		return FALSE;
    648          	}
    649          	else 
    650          	{
    651          		return TRUE;
    652          	}
    653          }
    654          
    655          /*******************************************************************************
    656          * Function Name : UhfRevData_V7
    657          * Description   : RF接收解码，V7方式
    658          * Input         : uhfdata - 接收解码后数据存储地址
    659                            checktime - 持续接收解码时长：ms
    660          * Output        : None
    661          * Return        : u8 - 接收到的字节数
    662          *******************************************************************************/
    663          static u8 UhfRevData_V7(u8 *uhfdata, u16 checktime) 
    664          {
    665          	OS_ERR os_err;
    666          	u8  index = 0;
    667          	u8  uhf_bit_state = 0;
    668          	u16 uhf_pulse_h = 0;
    669          	u16 uhf_pulse_l = 0;
    670          	u16 filter_value;
    671          	u16 falling_timestamp;
    672          	u16 rising_timestamp;
    673          
    674          	OSSchedLock(&os_err);
    675          
    676          
    677          	rising_timestamp = U16_MAX - checktime * 500;			//2us基础时间
    678          	//fallingvalue = risingvalue;
    679          
    680          	TIM2_counting_now_flag = TRUE;
    681          	TIM_Cmd(TIM2, ENABLE);
    682          	TIM_SetCounter(TIM2, rising_timestamp);//设置定时器开始计时值,如果不做任何有效动作，15ms后，会产生溢出中断
    683          
    684          	while(1)//检测引导脉冲T=590us
    685          	{
    686          		//wait low
    687          		while(READ_UHF_IN == Bit_SET && TIM2_counting_now_flag == TRUE )	//循环检测脉冲，为低电平结束
    688          		{
    689          			//首次执行,假设一直是高电平，则15ms后超时，定时器也将失能
    690          		}
    691          
    692          		//low appeared,then filtering
    693          		filter_value = TIM_GetCounter(TIM2) + UHFFILTER;	//设置毛刺脉冲干扰时间间隔
    694          		while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE) 
    695          		{
    696          		}
    697          		while(READ_UHF_IN == Bit_SET && TIM2_counting_now_flag == TRUE) 
    698          		{
    699          		}
    700          
    701          		//low stable		
    702          		falling_timestamp = TIM_GetCounter(TIM2);
    703          		uhf_pulse_h = falling_timestamp - rising_timestamp; //获得高电平脉冲的时长 ----首次运行到这里时，无意义，不准确，因为不知道高电平是何时开始的。
    704          
    705          
    706          		//wait high
    707          		while(READ_UHF_IN == Bit_RESET && TIM2_counting_now_flag == TRUE) 
    708          		{
    709          		}
    710          
    711          		//high appear,then filtering
    712          		filter_value = TIM_GetCounter(TIM2) + UHFFILTER;
    713          		while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE) 
    714          		{
    715          		}
    716          		while(READ_UHF_IN == Bit_RESET && TIM2_counting_now_flag == TRUE) 
    717          		{
    718          		}
    719          
    720          		//high stable
    721          		rising_timestamp = TIM_GetCounter(TIM2);
    722          		uhf_pulse_l = rising_timestamp - falling_timestamp; 	//获得低电平脉冲的时长----首次运行到这里时，这个时长准确
    723          
    724          
    725          
    726          		//check timeout
    727          		if(TIM2_counting_now_flag == FALSE)//定时器超时，返回
    728          		{
    729          			OSSchedUnlock(&os_err);
    730          			return 0;
    731          		}
    732          		
    733          		//检测接收到的脉冲是否符合规定值，符合计数器加1，但是中间任何一次判断无效后,直接清零，重新从零开始
    734          		if(FALSE == ValueRange(uhf_pulse_h, 295, 2) || FALSE == ValueRange(uhf_pulse_l, 295, 2)) 
    735          		{
    736          			index=0;
    737          		}
    738          		else 
    739          		{
    740          			index++;
    741          		}
    742          		
    743          		if(index > 11)	 //连续符合规定值脉冲个数大于11，继续
    744          		{
    745          			//InfoPrintf("=======777=======");	
    746          			index = 0;
    747          			break;
    748          		}
    749          	}
    750          
    751          	//假设前面的15ms时间没用完，就已经检测到了11次引导脉冲了,
    752          	//那么TIM2_counting_now_flag 还是为TRUE，那么经过下面代码的赋值，会在130ms后在中断里被置为FALSE
    753          	
    754          	//假设刚好用完15ms，那么就会TIM2_counting_now_flag被置为FALSE
    755          
    756          
    757          	
    758          	TIM_SetCounter(TIM2, 0);	//设置定时器超时130ms 65536 * 2 us 约等于130ms
    759          	falling_timestamp= 0;
    760          	rising_timestamp= 0;
    761          	memset(uhfdata, 0x00, 15); //初始化数组
    762          	
    763          	TIM2_counting_now_flag = TRUE; //zgc add,如果不做任何赋值操作，130ms后，会被置为FALSE
    764          	
    765          	while(1)	//检测引导脉冲，1个周期，T=1.18ms
    766          	{
    767          		//wait high
    768          		while(READ_UHF_IN == Bit_RESET && TIM2_counting_now_flag == TRUE) 
    769          		{
    770          		}
    771          		//hign appear,then filtering...
    772          		filter_value = TIM_GetCounter(TIM2) + UHFFILTER;
    773          		while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE) 
    774          		{
    775          		}
    776          		while(READ_UHF_IN == Bit_RESET && TIM2_counting_now_flag == TRUE) 
    777          		{
    778          		}
    779          		//high stable
    780          		rising_timestamp = TIM_GetCounter(TIM2);
    781          		uhf_pulse_l = rising_timestamp - falling_timestamp; //获得高电平脉冲的时长
    782          
    783          		//wait low
    784          		while(READ_UHF_IN == Bit_SET && TIM2_counting_now_flag == TRUE)
    785          		{ 
    786          		}
    787          		//low appeared
    788          		filter_value = TIM_GetCounter(TIM2) + UHFFILTER;
    789          		while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE) 
    790          		{
    791          		}
    792          		while(READ_UHF_IN == Bit_SET && TIM2_counting_now_flag == TRUE) 
    793          		{
    794          		}
    795          		
    796          		//low stable
    797          		falling_timestamp = TIM_GetCounter(TIM2);
    798          		uhf_pulse_h = falling_timestamp - rising_timestamp; //获得低电平脉冲的时长
    799          
    800          		if(TIM2_counting_now_flag == FALSE) 
    801          		{
    802          			OSSchedUnlock(&os_err);
    803          			return 0;
    804          		}
    805          		
    806          		if(ValueRange(uhf_pulse_l, 590, 2) == TRUE && ValueRange(uhf_pulse_h, 590, 2) == TRUE) 
    807          		{
    808          			break; //only check one period ,check ok,break!
    809          		}
    810          	}
    811          
    812          	TIM_SetCounter(TIM2, 0);
    813          	filter_value = (UHFPLUSE_V7 >> 1);
    814          	while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE)	//延时1/2T
    815          	{
    816          	}
    817          
    818          	TIM_SetCounter(TIM2, 0);//130ms的计时
    819          	index = 2;
    820          	uhf_bit_state = 0;	//数据帧起始电平
    821          	falling_timestamp = 0;
    822          	rising_timestamp = 0;
    823          	do{
    824          		//wait pin voltage change
    825          		while(READ_UHF_IN == (BitAction)uhf_bit_state && TIM2_counting_now_flag == TRUE) 
    826          		{
    827          		}
    828          		//changed ,then filter...
    829          		filter_value = TIM_GetCounter(TIM2) + UHFFILTER;
    830          		while(TIM_GetCounter(TIM2) < filter_value && TIM2_counting_now_flag == TRUE) 
    831          		{
    832          		}
    833          		while(READ_UHF_IN == (BitAction)uhf_bit_state && TIM2_counting_now_flag == TRUE) 
    834          		{
    835          		}
    836          		//filter ok,and pin voltage changed to a stable state
    837          		rising_timestamp = TIM_GetCounter(TIM2);
    838          		uhf_pulse_l = rising_timestamp - falling_timestamp;	//获得一个脉冲的时长
    839          		if(rising_timestamp > 60000) 						//检测波形超过130ms，计数器清零，继续
    840          		{
    841          			rising_timestamp = 0;
    842          			TIM_SetCounter(TIM2, 2);			//130ms
    843          		}
    844          		
    845          		falling_timestamp = rising_timestamp;
    846          		uhf_bit_state = !uhf_bit_state;
    847          		if(uhf_pulse_l > (UHFPLUSE_V7 << 1))		//一帧数据完，检测到不符规定的脉冲，结束
    848          		{
    849          			break;
    850          		}
    851          
    852          		if(uhf_pulse_l < UHFMAST_V7) 
    853          		{
    854          			index++;
    855          			if(index & 0x01)
    856          			{
    857          				uhfdata[index >> 4] |= uhf_bit_state << (7 - ((index & 0x0F) >> 1));	//低字节，高位，在前
    858          			}
    859          		}
    860          		else 
    861          		{
    862          			index += 2;
    863          			uhfdata[index >> 4] |= uhf_bit_state << (7 - ((index & 0x0F) >> 1));
    864          		}
    865          
    866          	}while(index < 238 && TIM2_counting_now_flag == TRUE);
    867          	
    868          	TIM_Cmd(TIM2, DISABLE);
    869          	TIM2_counting_now_flag = FALSE;
    870          	OSSchedUnlock(&os_err);
    871          	return (index >> 4);
    872          }
    873          
    874          
    875          //bool HandRemoteUnlock;
    876          /*******************************************************************************
    877          * Description   : 验证遥控器数据是否合法
    878          * Input         : None
    879          * Output        : None
    880          * Return        : bool - TRUE, FALSE
    881          
    882          
    883             0  1  2  3  4  5  6  7  8  9  10 11 
    884          RX:50,E3,00,80,06,27,59,3A,38,58,9D,2A,
    885          -------------------------------------RX计步器值:006CDA03
    886          -----------------------------------本地计步器值:006CDA03
    887          -------------------------------------------差值:00000000
    888          计数步进不在范围内 
    889          *******************************************************************************/
    890          static bool CheckRemoteValueIsAllow(u32 *ptr) 
    891          {
    892          	#define CheckRemoteValueIsAllow_print
    893          	u32 rx_loq;
    894          	u32 calc_loq;
    895          	u32 rx_rf_id;
    896          	u8 i;
    897          
    898          
    899          	#ifdef CheckRemoteValueIsAllow_print
    900          	InfoPrintf("解密前:");
    901          	for(i=0;i<11+1;i++)
    902          	{
    903          		InfoPrintf("%02X,",Data[i]);
    904          	}
    905          	InfoPrintf("\r\n");
    906          	#endif	
    907          	
    908          	if(Data[1] == REMOTE_MARK_V8) 		//......解密数据
    909          	{
    910          		IV8_Decrypt(&Data[3]);///here
    911          	}
    912          	else if(Data[1] == REMOTE_MARK_V7)	//......解密数据
    913          	{ 
    914          		V7_Decrypt(&Data[3]);
    915          	}
    916          	else 
    917          	{
    918          	
    919          	};
    920          
    921          	#ifdef CheckRemoteValueIsAllow_print
    922          	InfoPrintf("解密后:");
    923          	for(i=0;i<11+1;i++)
    924          	{
    925          		InfoPrintf("%02X,",Data[i]);
    926          	}
    927          	InfoPrintf("\r\n");
    928          	#endif
    929          	
    930          
    931          	//解密了8个字节，存放与 Data[3~~10]
    932          	
    933          	if((Data[10] != (Data[11]&0xF0))&&(Data[11]!=0x7F)&&(Data[11]!=0x49))  //解密后键值与明文键值不一致 
    934          	{
    935          		#ifdef CheckRemoteValueIsAllow_print
    936          		InfoPrintf("解密后键值与明文键值不一致 \r\n");
    937          		#endif
    938          		
    939          		return FALSE;
    940          	}
    941          
    942          	Data[10] = 0x00;  //计步值的高8位清0 (bit[31~~24] =00000000b)
    943          
    944          	/*
    945          	当前Data[3~~10]:
    946          	  	50,E3,00,XX,XX,XX,XX,XX,XX,XX,00,2A,
    947          
    948          	Data[3~~6] : ID	
    949          	Data[7~~10]: 计步值 ,Data[10]=0x00	 0x09627B16 
    950          	
    951          	*/
    952          
    953          	//Remote.Totle=2;
    954          	//Remote.Rfid[0]=0x09627B16;
    955          	//Remote.Rfid[1]=0x08EF4ED9;
    956              
    957              
    958          	if(Remote.Totle>0)
    959          	{
    960          		#ifdef CheckRemoteValueIsAllow_print
    961          		InfoPrintf("---已学习遥控数量:%d---\r\n",Remote.Totle);
    962          
    963          		for(i=0;i<Remote.Totle;i++)
    964          		{
    965          			InfoPrintf("LOCAL[%d]=0x%08X\r\n",i,Remote.Rfid[i]);
    966          		}
    967          		
    968          		InfoPrintf("RX rfid= 0x%08X \r\n",(*(u32 *) &Data[3]));
    969          		#endif
    970          		rx_rf_id = *(u32 *) &Data[3];
    971          		for(u8 i = 0; i < Remote.Totle; i++)   //逐个与保存的遥控器属性比较
    972          		{
    973          			if(Remote.Rfid[i] == rx_rf_id)  //ID值一致
    974          			{
    975          				rx_loq = *(u32 *)(&Data[7]);//注意，Data[10]已被强制赋值为0x00
    976          				calc_loq = (rx_loq - Remote.Rfloq[i]) & 0x00FFFFFF;
    977          				#if 0
    978          				InfoPrintf("----本地计步器值:%08X\r\n",Remote.Rfloq[i]);
    979          				InfoPrintf("------RX计步器值:%08X\r\n",rx_loq);
    980          				InfoPrintf("------------差值:%08X\r\n",calc_loq);
    981          				#endif
    982          
    983          				
    984          				if(/*calc_loq > 800 ||*/ calc_loq == 0)
    985          				//if(calc_loq == 0)  
    986          				{
    987          					InfoPrintf("计数步进不在范围内--差值: %d \r\n",calc_loq);
    988          					
    989          					return FALSE;
    990          				}
    991          				else 
    992          				{		
    993          					#ifdef CheckRemoteValueIsAllow_print
    994          					InfoPrintf("遥控命令有效\r\n");
    995          					#endif		
    996          
    997          					if(ptr!=NULL)
    998          					{
    999          						*((u32*)(ptr))=rx_rf_id;
   1000          					}
   1001          					Remote.Rfloq[i] = *(u32 *) &Data[7];  	//记录新计数
   1002          					
   1003          					FLASH_WriteRemoteLOQ(&Remote);  		//保存到FLASH
   1004          					
   1005          					return TRUE;
   1006          				}
   1007          			}
   1008          
   1009          			#ifdef CheckRemoteValueIsAllow_print	
   1010          			if(i==Remote.Totle-1)
   1011          	       	{
   1012          	       	 	InfoPrintf("ID不匹配!!!!!LOCAL=%08X,RX=%08X!!!!\r\n\r\n\r\n",Remote.Rfid[i],(*(u32 *) &Data[3]));
   1013          	       	}
   1014          			#endif
   1015          		}
   1016          	}
   1017          	else
   1018             	{
   1019             		#ifdef CheckRemoteValueIsAllow_print
   1020             	 	InfoPrintf("未学习RF60的ID\r\n");
   1021          		#endif
   1022             	}
   1023          	
   1024          	return FALSE;
   1025          }
   1026          
   1027          void key_release(void)
   1028          {
   1029          	OS_ERR os_err;
   1030          	
   1031          	if(KEY_TRUNK_L_time_stamp!=0)
   1032          	{
   1033          		if(OSTimeGet(&os_err)-KEY_TRUNK_L_time_stamp>T_1S)
   1034          		{
   1035          			InfoPrintf("KEY_TRUNK_OFF\r\n");
   1036          			KEY_TRUNK_L_time_stamp=0;
   1037          			KEY_TRUNK_OFF;
   1038          		}
   1039          	}
   1040          	if(KEY_UNLOCK_L_time_stamp!=0)
   1041          	{
   1042          		if(OSTimeGet(&os_err)-KEY_UNLOCK_L_time_stamp>T_1S)
   1043          		{
   1044          			InfoPrintf("KEY_UNLOCK_OFF\r\n");
   1045          			KEY_UNLOCK_L_time_stamp=0;
   1046          			KEY_UNLOCK_OFF;
   1047          		}
   1048          	}		
   1049          	if(KEY_LOCK_L_time_stamp!=0)
   1050          	{
   1051          		if(OSTimeGet(&os_err)-KEY_LOCK_L_time_stamp>T_1S)
   1052          		{
   1053          			InfoPrintf("KEY_LOCK_OFF\r\n");
   1054          			KEY_LOCK_L_time_stamp=0;
   1055          			KEY_LOCK_OFF;
   1056          		}
   1057          	}
   1058          }
   1059          
   1060          static void RemoteKeyActive(u16 key) 
   1061          {	
   1062          	OS_ERR os_err;
   1063          	static uint32_t last_short_key_trunk_timestamp=0;
   1064          	static uint32_t last_short_key_unlock_timestamp=0;
   1065          	static uint32_t last_short_key_lock_timestamp=0;
   1066          
   1067          	switch(key) 
   1068          	{
   1069          		case KEY_BOX:
   1070          			InfoPrintf("接收到尾箱--短按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1071          			if(smart_card_pwr_status==0)
   1072          			{
   1073          				power_on_smart_card();
   1074          				DelayXms(600);
   1075          			}
   1076          			else
   1077          			{
   1078          				remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1079          			}
   1080          			last_short_key_trunk_timestamp=OSTimeGet(&os_err);
   1081          			KEY_TRUNK_ON;
   1082          			DelayXms(350);
   1083          			KEY_TRUNK_OFF;
   1084          			break;
   1085          		case KEY_BOX_L:
   1086          			if(last_short_key_trunk_timestamp+T_1S>OSTimeGet(&os_err))
   1087          			{
   1088          				last_short_key_trunk_timestamp=OSTimeGet(&os_err);
   1089          				InfoPrintf("接收到尾箱--长按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1090          				if(smart_card_pwr_status==0)
   1091          				{
   1092          					power_on_smart_card();
   1093          					DelayXms(700);
   1094          				}
   1095          				else
   1096          				{
   1097          					remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1098          				}
   1099          				
   1100          				KEY_TRUNK_ON;
   1101          				KEY_TRUNK_L_time_stamp=OSTimeGet(&os_err);
   1102          			}
   1103          			else
   1104          			{
   1105          				InfoPrintf("接收到(无效)尾箱长按键\r\n");
   1106          			}
   1107          			break;
   1108          		case KEY_UNLOCK:
   1109          			InfoPrintf("接收到解锁--短按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1110          			if(smart_card_pwr_status==0)
   1111          			{
   1112          				power_on_smart_card();
   1113          				DelayXms(800);
   1114          			}
   1115          			else
   1116          			{
   1117          				remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1118          			}
   1119          			last_short_key_unlock_timestamp=OSTimeGet(&os_err);
   1120          			KEY_UNLOCK_ON;
   1121          			smart_card_need_dly_pwr_off_flag=0;
   1122          			KEY_UNLOCK_L_time_stamp=OSTimeGet(&os_err);
   1123          			break;
   1124          		case KEY_UNLOCK_L: 
   1125          			if(last_short_key_unlock_timestamp+T_1S>OSTimeGet(&os_err))
   1126          			{
   1127          				last_short_key_unlock_timestamp=OSTimeGet(&os_err);
   1128          				InfoPrintf("接收到解锁--长按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1129          				if(smart_card_pwr_status==0)
   1130          				{
   1131          					power_on_smart_card();
   1132          					DelayXms(800);
   1133          				}
   1134          				else
   1135          				{
   1136          					remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1137          				}
   1138          				KEY_UNLOCK_ON;
   1139          				KEY_UNLOCK_L_time_stamp=OSTimeGet(&os_err);
   1140          				smart_card_need_dly_pwr_off_flag=0;
   1141          			}
   1142          			else
   1143          			{
   1144          				InfoPrintf("接收到(无效)解锁长按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1145          			}
   1146          			break;	
   1147          
   1148          			
   1149          		case KEY_LOCK:
   1150          			InfoPrintf("接收到锁车--短按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1151          			if(smart_card_pwr_status==0)
   1152          			{
   1153          				power_on_smart_card();
   1154          				DelayXms(800);
   1155          			}
   1156          			else
   1157          			{
   1158          				remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1159          				smart_card_need_dly_pwr_off_flag=1;
   1160          			}
   1161          			last_short_key_lock_timestamp=OSTimeGet(&os_err);
   1162          			KEY_LOCK_ON;
   1163          			KEY_LOCK_L_time_stamp=OSTimeGet(&os_err);
   1164          			break;
   1165          			
   1166          		case KEY_LOCK_L: 
   1167          			if(last_short_key_lock_timestamp+T_1S>OSTimeGet(&os_err))
   1168          			{
   1169          				last_short_key_lock_timestamp=OSTimeGet(&os_err);
   1170          				InfoPrintf("接收到锁车--长按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1171          				if(smart_card_pwr_status==0)
   1172          				{
   1173          					power_on_smart_card();
   1174          					DelayXms(800);
   1175          				}
   1176          				else
   1177          				{
   1178          					remote_pwr_on_card_timestamp=OSTimeGet(&os_err);
   1179          					smart_card_need_dly_pwr_off_flag=1;
   1180          				}
   1181          				KEY_LOCK_ON;
   1182          				KEY_LOCK_L_time_stamp=OSTimeGet(&os_err);
   1183          			}
   1184          			else
   1185          			{
   1186          				InfoPrintf("接收到(无效)锁车长按键,当前card_pwr=%d\r\n",smart_card_pwr_status);
   1187          			}
   1188          			break;		
   1189          			
   1190          		case REMOTE_KEY_START:
   1191          			DriveAlarm(1, 100);
   1192          			if(READ_ON_LINE==0)
   1193          			{
   1194          				InfoPrintf("接收到远程启动命令\r\n");
   1195          				ctl_car_remote_start();
   1196          				on_change_flag=0;
   1197          				on_status=READ_ON_LINE;
   1198          				remote_started_flag=1;
   1199          				
   1200          				if(on_status==0)
   1201          				{	
   1202          					DriveAlarm(10, 30);
   1203          					InfoPrintf("ON线无电,远程启动失败\r\n");
   1204          					remote_started_flag=0;	
   1205          				}
   1206          			}
   1207          			else
   1208          			{
   1209          				InfoPrintf("接收到远程启动命令，但不执行\r\n");
   1210          			}
   1211          			break;
   1212          			
   1213          		case REMOTE_KEY_STOP:
   1214          			DriveAlarm(1, 100);
   1215          			if((READ_ON_LINE==1)&&(on_change_flag==0)&&(remote_started_flag==1))
   1216          			{
   1217          				InfoPrintf("接收到远程熄火命令\r\n");
   1218          				ctl_car_remote_stop();
   1219          				on_status=READ_ON_LINE;
   1220          			}
   1221          			else
   1222          			{
   1223          				InfoPrintf("接收到远程熄火命令，但不执行\r\n");
   1224          			}
   1225          			break;
   1226          			
   1227          		case KEY_ALARM_L:
   1228          			break;
   1229          		default : 
   1230          			break;
   1231          	}
   1232          }
   1233          
   1234          
   1235          bool ActiveImmo(void) 
   1236          {
   1237          	u8 i,j;
   1238          	u8 index;
   1239          	u8 cnt;
   1240          	u8 err=0;
   1241          	u32 RFid=0;
   1242          
   1243            	InfoPrintf("Active Immo...,钥匙数量=%d\r\n",Remote.Totle);
   1244          	while(1)
   1245          	{  
   1246          		if(err%3==0)
   1247          		{
   1248          			SendStartLF();  				//发送LF唤醒遥控器		
   1249          		}
   1250          		
   1251          		index = UhfRevData_V7(Data, 180);	//接收V8遥控器信号 
   1252          		if(index > 6)//接收到高频数据
   1253          		{
   1254          			InfoPrintf("\r\n\r\nActiveImmo的RX(%d+1):",index);
   1255          			for(cnt=0;cnt<index+1;cnt++){InfoPrintf("%02X,",Data[cnt]);}InfoPrintf("\r\n");
   1256          		
   1257          			if(CheckRemoteValueIsAllow(&RFid)==TRUE)
   1258          			{
   1259          				if(Remote.Rfid[main_key_sn]!=RFid)
   1260          				{
   1261          					for(j=0;j<4;j++)
   1262          					{
   1263          						if(Remote.Rfid[j]==RFid)
   1264          						{
   1265          							InfoPrintf("\r\n\r\n\r\n\r\n!!!!!!!!!!!!!!!!! 主遥控器编号变更为:%d !!!!!!!!!!!!!!!!!\r\n\r\n\r\n\r\n",j);
   1266          							main_key_sn=j;
   1267          						}
   1268          					}
   1269          				}
   1270          				//InfoPrintf("遥控器RFID=%08X,配对编号:%d\r\n",RFid,main_key_sn);
   1271          				return TRUE;
   1272          			}
   1273          		}
   1274          
   1275          		if(err++ < 30)
   1276          		{
   1277          			//InfoPrintf("CCCCCC=%d,err=%d\r\n",i,err);
   1278          			IWDG_ReloadCounter();
   1279          			continue;
   1280          		}
   1281          		else
   1282          		{
   1283          			InfoPrintf("Active Immo 等待遥控器应答超时!!!!\r\n");
   1284          			break;
   1285          		}
   1286          	}
   1287          
   1288          	return FALSE;
   1289          }
   1290          
   1291          
   1292          
   1293          /*******************************************************************************
   1294          * Function Name : OnRfRev
   1295          * Description   : 高频接收遥控器数据
   1296          * Input         : None
   1297          * Output        : None
   1298          * Return        : None
   1299          *******************************************************************************/
   1300          static void OnRfRev(void) 
   1301          {
   1302          	u8 index = 0;
   1303          	u8 i;
   1304          	
   1305          	index = UhfRevData_V7(Data, 15);	//接收V7遥控器信号
   1306          	
   1307          	if(ClearKeyValueCount == 0) 
   1308          	{
   1309          		RemoteLastData = 0;
   1310          		RemoteKeyValue = 0;
   1311          	}
   1312          	else 
   1313          	{
   1314          		ClearKeyValueCount--;
   1315          	}
   1316          	
   1317          	if(index == 0)
   1318          	{
   1319          		return;  //未收到数据
   1320          	}
   1321          	
   1322          
   1323          	if(Data[1] != REMOTE_MARK_V7 && Data[1] != REMOTE_MARK_V8)//引导标志字不符 
   1324          	//if(Data[1] != REMOTE_MARK_V8)//引导标志字不符 
   1325          	{
   1326          		return;
   1327          	}
   1328          	
   1329          	if(Data[2] != 0x00)//引导标志字不符
   1330          	{
   1331          			return;
   1332          	}
   1333          
   1334          
   1335          	if(Data[0] == 0x50)  	//长帧
   1336          	{
   1337          		RemoteLastData = Data[3];//记录长短帧一致数据
   1338          		//zgc mask
   1339          		//InfoPrintf("校验发射数据的遥控器...\r\n");
   1340          		if(CheckRemoteValueIsAllow(NULL) == FALSE) 
   1341          		{
   1342          			InfoPrintf("非法 遥控器 或 遥控命令，返回\r\n\r\n");
   1343          			return;//非法遥控器
   1344          		}
   1345          		InfoPrintf("校验正确\r\n");
   1346          		InfoPrintf("UHF数据包为:");
   1347          		for(i=0;i<index+1;i++)InfoPrintf("%02X,",Data[i]);InfoPrintf("\r\n");
   1348          		
   1349          		RemoteKeyValue = Data[11];  //记录键值
   1350          		ClearKeyValueCount = 40;
   1351          	}
   1352          	else if((Data[0] == 0x51)&&(Data[1] == 0xE3)&&(Data[2] == 0x00))//短帧
   1353          	{
   1354          		#if 1
   1355          		InfoPrintf("长按解密前:");
   1356          		for(i=0;i<index+1;i++)
   1357          		{
   1358          			InfoPrintf("%02X,",Data[i]);
   1359          		}
   1360          		InfoPrintf("\r\n");
   1361          		#endif	
   1362          		RemoteKeyValue=Data[4];
   1363          
   1364          		#if 0
   1365          		if(Data[3] != RemoteLastData || Data[4] != (u8)RemoteKeyValue)   //长短帧一致数据不符、键值不符
   1366          		{
   1367          			InfoPrintf("AAAA %02X,%02X\r\n",RemoteLastData,RemoteKeyValue);
   1368          			return;	
   1369          		}
   1370          		#endif
   1371          
   1372          		
   1373          		//InfoPrintf("BBB %02X,%02X\r\n",RemoteLastData,RemoteKeyValue);
   1374          		RemoteLastData++; //短帧数据只有效一次
   1375          		RemoteKeyValue |= KEY_LONG; //记录键值
   1376          	}
   1377          	else 
   1378          	{
   1379          		return;
   1380          	}
   1381          	
   1382          	InfoPrintf("RemoteKeyValue=%04X\r\n",RemoteKeyValue);
   1383          	//执行键值响应
   1384          	RemoteKeyActive(RemoteKeyValue);  
   1385          }
   1386          
   1387          /*******************************************************************************
   1388          * Function Name : OnStudyRemote
   1389          * Description   : 学习遥控模式。
   1390          (1)
   1391          主控板在检测到学习键被按下3秒钟后: 主板持续发送10秒钟的低频信号(或者直到学完3个遥控器的RF ID 后)。
   1392          该低频信号ID为0x0000,数据体里面携带有主板上保存的"低频唤醒ID(2Bytes)"。
   1393          另外，在此期间，主板的高频接收会持续检测是否收到RF60下发的
   1394          发送结束后，改为循环发送"低频唤醒ID"的唤醒帧。
   1395          
   1396          (2)
   1397          7952在检测到CLOSE 和 OPEN键被按下后，会把唤醒ID寄存器的值设为0x0000,以便能够接收到主板发来的"学习键低频数据"，然后从
   1398          中提取出携带的"低频唤醒ID"，并保存到FLASH中，然后设置到唤醒ID寄存器，之后，就能被主板的低频帧唤醒和通信了。
   1399          
   1400          (3)
   1401          RF60在检测到CLOSE 和 OPEN 键被按下后，会发送包含RF60 ID的数据包给主板，目前还不知会发送几次。
   1402          
   1403          
   1404          * Input         : None
   1405          * Output        : None
   1406          * Return        : None
   1407          *******************************************************************************/
   1408          static void OnStudyRemote(void) 
   1409          {
   1410          	OS_ERR os_err;
   1411          	REMOTE_STATUS NewRemote={0};  //新遥控器属性数据
   1412          	REMOTE_STATUS NewRemote_cmp={0};  //新遥控器属性数据
   1413          	u8 IDCount = 0;
   1414          	u8 index = 0;
   1415          	u32 InitTime, LastTime;
   1416          	u8 i=0;
   1417          	u8  double_id_flag=0;
   1418          	u32 double_id_val=0;
   1419          	u8 key_max_4_flag=0;
   1420          	u8 temp;
   1421              //u8 *ptr;
   1422          	key_sn=0;
   1423          	
   1424          	memset((u8 *)&NewRemote, 0x00, sizeof(REMOTE_STATUS));
   1425          
   1426          	IWDG_ReloadCounter();
   1427          	DriveAlarm(1, 1250); //进入学习模式提示
   1428          	IWDG_ReloadCounter();
   1429          	DelayXms(1250);
   1430          	IWDG_ReloadCounter();
   1431          	DelayXms(1250);
   1432          	IWDG_ReloadCounter();
   1433          	DriveAlarm(1, 1250); //进入学习模式提示
   1434          	IWDG_ReloadCounter();
   1435          	
   1436          	InitTime = OSTimeGet(&os_err);
   1437          	i=0;
   1438          	while(READ_STUDYKEY == Bit_RESET) //学习按键按下
   1439          	{
   1440          		i++;
   1441          		if(i>3)
   1442          		{
   1443          			break;
   1444          		}
   1445          		DelayXms(10);
   1446          	}
   1447          	if(i>3)
   1448          	{
   1449          		key_max_4_flag=1;
   1450          	}
   1451          	InfoPrintf("开始学习...\r\n");
   1452          	
   1453          
   1454          	while(IDCount < 4) 	//匹配的遥控器数量少于3
   1455          	{ 
   1456          		IWDG_ReloadCounter();
   1457          		index = UhfRevData_V7(Data, 50);
   1458          		if(index > 9)  //接收V7遥控器信号
   1459          		{
   1460          			InfoPrintf("接收到遥控器数据(%d+1):",index);
   1461          			for(i=0;i<index+1;i++)InfoPrintf("%02X,",Data[i]);InfoPrintf("\r\n");
   1462          				
   1463          			if((Data[0] != 0x50)||(Data[2] != 0x00)) continue;		
   1464          
   1465          			if(Data[11]!=REMOTE_KEY_STOP)continue;
   1466          			
   1467          			if(Data[1] == REMOTE_MARK_V8)  		//解密遥控数据
   1468          			{
   1469          				IV8_Decrypt(Data + 3);
   1470          				
   1471          				InfoPrintf("解密后%d+1:",index);
   1472          				for(i=0;i<index+1;i++)InfoPrintf("%02X,",Data[i]);InfoPrintf("\r\n");
   1473          				
   1474          			}
   1475          			else if(Data[1] == REMOTE_MARK_V7)  //解密遥控数据
   1476          			{
   1477          				V7_Decrypt(Data + 3);
   1478          			}
   1479          			else 
   1480          			{
   1481          				continue;
   1482          			}
   1483          			
   1484          			if(Data[10] != (Data[11]&0xF0)) 
   1485          			{
   1486          				InfoPrintf("校验错误====0x%02X===0x%02X======\r\n",Data[10],Data[11]);
   1487          				//continue;
   1488          			}
   1489          
   1490          			if(Data[11]==0x2A)
   1491          			{
   1492          				//InfoPrintf("学习键值错误!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n");
   1493          				//continue;
   1494          			}
   1495          
   1496          			#if 1
   1497          			if(double_id_flag==1)
   1498          			{
   1499          				if(double_id_val==*(u32 *)&Data[3])
   1500          				{
   1501          					//InfoPrintf("A-\r\n");
   1502          				}
   1503          				else
   1504          				{
   1505          					//InfoPrintf("B-\r\n");
   1506          					
   1507          					continue;
   1508          				}
   1509          			}
   1510          
   1511          			if(double_id_flag==0)
   1512          			{
   1513          				double_id_val=*(u32 *)&Data[3];
   1514          				double_id_flag=1;
   1515          				//InfoPrintf("C-\r\n");
   1516          				continue;
   1517          			}
   1518          
   1519          			double_id_flag=0;
   1520          			#endif
   1521          			
   1522          			
   1523          			//如果RFID 重复，则忽略此包数据，返回
   1524          			if((IDCount == 1) && (*(u32 *) &Data[3] == NewRemote.Rfid[0]))
   1525          			{
   1526          				InfoPrintf("RFID重复A =%08X\r\n",*(u32 *) &Data[3]);
   1527          				continue;
   1528          			}
   1529          			
   1530          			//如果RFID 重复，则忽略此包数据，返回
   1531          			if((IDCount == 2) && ( (*(u32 *) &Data[3] == NewRemote.Rfid[0]) || (*(u32 *) &Data[3] == NewRemote.Rfid[1])) ) 
   1532          			{
   1533          				InfoPrintf("RFID重复B =%08X\r\n",*(u32 *) &Data[3]);
   1534          				continue;
   1535          			}
   1536          
   1537          			//如果RFID 重复，则忽略此包数据，返回
   1538          			if(    (IDCount == 3) 
   1539          				&& ( 
   1540          				        (*(u32 *) &Data[3] == NewRemote.Rfid[0]) 
   1541          				     || (*(u32 *) &Data[3] == NewRemote.Rfid[1])
   1542          				     || (*(u32 *) &Data[3] == NewRemote.Rfid[2])
   1543          				   ) 
   1544          		       ) 
   1545          			{
   1546          				InfoPrintf("RFID重复C =%08X\r\n",*(u32 *) &Data[3]);
   1547          				continue;
   1548          			}
   1549          			
   1550          			NewRemote.Rfid[IDCount] = *(u32 *) &Data[3];
   1551          			NewRemote.Rfloq[IDCount]= *(u32 *) &Data[7] & 0x00FFFFFF;
   1552          			NewRemote.Lfid[IDCount] = ((u16)NewRemote.Rfid[IDCount] ^ 0xA569) & 0xFFFE;
   1553          
   1554          			//OSSchedUnlock(&os_err);
   1555          			DriveAlarm(1, 150);
   1556          			InfoPrintf("\r\n");
   1557          			InfoPrintf("学习到RFID =%08X\r\n",NewRemote.Rfid[IDCount]);
   1558          			InfoPrintf("学习到Rfloq=%08X\r\n",NewRemote.Rfloq[IDCount]);			
   1559          			//InfoPrintf("学习到LFID =%08X\r\n",NewRemote.Lfid[IDCount]);
   1560          			IDCount++;
   1561          			InfoPrintf("学习到RFID数量=%d\r\n",IDCount);
   1562          			key_sn++;
   1563          			InitTime=OSTimeGet(&os_err);
   1564          			DelayXms(200);
   1565          			//OSSchedLock(&os_err);
   1566          		}
   1567          		else
   1568          		{
   1569          			//未接收到RF60下发的有效的高频数据
   1570          		}
   1571          
   1572          		//超时判断
   1573          		LastTime = OSTimeGet(&os_err);
   1574          		if(key_max_4_flag==1)
   1575          		{
   1576          			temp=4;	
   1577          		}
   1578          		else
   1579          		{
   1580          			temp=2;
   1581          		}
   1582          		//if((LastTime - InitTime > STUDY_MODE_TIME+(key_sn*60))/*||(READ_STUDYKEY == Bit_RESET)*/) 	//持续接收时间10s
   1583          		if((( (LastTime-InitTime) > 6000) /*||(READ_STUDYKEY == Bit_RESET)*/) 	//持续接收时间10s
   1584          		    ||(key_sn>=temp)
   1585          		  )
   1586          		{
   1587          			InfoPrintf("学习ID时间已耗完\r\n");
   1588          			//OSSchedUnlock(&os_err);
   1589          			DriveAlarm(4, 50);	//zgc add
   1590                      DelayXms(300);
   1591          			//OSSchedLock(&os_err);
   1592          			break;
   1593          		}
   1594          
   1595          		//不停地发送低频信号，确保PCF7952能接收到主控板决定的7952低频唤醒ID S
   1596          		IWDG_ReloadCounter();	//喂狗
   1597          		OSSchedLock(&os_err);
   1598          		if(SendStudyLF()==1)
   1599          		{
   1600          			OSSchedUnlock(&os_err);
   1601          			DriveAlarm(4, 50);
   1602          			break;
   1603          		}
   1604          		OSSchedUnlock(&os_err);
   1605          		DelayXms(5);
   1606          		//OSSchedLock(&os_err);
   1607          	}
   1608          	
   1609          	InfoPrintf("学习到RFID数量xxxxxxxxxxxx=%d\r\n",IDCount);
   1610          	
   1611          	if(IDCount != 0) 	//有效遥控器数量非0
   1612          	{ 
   1613          		NewRemote.Totle = IDCount;
   1614          		NewRemote.Index = 0;
   1615          		NewRemote.State = Remote.State; //复制当前汽车状态
   1616          		InfoPrintf("学习到RFID数量dccccccccccccccc=%d\r\n",IDCount);
   1617          		memcpy(&Remote, &NewRemote, sizeof(REMOTE_STATUS));
   1618          
   1619          		if(FLASH_WriteRemoteID(&Remote) == FALSE) 
   1620          		{
   1621          			FLASH_WriteRemoteID(&Remote);
   1622          		}
   1623          		
   1624          		FLASH_WriteRemoteLOQ(&Remote);
   1625          		FLASH_ReadRemoteID(&NewRemote_cmp);  			//获取遥控器ID值等
   1626          		FLASH_ReadRemoteLOQ(&NewRemote_cmp); 			//获取遥控器LOQ值等
   1627          
   1628          		if(memcmp(&NewRemote_cmp,&Remote,sizeof(REMOTE_STATUS))==0)
   1629          		{
   1630          			InfoPrintf("保存成功!!!!!!!!! 遥控数量=%d !!!!!!!!!!!!!!\r\n",IDCount);
   1631          		}
   1632          		//OSSchedUnlock(&os_err);
   1633          		DriveAlarm(IDCount, 500);  //保存遥控器属性数据提示
   1634          		//OSSchedLock(&os_err);
   1635          	}
   1636          
   1637          	
   1638              //OSSchedUnlock(&os_err);
   1639          	
   1640            	return;
   1641          }
   1642          
   1643          
   1644          static void rf_open_module(void)
   1645          {
   1646          	//user_uart2_open();
   1647          	//gps_power_ctl(1);
   1648          	//gps_reset_ctl(0);
   1649          	//user_delay_ms(TIME_10ms);
   1650          	//gps_config_module();
   1651          	//gps_init_ant_ck_pin();
   1652          }
   1653          
   1654          static void rf_close_module(void)
   1655          {
   1656          	
   1657          }
   1658          
   1659          
   1660          #define ___RF____MIDDLE__________________________________________________________
   1661          
   1662          
   1663          #define ___RF_APP__________________________________________________________________________
   1664          
   1665          
   1666          
   1667          
   1668          static void RfTaskMsg_handle(TASK_MSG_T *p_msg)
   1669          {
   1670          
   1671          	switch (p_msg->msg_src_id)
   1672          	{
   1673          		case DEV_MANAGE_TASK_ID:
   1674          			switch (p_msg->msg_father_type)
   1675          			{
   1676          				case FATHER_MSG_T_TASK_POWER_CTRL:
   1677          					if(p_msg->msg_son_type==POWER_CTRL_PWR_ON)
   1678          					{
   1679          						rf_open_module();
   1680          					}
   1681          					else if(p_msg->msg_son_type==POWER_CTRL_WAKEUP)
   1682          					{
   1683          
   1684          					}
   1685          					else if(p_msg->msg_son_type==POWER_CTRL_SLEEP)
   1686          					{
   1687          
   1688          					}
   1689          					else if(p_msg->msg_son_type==POWER_CTRL_PWR_OFF)
   1690          					{
   1691          
   1692          					}
   1693          					break;
   1694          				default:
   1695          					break;
   1696          			}
   1697          			break;
   1698          		case MODEM_MANAGE_TASK_ID:
   1699          			break;
   1700          		default:
   1701          			break;
   1702          	}		
   1703          }
   1704          
   1705          void init_adc(uint8_t chan)
   1706          {
   1707          	
   1708          	ADC_InitTypeDef ADC_InitStructure;
   1709          	ADC_Cmd(ADC1, DISABLE);
   1710          	
   1711          	/* ADC1 configuration ------------------------------------------------------*/
   1712          	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   1713          	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
   1714          	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   1715          	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   1716          	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   1717          	ADC_InitStructure.ADC_NbrOfChannel = 1;
   1718          	ADC_Init(ADC1, &ADC_InitStructure);
   1719          	
   1720          	/* ADC1 regular channels configuration */ 
   1721          	ADC_RegularChannelConfig(ADC1, chan, 1, ADC_SampleTime_28Cycles5);
   1722          
   1723          	/* Enable ADC1 EOC interrupt */
   1724          	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   1725          
   1726          	/*ADC_ResetCalibration(ADC1);
   1727          	while(ADC_GetResetCalibrationStatus(ADC1));
   1728          	ADC_StartCalibration(ADC1);
   1729          	while(ADC_GetCalibrationStatus(ADC1));
   1730          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);*/
   1731          
   1732          	//ADC_Cmd(ADC1, ENABLE);
   1733          }
   1734          
   1735          void start_adc(uint8_t chan)
   1736          {
   1737          	ADC_RegularChannelConfig(ADC1, chan, 1, ADC_SampleTime_28Cycles5);
   1738          	ADC_Cmd(ADC1, ENABLE);
   1739          }
   1740          
   1741          
   1742          
   1743          void ADC1_2_IRQHandler(void)
   1744          {
   1745          	uint16_t temp;
   1746          	uint32_t all=0;
   1747          	uint8_t i;	
   1748          
   1749          	if(1 == ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC))
   1750          	{
   1751          		bat_current = ADC_GetConversionValue(ADC1);
   1752          		if(check_bat_vol_ok_flag==2)
   1753          		{
   1754          			if((bat_current>bat_off_average+bat_dif_val)&&(bat_cali_ok_flag==1))
   1755          			{
   1756          				#if 1
   1757          				{
   1758          					static uint8_t cnt=0;
   1759          					if(cnt++%10==0)
   1760          					InfoPrintf("疑似启动...\r\n");
   1761          				}
   1762          				#endif
   1763          			}
   1764          		}
   1765          
   1766          		if(check_bat_vol_ok_flag==0)
   1767          		{
   1768          			check_bat_vol_buf[check_bat_vol_buf_offset++]=bat_current;
   1769          			if(check_bat_vol_buf_offset>=CHECK_BUF_LEN)
   1770          			{
   1771          				all=0;
   1772          				for(i=0;i<CHECK_BUF_LEN;i++)
   1773          				{
   1774          					all+=check_bat_vol_buf[i];
   1775          				}
   1776          
   1777          				check_bat_vol_buf_offset=0;
   1778          				check_bat_vol_ok_flag=1;
   1779          				bat_off_average=all/CHECK_BUF_LEN;
   1780          				InfoPrintf("校准主电池 熄火后 电压OK\r\n");
   1781          			}
   1782          			
   1783          			check_bat_vol_buf_offset%=CHECK_BUF_LEN;
   1784          		}
   1785          		else if(check_bat_vol_ok_flag==1)
   1786          		{
   1787          			all=0;
   1788          			check_bat_vol_buf[check_bat_vol_buf_offset++]=bat_current;
   1789          			for(i=0;i<CHECK_BUF_LEN;i++)
   1790          			{
   1791          				all+=check_bat_vol_buf[i];
   1792          			}
   1793          			bat_engined_average=all/CHECK_BUF_LEN;
   1794          			check_bat_vol_buf_offset%=CHECK_BUF_LEN;
   1795          			//InfoPrintf("校准主电池 点火后 电压OK\r\n");
   1796          		}
   1797          				
   1798          		ADC_Cmd(ADC1, DISABLE);
   1799          	}
   1800          }
   1801          
   1802          static void recalibrate_bat_vol(void)
   1803          {
   1804          	check_bat_vol_ok_flag=0;
   1805          	check_bat_vol_buf_offset=0;
   1806          	bat_cali_ok_flag=0;
   1807          }
   1808          
   1809          static void check_study_key(void)
   1810          {
   1811          	OS_ERR os_err;
   1812          	uint32_t temp,j;
   1813          	uint32_t i;
   1814          	static uint32_t cali_alarm_timestamp=0;
   1815          	
   1816          	if(READ_STUDYKEY == Bit_RESET)
   1817          	{
   1818          		temp=0;
   1819          		for(i=1;i<150;i++)
   1820          		{
   1821          			user_delay_ms(10);
   1822          			if(READ_STUDYKEY == Bit_SET)
   1823          			{
   1824          				i=0;
   1825          				break;
   1826          			}
   1827          			IWDG_ReloadCounter();
   1828          		}
   1829          		
   1830          		if(i!=0)
   1831          		{
   1832          			InfoPrintf("进入学习遥控器模式...\r\n");
   1833          			OnStudyRemote();
   1834          			user_delay_ms(200);
   1835          		}
   1836          		#ifdef EN_ADC1_CHN1
   1837          		else
   1838          		{
   1839          			//InfoPrintf("检测校准...\r\n");
   1840          			temp=1;
   1841          			for(i=0;i<300;i++)
   1842          			{
   1843          				user_delay_ms(10);
   1844          				
   1845          				if((READ_STUDYKEY == Bit_RESET) && (temp%2==1))
   1846          				{
   1847          					user_delay_ms(30);
   1848          					temp++;
   1849          				}
   1850          				else if((READ_STUDYKEY == Bit_SET) && (temp%2==0))
   1851          				{
   1852          					user_delay_ms(30);
   1853          					temp++; 
   1854          				}
   1855          
   1856          				if((temp==1)&&(i>120))
   1857          				{
   1858          					break;
   1859          				}
   1860          
   1861          				if(temp>=5)
   1862          				{
   1863          					InfoPrintf("进入校准模式...\r\n");
   1864          					recalibrate_bat_vol();
   1865          					start_calibrate_bat_timestamp=OSTimeGet(&os_err);
   1866          					break;
   1867          				}	
   1868          			}
   1869          		}
   1870          		#endif
   1871          	}
   1872          
   1873          	#ifdef EN_ADC1_CHN1
   1874          	if(OSTimeGet(&os_err)-start_calibrate_bat_timestamp>10000)
   1875          	{
   1876          		if(check_bat_vol_ok_flag==1)
   1877          		{
   1878          			if(bat_engined_average>bat_off_average+100)
   1879          			{
   1880          				bat_dif_val=bat_engined_average-bat_off_average;
   1881          				bat_cali_ok_flag=1;
   1882          			}
   1883          			else
   1884          			{
   1885          				bat_cali_ok_flag=0;
   1886          				InfoPrintf("校准错误\r\n");
   1887          				DriveAlarm(12, 70);
   1888          			}
   1889          			check_bat_vol_ok_flag=2;
   1890          			InfoPrintf("校准结束\r\n");
   1891          			cali_alarm_timestamp=0;
   1892          		}
   1893          	}
   1894          	else
   1895          	{
   1896          		if(check_bat_vol_ok_flag<=1)
   1897          		{
   1898          			if((OSTimeGet(&os_err)-cali_alarm_timestamp)>=1000)
   1899          			{
   1900          				cali_alarm_timestamp=OSTimeGet(&os_err);
   1901          				DriveAlarm(1, 200);
   1902          			}
   1903          		}
   1904          	}
   1905          	#endif
   1906          }
   1907          
   1908          void IWDG_Configuration(void)
   1909          {
   1910          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);	// 打开使能，iwdg的寄存器有写保护,必须先写入0x5555，才能操作寄存器
   1911          	IWDG_SetPrescaler(IWDG_Prescaler_256);			// 独立看门狗使用内部低速振荡器LSI，对LSI进行256分频
   1912          	//IWDG_SetReload(2000);							// 设定独立看门狗计数器的计数值(0x000~0xFFF;0~4095)，复位时间为12.8s
   1913          	//IWDG_SetReload(200);							// 设定独立看门狗计数器的计数值(0x000~0xFFF;0~4095)，复位时间为1.28s
   1914          	IWDG_SetReload(800);							// 设定独立看门狗计数器的计数值(0x000~0xFFF;0~4095)，复位时间为2.56s
   1915          	IWDG_ReloadCounter();							// 重载独立看门狗计数器，向寄存器写入0xAAAA，或者更新计数值
   1916          	IWDG_Enable();									// 开启看门狗，向寄存器写入0xCCCC即可
   1917          }
   1918          
   1919          
   1920          void RfTask(void *p_arg)
   1921          {
   1922          	TASK_MSG_T *task_msg;
   1923          	OS_MSG_SIZE msg_size;
   1924          	uint32_t last_time=0;
   1925          	uint32_t last_adc_time=0;
   1926          	uint32_t i;
   1927          	uint8_t temp;
   1928          	OS_ERR os_err;
   1929          	p_arg=p_arg;
   1930          	
   1931          	KEY_PWR_OFF;
   1932          	MCURegID = *(vu32 *)(0x1FFFF7E8 + 8);			//获取MCU固件ID
   1933          	factory_trace_id = *(vu32 *)(0x1FFFF7E8 + 0);	//获取MCU固件ID zgc
   1934          	FLASH_ReadRemoteID(&Remote);  					//获取遥控器ID值等
   1935          	FLASH_ReadRemoteLOQ(&Remote); 					//获取遥控器LOQ值等
   1936          
   1937          	#ifdef EN_ADC1_CHN1
   1938          	init_adc(ADC_Channel_1);
   1939          	#else
   1940          	DelayXms(5);  
   1941          	on_status=READ_ON_LINE;
   1942          	#endif
   1943          	
   1944          	while(1)
   1945          	{
   1946          		task_msg = OSTaskQPend(0,OS_OPT_PEND_NON_BLOCKING,&msg_size,NULL,&os_err);
   1947          		if(NULL != task_msg)
   1948          		{
   1949          			RfTaskMsg_handle(task_msg);
   1950          			user_free(task_msg,__FUNCTION__);
   1951          		}
   1952          		
   1953          		OnRfRev();
   1954          
   1955          		check_study_key();
   1956          		
   1957          		#ifdef EN_ADC1_CHN1
   1958          		if(user_get_os_time()-last_adc_time>T_10MS)
   1959          		{
   1960          			last_adc_time=user_get_os_time();
   1961          			start_adc(ADC_Channel_1);
   1962          			
   1963          		}
   1964          		#else
   1965          		if(user_get_os_time()-last_adc_time>T_50MS)
   1966          		{
   1967          			last_adc_time=user_get_os_time();
   1968          			if(READ_ON_LINE!=on_status)
   1969          			{
   1970          				DelayXms(5);  
   1971          				for(i=0;i<10;i++)
   1972          				{
   1973          					temp=READ_ON_LINE;
   1974          					if(temp==on_status)
   1975          					{
   1976          						break;
   1977          					}
   1978          					
   1979          					if(i==9)
   1980          					{
   1981          						on_status=temp;
   1982          						InfoPrintf("!!!!!!!!!!on_status=%d,\r\n",on_status);
   1983          						on_change_flag=1;
   1984          						remote_started_flag=0;
   1985          						if(on_status==1)
   1986          						{
   1987          							if(ActiveImmo() == TRUE) 
   1988          							{		
   1989          								if(smart_card_pwr_status!=1)
   1990          								{
   1991          									power_on_smart_card(); 
   1992          								}
   1993          								smart_card_need_dly_pwr_off_flag=0;
   1994          								//DriveAlarm(3, 100);
   1995          								InfoPrintf("AAA遥控器在车上，转为 本地启动 模式 !!!!\r\n");
   1996          								InfoPrintf("\r\n\r\n\r\n");
   1997          								remote_started_flag=0;
   1998          							}
   1999          							else 
   2000          							{
   2001          								//control_car_power(CAR_OFF);
   2002          								DriveAlarm(1, 100);
   2003          								DelayXms(1000); 
   2004          								InfoPrintf("遥控器不在车上，熄火OK\r\n");
   2005          							}
   2006          						}
   2007          					}
   2008          					DelayXms(2);
   2009          				}
   2010          			}
   2011          		}
   2012          		#endif
   2013          
   2014          		if(READ_BREAK_PIN==1)
   2015          		{
   2016          			DelayXms(5);
   2017          			if((remote_started_flag==1)&&(READ_BREAK_PIN==1))
   2018          			{
   2019          				if(ActiveImmo() == TRUE) 
   2020          				{		
   2021          					if(smart_card_pwr_status!=1)
   2022          					{
   2023          						power_on_smart_card(); 
   2024          						smart_card_need_dly_pwr_off_flag=0;
   2025          					}
   2026          					//DriveAlarm(5, 100);
   2027          					InfoPrintf("遥控器在车上，转为 本地启动 模式 !!!!\r\n");
   2028          					InfoPrintf("\r\n\r\n\r\n");
   2029          					remote_started_flag=0;
   2030          				}
   2031          				else 
   2032          				{
   2033          					control_car_power(CAR_OFF);
   2034          					DriveAlarm(1, 100);
   2035          					DelayXms(1000); 
   2036          					InfoPrintf("遥控器不在车上，熄火OK\r\n");
   2037          				}
   2038          			}
   2039          		}
   2040          		
   2041          		if(smart_card_need_dly_pwr_off_flag==1)
   2042          		{
   2043          			if(OSTimeGet(&os_err)-remote_pwr_on_card_timestamp>T_3S)
   2044          			{
   2045          				//DriveAlarm(2, 200);
   2046          				power_off_smart_card(); 
   2047          			}
   2048          		}
   2049          
   2050          		key_release();
   2051          
   2052          		if(user_get_os_time()-last_time>T_600MS)
   2053          		{
   2054          			if((remote_started_flag==1)||(on_status==0))
   2055          			{
   2056          				last_time=user_get_os_time();
   2057          				//InfoPrintf("bat_OFF_average=%d,bat_engined_average=%d,bat_current=%d\r\n",bat_off_average,bat_engined_average,bat_current);
   2058          				SendAwakeLF();
   2059          			}
   2060          		}
   2061          
   2062          
   2063          		IWDG_ReloadCounter();
   2064          		//DelayXms(15);
   2065          		OSSchedRoundRobinYield(&os_err);
   2066          	}
   2067          
   2068          }
   2069          
   2070          
   2071          
   2072          
   2073          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC1_2_IRQHandler
         0   -> ADC_Cmd
        16   -> ADC_GetConversionValue
        16   -> ADC_GetFlagStatus
        16   -> InfoPrintf
      32   ActiveImmo
        32   -> CheckRemoteValueIsAllow
        32   -> IWDG_ReloadCounter
        32   -> InfoPrintf
        32   -> SendStartLF
        32   -> UhfRevData_V7
      24   AddTimeDriveAlarm
        24   -> DelayXms
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
      32   CheckRemoteValueIsAllow
        32   -> FLASH_WriteRemoteLOQ
        32   -> IV8_Decrypt
        32   -> InfoPrintf
        32   -> V7_Decrypt
      16   DelayXms
        16   -> OSTimeDly
      24   DriveAlarm
        24   -> DelayXms
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> IWDG_ReloadCounter
      16   GPIO_Configuration
        16   -> GPIO_Init
        16   -> GPIO_PinRemapConfig
        16   -> GPIO_ResetBits
       8   IWDG_Configuration
         0   -> IWDG_Enable
         8   -> IWDG_ReloadCounter
         8   -> IWDG_SetPrescaler
         8   -> IWDG_SetReload
         8   -> IWDG_WriteAccessCmd
      16   LED_flash
        16   -> DelayXms
     128   LFSendData
       128   -> OSSchedLock
       128   -> OSSchedUnlock
       128   -> TIM_CCxCmd
       128   -> TIM_Cmd
       128   -> TIM_CtrlPWMOutputs
       128   -> TIM_GetCounter
       128   -> TIM_SetCounter
       128   -> __aeabi_memclr4
      16   OnRfRev
        16   -> CheckRemoteValueIsAllow
         0   -> InfoPrintf
        16   -> InfoPrintf
         0   -> RemoteKeyActive
        16   -> UhfRevData_V7
     152   OnStudyRemote
       152   -> DelayXms
       152   -> DriveAlarm
       152   -> FLASH_ReadRemoteID
       152   -> FLASH_ReadRemoteLOQ
       152   -> FLASH_WriteRemoteID
       152   -> FLASH_WriteRemoteLOQ
       152   -> GPIO_ReadInputDataBit
       152   -> IV8_Decrypt
       152   -> IWDG_ReloadCounter
       152   -> InfoPrintf
       152   -> OSSchedLock
       152   -> OSSchedUnlock
       152   -> OSTimeGet
       152   -> SendStudyLF
       152   -> UhfRevData_V7
       152   -> V7_Decrypt
       152   -> __aeabi_memclr4
       152   -> __aeabi_memcpy4
       152   -> __aeabi_memset4
       152   -> memcmp
       8   RangVlue
         8   -> Cal_crc8
         8   -> user_get_os_time
      16   RemoteKeyActive
        16   -> DelayXms
        16   -> DriveAlarm
        16   -> GPIO_ReadInputDataBit
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> InfoPrintf
        16   -> OSTimeGet
        16   -> ctl_car_remote_start
        16   -> ctl_car_remote_stop
        16   -> power_on_smart_card
      32   RfTask
        32   -> ActiveImmo
        32   -> DelayXms
        32   -> DriveAlarm
        32   -> FLASH_ReadRemoteID
        32   -> FLASH_ReadRemoteLOQ
        32   -> GPIO_ReadInputDataBit
        32   -> GPIO_SetBits
        32   -> IWDG_ReloadCounter
        32   -> InfoPrintf
        32   -> OSSchedRoundRobinYield
        32   -> OSTaskQPend
        32   -> OSTimeGet
        32   -> OnRfRev
        32   -> RfTaskMsg_handle
        32   -> SendAwakeLF
        32   -> check_study_key
        32   -> control_car_power
        32   -> key_release
        32   -> power_off_smart_card
        32   -> power_on_smart_card
        32   -> user_free
        32   -> user_get_os_time
       0   RfTaskMsg_handle
         0   -> rf_open_module
      24   SendAwakeLF
        24   -> InfoPrintf
        24   -> LFSendData
      32   SendStartLF
        32   -> InfoPrintf
        32   -> LFSendData
        32   -> RangVlue
      24   SendStudyLF
        24   -> IWDG_ReloadCounter
        24   -> InfoPrintf
        24   -> LFSendData
       8   TIM2_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> TIM_Cmd
         8   -> TIM_GetITStatus
      48   UhfRevData_V7
        48   -> GPIO_ReadInputDataBit
        48   -> OSSchedLock
        48   -> OSSchedUnlock
        48   -> TIM_Cmd
        48   -> TIM_GetCounter
        48   -> TIM_SetCounter
        48   -> ValueRange
        48   -> __aeabi_memset
       0   ValueRange
      16   check_study_key
        16   -> GPIO_ReadInputDataBit
        16   -> IWDG_ReloadCounter
        16   -> InfoPrintf
        16   -> OnStudyRemote
         0   -> user_delay_ms
        16   -> user_delay_ms
       8   control_car_power
         0   -> DelayXms
         8   -> DelayXms
         0   -> GPIO_ResetBits
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> InfoPrintf
      16   ctl_car_remote_start
        16   -> DelayXms
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> InfoPrintf
        16   -> OSTimeGet
        16   -> control_car_power
        16   -> power_on_smart_card
       8   ctl_car_remote_stop
         8   -> DelayXms
         0   -> InfoPrintf
         8   -> InfoPrintf
         8   -> control_car_power
      32   init_adc
        32   -> ADC_Cmd
        32   -> ADC_ITConfig
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
      16   key_release
        16   -> GPIO_ResetBits
        16   -> InfoPrintf
        16   -> OSTimeGet
       8   power_off_smart_card
         8   -> GPIO_SetBits
         8   -> InfoPrintf
      16   power_on_smart_card
        16   -> GPIO_ResetBits
        16   -> InfoPrintf
        16   -> OSTimeGet
       0   rf_open_module
       8   start_adc
         0   -> ADC_Cmd
         8   -> ADC_RegularChannelConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable102
       4  ??DataTable105
       4  ??DataTable105_1
       4  ??DataTable105_2
       4  ??DataTable105_3
       4  ??DataTable105_4
       4  ??DataTable105_5
       4  ??DataTable105_6
       4  ??DataTable95
       4  ??DataTable95_1
       4  ??DataTable95_2
       4  ??DataTable96
       4  ??DataTable96_1
       4  ??DataTable96_2
       4  ??DataTable96_3
       4  ??DataTable98
       4  ??DataTable99
       4  ??DataTable99_1
      24  ?_0
      28  ?_1
      28  ?_10
      12  ?_11
      96  ?_12
      56  ?_13
      12  ?_14
      52  ?_15
      48  ?_16
       8  ?_17
       8  ?_18
       4  ?_19
      24  ?_2
       8  ?_20
      32  ?_21
      28  ?_22
      20  ?_23
      20  ?_24
      32  ?_25
      16  ?_26
      44  ?_27
      20  ?_28
      16  ?_29
      24  ?_3
      20  ?_30
      16  ?_31
      40  ?_32
      40  ?_33
      28  ?_34
      40  ?_35
      40  ?_36
      44  ?_37
      40  ?_38
      40  ?_39
      16  ?_4
      44  ?_40
      24  ?_41
      24  ?_42
      32  ?_43
      24  ?_44
      32  ?_45
      32  ?_46
      28  ?_47
      76  ?_48
      40  ?_49
      16  ?_5
      36  ?_50
      12  ?_51
      16  ?_52
      12  ?_53
      24  ?_54
      52  ?_55
      52  ?_56
      16  ?_57
      24  ?_58
      12  ?_59
      20  ?_6
      36  ?_60
      20  ?_61
      20  ?_62
      20  ?_63
      20  ?_64
      20  ?_65
      20  ?_66
      20  ?_67
      32  ?_68
      36  ?_69
      20  ?_7
      48  ?_70
      16  ?_71
      28  ?_72
      24  ?_73
      28  ?_74
      44  ?_75
       8  ?_76
      28  ?_77
      40  ?_78
      16  ?_8
      32  ?_9
     254  ADC1_2_IRQHandler
     204  ActiveImmo
      56  AddTimeDriveAlarm
      44  BasePlus
     326  CheckRemoteValueIsAllow
      72  Data
          RangData
          ClearKeyValueCount
          RemoteLastData
          car_power
          smart_card_need_dly_pwr_off_flag
          smart_card_pwr_status
          key_sn
          on_change_flag
          on_status
          remote_started_flag
          main_key_sn
          cnt
          RemoteKeyValue
          lf_dst_WUPA
          remote_pwr_on_card_timestamp
          MCURegID
          factory_trace_id
          KEY_TRUNK_L_time_stamp
          KEY_UNLOCK_L_time_stamp
          KEY_LOCK_L_time_stamp
          last_short_key_trunk_timestamp
          last_short_key_unlock_timestamp
          last_short_key_lock_timestamp
      16  DelayXms
      60  DriveAlarm
     280  GPIO_Configuration
      36  IWDG_Configuration
      36  LED_flash
     426  LFSendData
     226  OnRfRev
     840  OnStudyRemote
      64  RangVlue
      52  Remote
     762  RemoteKeyActive
     484  RfTask
      22  RfTaskMsg_handle
      94  SendAwakeLF
     106  SendStartLF
     140  SendStudyLF
      46  TIM2_IRQHandler
       1  TIM2_counting_now_flag
     818  UhfRevData_V7
      28  ValueRange
      60  check_bat_vol_ok_flag
          check_bat_vol_buf_offset
          bat_cali_ok_flag
          cnt
          check_bat_vol_buf
          bat_off_average
          bat_engined_average
          bat_current
          bat_dif_val
      82  check_study_key
     146  control_car_power
     160  ctl_car_remote_start
      34  ctl_car_remote_stop
       1  enable_lf_tx_flag
      84  init_adc
     146  key_release
       2  lf_dst_WUPB
      34  power_off_smart_card
      46  power_on_smart_card
       2  rf_open_module
      28  start_adc
       8  -- Other

 
    55 bytes in section .bss
   133 bytes in section .data
   204 bytes in section .rodata
 8 254 bytes in section .text
 
 8 254 bytes of CODE  memory
   204 bytes of CONST memory
   188 bytes of DATA  memory

Errors: none
Warnings: 15
