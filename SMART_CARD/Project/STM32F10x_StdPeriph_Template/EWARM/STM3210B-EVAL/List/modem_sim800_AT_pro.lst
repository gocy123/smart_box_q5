###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\modem\sim800\modem_sim800_AT_pro.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\modem\sim800\modem_sim800_AT_pro.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\modem_sim800_AT_pro.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\modem_sim800_AT_pro.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\modem\sim800\modem_sim800_AT_pro.c
      1          #include "user_system_cfg.h"
      2          
      3          #ifdef USE_SIM800_MODEM
      4          
      5          #include <stdint.h>
      6          #include <string.h>
      7          #include <stdio.h>
      8          
      9          #include "os_cfg_app.h"			//TCB,STACK,PRIORITY,任务间消息的结构体定义和宏
     10          #include "os.h"
     11          #include "modem_sim800_AT_pro.h"
     12          #include "uart1_network_layer.h"
     13          #include "user_debug_app.h"
     14          
     15          
     16          #define AT_TBL_LEN 9 
     17          const char *at_tbl[AT_TBL_LEN]={
     18          "\r\n+CSQ:",// 0
     19          "\r\n+CREG",// 1
     20          "\r\n+CGATT:",// 2
     21          "\r\nCONNECT OK",// 3
     22          "\r\nSHUT OK",// 4
     23          "\r\nSTATE: CONNECT OK",//5
     24          "\r\nERROR\r\n",// 6
     25          "\r\nOK\r\n",// 7
     26          "\r\nALREADY CONNECT"//8
     27          
     28          };
     29          
     30          #define AT_IN_BUF_LEN (128) 
     31          static uint8_t inbuf[AT_IN_BUF_LEN]={0};  //用于保存:从RX中断缓冲buffer中读出的数据
     32          
     33          extern OS_Q modem_send_at_rsp_q;
     34          extern OS_Q modem_send_gprs_at_rsp_q;
     35          extern OS_Q modem_receive_urc_q;
     36          extern OS_Q modem_receive_gprs_data_q;
     37          
     38          extern 	void *user_malloc(unsigned int size,char const*caller);
     39          extern 	void user_free(void *rmem,char const*caller);
     40          
     41          
     42          /*
     43          input:
     44          		frame:
     45          		frame_len:
     46          		Rxing_at_or_gprs:
     47          						 1:正在接收GPRS数据
     48          						 0:在接收非GPRS数据以外的数据
     49          		wait_cip_ack:
     50          					 1:正在等待 > 括号
     51          					 0:其它		
     52          return:
     53          		0		: parse ok
     54          		others	: failed
     55          
     56          */
     57          //#define at_parse_one_frame_print
     58          static int at_parse_one_frame(uint8_t *frame,uint32_t frame_len,char Rxing_at_or_gprs,char wait_cip_ack)
     59          {
     60          	OS_ERR os_err; 
     61          	int i;
     62                  //#ifdef at_parse_one_frame_print
     63          	int j;
     64                  //#endif       
     65          	//int dlci;
     66          	uint8_t *ptr=NULL;
     67          	OS_Q *p_Q=NULL;
     68          
     69          	//--------提取出一个完整帧--------------------
     70          	
     71          	//区分出GPRS数据帧,通用AT指令帧,SEND OK帧,URC帧
     72          	if(Rxing_at_or_gprs==1)
     73          	{
     74          		//#ifdef at_parse_one_frame_print
     75          		InfoPrintf("驱动层提取出%d字节GPRS数据:",frame_len);
     76          		for(j=0;j<frame_len;j++)InfoPrintf("%02X",frame[j]);InfoPrintf("\r\n");
     77          		//#endif
     78          		p_Q=(&modem_receive_gprs_data_q);
     79          	}
     80          	else
     81          	{		
     82          		#ifdef at_parse_one_frame_print
     83          		InfoPrintf("驱动层提取出%d字节AT指令数据:",frame_len);for(j=0;j<frame_len;j++){
     84          		if(frame[j]!=0x0D && frame[j]!=0x0A&&frame[j]>0x1F&&frame[j]<0x7F)InfoPrintf("%c",frame[j]);}
     85          		InfoPrintf("\r\n");
     86          		#endif
     87          	
     88          		if(strncmp((char const *)frame,"\r\nSEND OK\r\n",11)==0)
     89          		{
     90          			p_Q = &modem_send_gprs_at_rsp_q;
     91          		}
     92          		else if(strncmp((char const *)frame,"\r\n> ",4)==0)
     93          		{
     94          			p_Q = &modem_send_gprs_at_rsp_q;			
     95          		}
     96          		else 	
     97          		{	
     98          			if((frame[2]>=0X30)&&(frame[2]<=0X39))//0~9 for ip ,10.21.255.210
     99          			{
    100          				p_Q=&modem_send_at_rsp_q;
    101          			}
    102          			else
    103          			{
    104          				for(i=0;i<AT_TBL_LEN;i++)
    105          				{
    106          					if(strncmp((char const *)frame,at_tbl[i],strlen(at_tbl[i]))==0)
    107          					{
    108          						//post at_rsp
    109          						p_Q=&modem_send_at_rsp_q;
    110          						if(i==6)// "\r\n ERROR \r\n"
    111          						{
    112          							if(wait_cip_ack>0)
    113          							{
    114          								p_Q=&modem_send_gprs_at_rsp_q;
    115          							}
    116          						}
    117          						break;
    118          					}
    119          				}
    120          				
    121          				if(i>=AT_TBL_LEN)
    122          				{	
    123          					//post urc 
    124          					#if 0
    125          					InfoPrintf("URC帧:");for(j=0;j<frame_len;j++){
    126          					if(ptr[j]!=0x0D && ptr[j]!=0x0A&&ptr[j]>0x1F&&ptr[j]<0x7F)
    127          					InfoPrintf("%c",ptr[j]);}
    128          					InfoPrintf("完Q毕\r\n");
    129          					#endif
    130          					p_Q = &modem_receive_urc_q;
    131          				}
    132          			}
    133          		}
    134          	}
    135          
    136          	if(p_Q!=NULL)
    137          	{
    138          		ptr = (uint8_t*)user_malloc(frame_len+1,__FUNCTION__);	//额外增加一个字节,填值0x00，预防后续库函数 字符串操作越界
    139          		if(ptr!=NULL)
    140          		{
    141          			//memset(ptr,0,frame_len);
    142          			ptr[frame_len]=0;									//额外增加一个字节,填值0x00，预防后续库函数 字符串操作越界
    143          			memcpy(ptr,frame,frame_len);
    144          			#if 0
    145          			InfoPrintf("driver post:");
    146          			if(modem_get_ptr_recv_remote_data_q()==p_Q)
    147          			{
    148          				InfoPrintf("modem_recv_remote_data q \r\n");
    149          			}
    150          			else if(modem_get_ptr_gprs_at_rsp_q()==p_Q)
    151          			{
    152          				InfoPrintf("modem_send_gprs_at_rsp q \r\n");
    153          			}
    154          			else if(modem_get_ptr_send_at_rsp_q()==p_Q)
    155          			{
    156          				InfoPrintf("modem_send_at_rsp q \r\n");
    157          			}
    158          			else if(modem_get_ptr_receive_urc_q()==p_Q)
    159          			{
    160          				InfoPrintf("modem_receive_urc q \r\n");
    161          			}
    162          			else 
    163          			{
    164          				InfoPrintf("其他Q \r\n");
    165          			}
    166          			InfoPrintf(":");
    167          			for(j=0;j<frame_len;j++)
    168          			{
    169          				if(ptr[j]!=0x0D && ptr[j]!=0x0A&&ptr[j]>0x1F&&ptr[j]<0x7F)
    170          				InfoPrintf("%c",ptr[j]);
    171          			}
    172          			InfoPrintf("完毕\r\n");
    173          			#endif
    174          
    175          			OSQPost(p_Q,ptr,frame_len,OS_OPT_POST_FIFO,&os_err);
    176          			if(os_err != OS_ERR_NONE)
    177          			{
    178          				InfoPrintf("post AT Q fail,%u,",os_err);		
    179          				#if 0
    180          				InfoPrintf("Q:");
    181          				for(j=0;j<frame_len;j++)
    182          				{
    183          					if(ptr[j]!=0x0D && ptr[j]!=0x0A&&ptr[j]>0x1F&&ptr[j]<0x7F)
    184          					InfoPrintf("%c",ptr[j]);
    185          				}
    186          				InfoPrintf("\r\n");
    187          				#endif
    188          				user_free(ptr,__FUNCTION__);
    189          			}
    190          			return os_err;
    191          		}
    192          		else
    193          		{	
    194          			InfoPrintf("tx Q 分配RAM 失败:");
    195          			if(&modem_receive_gprs_data_q==p_Q)
    196          			{
    197          				InfoPrintf("modem_recv_remote_data q \r\n");
    198          			}
    199          			else if(&modem_send_gprs_at_rsp_q==p_Q)
    200          			{
    201          				InfoPrintf("modem_send_gprs_at_rsp q \r\n");
    202          			}
    203          			else if(&modem_send_at_rsp_q==p_Q)
    204          			{
    205          				InfoPrintf("modem_send_at_rsp q \r\n");
    206          			}
    207          			else if(&modem_receive_urc_q==p_Q)
    208          			{
    209          				InfoPrintf("modem_receive_urc q \r\n");
    210          			}
    211          			else 
    212          			{
    213          				InfoPrintf("其他Q \r\n");
    214          			}
    215          			return -1;
    216          		}
    217          	}
    218          	else
    219          	{
    220          		InfoPrintf("不需要post\r\n");
    221          	}
    222          	return 0;
    223          }
    224          
    225          
    226          /*	
    227          brief: extract one frame from the ringbuffer
    228          
    229          	input :
    230          			inbuf    : wait for extract buf
    231          			inbuf_len: wait buf`s len
    232          	output:
    233          			extracted_frame_len: extracted frame`s length; if >0 ,means extracted one frame successfully
    234          			at_or_gprs_mode: 
    235          							0: general AT cmd mode
    236          							1: RXing GPRS data 
    237          	return:
    238          			-1		: error calling
    239          			others	: need_shift_out_amount
    240          */
    241          
    242          static int at_extract_one_rx_frame(char *inbuf,uint32_t inbuf_cache_len,uint32_t *extracted_frame_len, char *at_or_gprs_mode)
    243          {
    244          	int i=0;
    245          	//uint8_t result=0;
    246          	//static uint8_t len_size;
    247          	//int unuseful_amount=0;	
    248          	static uint32_t need_rx_gprs_data_len=0; //+IPD,xxx: ,rx GPRS数据帧length
    249          	int need_shift_out_amount=0;
    250          
    251          	*extracted_frame_len=0;
    252          
    253          	//--1-----------------------------------------------------------------------------
    254          	//rx gprs data
    255          	if(*at_or_gprs_mode==1)
    256          	{
    257          		if(inbuf_cache_len>=need_rx_gprs_data_len)
    258          		{
    259          			*extracted_frame_len  = need_rx_gprs_data_len;
    260          			need_shift_out_amount = need_rx_gprs_data_len; 
    261          			//*at_or_gprs_mode=0;
    262          		}
    263          		else
    264          		{
    265          			need_shift_out_amount=0;
    266          		}
    267          		
    268          		return need_shift_out_amount;
    269          	}
    270          
    271          	//--2-- FIND HEAD ----general at cmd data,except the essential gprs data----------------
    272          	//rx AT cmd
    273          	for(i=0;i<inbuf_cache_len-1;i++)
    274          	{
    275          		if((inbuf[i]==0x0D)&&(inbuf[i+1]==0x0A))//(porting area...........)
    276          		{
    277          			if(i==0)
    278          			{
    279          				break;
    280          			}
    281          			else
    282          			{
    283          				#if 0
    284          				InfoPrintf("HEAD无效字节---%d---\r\n");
    285          				for(j=0;j<i;j++)InfoPrintf("%02X,",inbuf[j]);
    286          				InfoPrintf("\r\n");
    287          				#endif
    288          				need_shift_out_amount=i; 
    289          				
    290          				return need_shift_out_amount;	
    291          			}
    292          		}
    293          	}
    294          
    295          	//--3--已确保inbuf的 (前2字节为:0x0D,0x0A)     并且 inbuf_len>=4------------------------
    296          	
    297          	if(inbuf_cache_len>=9)//9 
    298          	{
    299          		// " \r\n+IPD,1:  7E   XX XX XX 7E "
    300          		if(strncmp(inbuf,"\r\n+IPD,",7)==0)		//(porting area...........)
    301          		{
    302          			for(i=7;i<inbuf_cache_len;i++)
    303          			{
    304          				if(inbuf[i]==':')				//(porting area...........)
    305          				{
    306          					sscanf((char*)(inbuf+7),"%u",&need_rx_gprs_data_len);
    307          					
    308          					if((need_rx_gprs_data_len<=AT_IN_BUF_LEN-20) && (need_rx_gprs_data_len>0))//预留20个字节
    309          					{
    310          						*at_or_gprs_mode=1;//set
    311          						//shift out "\r\n+IPD,123:" char bytes
    312          						need_shift_out_amount=i+1; 			
    313          					}
    314          					else
    315          					{
    316          						//GPRS 单包数据超长,终端无法缓冲.
    317          						//shift out all cache bytes
    318          						need_shift_out_amount=inbuf_cache_len;
    319          					}
    320          					
    321          					return need_shift_out_amount;						
    322          				}
    323          
    324          				//若没有找到":"怎么办 ??
    325          				if(i>=12)//12只是举例,12-7=5,最长 99999,已经超长了,所以12足够了
    326          				{
    327          					need_shift_out_amount=12;
    328          					return need_shift_out_amount;
    329          				}
    330          			}
    331          		}
    332          	}
    333          	
    334          	//--4--找 > ------------------------------------------------------------------------------
    335          	if(strncmp(inbuf,"\r\n> ",4)==0)			//(porting area...........)
    336          	{
    337          		*extracted_frame_len=4;
    338          		need_shift_out_amount=4;
    339          		return need_shift_out_amount;
    340          	}
    341          
    342          	//--5--一般的AT指令----------------------------------------------------------------------
    343          	for(i=2;i<inbuf_cache_len-1;i++)
    344          	{
    345          		if((inbuf[i]==0x0D)&&(inbuf[i+1]==0x0A))//(porting area...........)
    346          		{
    347          			if(i>2)
    348          			{
    349          				*extracted_frame_len  = i+2;
    350          				need_shift_out_amount = i+2; 
    351          				return need_shift_out_amount;
    352          			}
    353          			else
    354          			{
    355          				//InfoPrintf("AT无效字节--2-(0D 0A)--\r\n");
    356          				need_shift_out_amount=2;
    357          				return need_shift_out_amount;
    358          			}
    359          		}
    360          
    361          		if(i>100)//仅支持最长100个字节的AT命令响应 user define
    362          		{
    363          			InfoPrintf("extract at fail,len err!!!!!\r\n"); 
    364          			need_shift_out_amount=100;
    365          			return need_shift_out_amount;
    366          		}
    367          	}
    368          
    369          	need_shift_out_amount=0;
    370          	return need_shift_out_amount;
    371          }
    372          
    373          int at_pro_2g_module_data(char *at_gprs_mode,char *wait_cipsend_ack)
    374          {
    375          	static uint32_t remain_len=0;	
    376          	int this_time_read_len=0;
    377          	uint32_t extractOut_frame_len=0;
    378          	int shift_len=0; 
    379          	
    380          	if(remain_len>AT_IN_BUF_LEN)
    381          	{
    382          		InfoPrintf("remain_len overflow ,error!!!!!\r\n"); 
    383          		remain_len=0;
    384          	}
    385          		
    386          	this_time_read_len=uart1_receive_data(inbuf+remain_len,AT_IN_BUF_LEN-remain_len);
    387          	if(this_time_read_len>0)		
    388          	{		
    389          		//InfoPrintf("====================%d\r\n",this_time_read_len); 
    390          	
    391          		remain_len+=this_time_read_len;
    392          		
    393          		while(1)	
    394          		{
    395          			if(remain_len>=4)
    396          			{
    397          				shift_len=at_extract_one_rx_frame((char *)inbuf,remain_len,&extractOut_frame_len,at_gprs_mode);
    398          				if(shift_len <= remain_len)
    399          				{	
    400          					remain_len-=shift_len;
    401          					
    402          					if(shift_len>0)	//check one frame ok
    403          					{
    404          						if(extractOut_frame_len>0)
    405          						{					
    406          							at_parse_one_frame(inbuf,extractOut_frame_len,*at_gprs_mode,*wait_cipsend_ack);	
    407          							*at_gprs_mode=0;
    408          						}
    409          						
    410          						memmove(inbuf,inbuf+shift_len,remain_len);
    411          					}
    412          					else           	//check one frame fail, but not error
    413          					{
    414          						break;		//数据有效,但暂未构成完整帧
    415          					}
    416          				}
    417          				else
    418          				{
    419          					InfoPrintf("shift_len error\r\n");  
    420          					remain_len=0;
    421          					*at_gprs_mode=0;
    422          					return -1;
    423          				}
    424          			}
    425          			else
    426          			{
    427          				break;
    428          			}
    429          		}
    430          	}
    431          	else if(this_time_read_len==0)
    432          	{
    433          		//缓存数据 小于 最小数据单元
    434          	}
    435              else if(this_time_read_len<0)
    436              {
    437            		InfoPrintf("uart1_receive_data(),input len error\r\n");    
    438              }
    439          	
    440          	return 0;
    441          }
    442          
    443          #endif
    444          
    445          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   at_extract_one_rx_frame
        32   -> InfoPrintf
        32   -> sscanf
        32   -> strncmp
      40   at_parse_one_frame
        40   -> InfoPrintf
        40   -> OSQPost
        40   -> __aeabi_memcpy
        40   -> strlen
        40   -> strncmp
        40   -> user_free
        40   -> user_malloc
      24   at_pro_2g_module_data
        24   -> InfoPrintf
        24   -> __aeabi_memmove
        24   -> at_extract_one_rx_frame
        24   -> at_parse_one_frame
        24   -> uart1_receive_data


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       8  ?_0
       8  ?_1
       8  ?_10
       4  ?_11
      12  ?_12
       8  ?_13
      20  ?_14
      20  ?_15
      28  ?_16
      28  ?_17
      24  ?_18
      24  ?_19
      12  ?_2
      12  ?_20
      16  ?_21
       8  ?_22
       4  ?_23
      32  ?_24
      36  ?_25
      20  ?_26
      40  ?_27
      16  ?_3
      12  ?_4
      20  ?_5
      12  ?_6
       8  ?_7
      20  ?_8
      28  ?_9
     254  at_extract_one_rx_frame
     352  at_parse_one_frame
     160  at_pro_2g_module_data
      36  at_tbl
       4  need_rx_gprs_data_len
     132  remain_len
          inbuf
      20  -- Other

 
   136 bytes in section .bss
    36 bytes in section .data
   124 bytes in section .rodata
 1 186 bytes in section .text
 
 1 186 bytes of CODE  memory
   124 bytes of CONST memory
   172 bytes of DATA  memory

Errors: none
Warnings: none
