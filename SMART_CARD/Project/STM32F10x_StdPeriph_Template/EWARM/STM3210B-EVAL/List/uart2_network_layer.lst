###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        30/Jan/2018  14:31:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart2\uart2_network_layer.c
#    Command line =  
#        D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart2\uart2_network_layer.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\uart2_network_layer.lst
#    Object file  =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\uart2_network_layer.o
#
###############################################################################

D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart2\uart2_network_layer.c
      1          // porting head file
      2          #include "stm32f10x.h"
      3          #include "platform_config.h"
      4          
      5          //static head file  
      6          #include <stdio.h>
      7          #include <stdarg.h>
      8          #include <string.h>
      9          #include <stdint.h>
     10          #include "ringbuffer.h"
     11          #include "uart2_network_layer.h"
     12          
     13          
     14          
     15          #define ___________UART2__PORT_AREA____START______
     16          
     17          static int uart2_init_link(void);
     18          inline int uart2_wr_rx_link_buffer(uint8_t *buf, int len);
     19          static int uart2_trig_a_tx_interrupt(void);
     20          
     21          #define UART2_SEND_DATA_RETRY_TIMES  (500)
     22          
     23          enum uart2_send_state{
     24          	UART2_SEND_IDLE=0,
     25          	UART2_SEND_SENDING
     26          };
     27          //rx ringbuffer
     28          #define UART2_RX_RINGBUF_LEN    (128*sizeof(uart2_data_package_t))
     29          static struct rt_ringbuffer uart2_rx_ringbuffer_controller={0};
     30          static uint8_t uart2_rx_ringbuf[UART2_RX_RINGBUF_LEN]={0};
     31          
     32          //tx ringbuffer
     33          #define UART2_TX_RINGBUF_LEN    (128*sizeof(uart2_data_package_t))
     34          static struct rt_ringbuffer uart2_tx_ringbuffer_controller={0};
     35          static uint8_t uart2_tx_ringbuf[UART2_TX_RINGBUF_LEN]={0};
     36          
     37          //sending status flag
     38          static enum uart2_send_state uart2_send_sta=UART2_SEND_IDLE;
     39          
     40          
     41          static void uart2_retry_delay(void)
     42          {
     43          	#if 0
     44          	OS_ERR os_err;
     45          	OSTimeDly(ms,OS_OPT_TIME_DLY,&os_err);
     46          	#else
     47          	uint32_t i;
     48          	i=0xFF;
     49          	while(i--)
     50          	{
     51          		
     52          	}
     53          	#endif
     54          }
     55          
     56          
     57          void user_uart2_open(void)
     58          {	
     59          	//#define PRINT_BARDRATE_UART2 (9600)
     60          	#define PRINT_BARDRATE_UART2 (115200)
     61          	USART_InitTypeDef USART_InitStructure={0};
     62          	//NVIC_InitTypeDef NVIC_InitStructure={0};
     63          
     64          
     65          	GPIO_InitTypeDef GPIO_InitStructure;
     66          
     67          	/* Enable clock */
     68            	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
     69          
     70          	/* Configure USART2 Tx as alternate function push-pull */
     71          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
     72          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     73          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     74          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     75          
     76          	/* Configure USART2 Rx as input floating */
     77          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
     78          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     79          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     80          	
     81          
     82          	USART_InitStructure.USART_BaudRate = PRINT_BARDRATE_UART2;//*2;
     83          
     84          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     85          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
     86          	USART_InitStructure.USART_Parity = USART_Parity_No;
     87          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     88          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     89          
     90          	/* Configure USART2 */
     91          	USART_Init(USART2, &USART_InitStructure);
     92          
     93          	/* Enable USARTy Receive and Transmit interrupts */
     94          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
     95          
     96          	/* Enable the USARTy */
     97          	USART_Cmd(USART2, ENABLE);
     98          	
     99          	//config link layer
    100          	uart2_init_link();
    101          }
    102          
    103          void user_uart2_close(void)
    104          {
    105          
    106          }
    107          
    108          void user_uart2_wakeup(void)
    109          {
    110          
    111          }
    112          
    113          void user_uart2_sleep(void)
    114          {
    115          
    116          }
    117          
    118          void user_uart2_reset(void)
    119          {
    120          	user_uart2_close();
    121          	user_uart2_open();
    122          }
    123          
    124          static void user_uart2_en_tx_int(void)
    125          {
    126          	USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    127          }
    128          
    129          static void user_uart2_dis_tx_int(void)
    130          {
    131          	USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    132          }
    133          
    134          
    135          
    136          /*
    137          	brief:  write one minimum data package to peripheral TX regs
    138          
    139          	input: 
    140          			databyte: one msg will be sent
    141          	return:
    142          			0: send fail
    143          			1: send ok
    144          */
    145          static int user_uart2_transmit_one_data_package(uart2_data_package_t package)
    146          {
    147          	//int ret_len;
    148          	uint8_t ret;
    149          	do
    150          	{
    151          		ret=USART_GetFlagStatus(USART2,USART_FLAG_TXE);
    152          	}while(ret==0);
    153          	USART_SendData(USART2, (uint8_t) package);
    154          
    155          	return 1;
    156          }
    157          
    158          /*
    159          	brief: read one minimum data package from the peripheral RX regs
    160          
    161          	input: 
    162          			databyte: pointer that point to the rx databyte
    163          	return:
    164          			0: receive one byte fail
    165          			1: receive one byte ok
    166          */
    167          static int user_uart2_receive_one_data_package(uart2_data_package_t *package)
    168          {
    169          	*package = (uart2_data_package_t)(USART2->DR);
    170          	return 1;
    171          }
    172          
    173          void USART2_IRQHandler(void)
    174          {
    175          	//uint32_t intsrc, tmp, tmp1;
    176          	uart2_data_package_t tempchar;
    177          
    178          	// Receive Data Available or Character time-out
    179          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
    180          	{
    181          		if(user_uart2_receive_one_data_package(&tempchar)==1)
    182          		{
    183          			//InfoPrintf("%c",tempchar);
    184          		
    185          			if(uart2_wr_rx_link_buffer((uint8_t *)&tempchar,sizeof(tempchar))!=1)
    186          			{
    187          				//InfoPrintf("UART2 RX link buffer full  (%d)\r\n",rt_ringbuffer_data_len(&uart2_rx_ringbuffer_controller));
    188          			}
    189          		}
    190          	}
    191          
    192          	// Transmit Holding Empty
    193          	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
    194          	{
    195          			uart2_trig_a_tx_interrupt();
    196          	}
    197          
    198          }
    199          
    200          
    201          #define __________UART2__PORT_AREA____END________
    202          
    203          
    204          
    205          
    206          
    207          /*
    208          	return:
    209          			0: idle
    210          			1: busy,can`t write data to tx buf
    211          */
    212          int uart2_get_busy_state(void)
    213          {
    214          	return uart2_send_sta;
    215          }
    216          
    217          
    218          static int uart2_init_link(void)
    219          {
    220          	rt_ringbuffer_init(&uart2_rx_ringbuffer_controller,
    221          						uart2_rx_ringbuf,
    222          						UART2_RX_RINGBUF_LEN);
    223          	
    224          	rt_ringbuffer_init(&uart2_tx_ringbuffer_controller,
    225          							uart2_tx_ringbuf,
    226          							UART2_TX_RINGBUF_LEN);
    227          
    228          	uart2_send_sta=UART2_SEND_IDLE;
    229          
    230          	return 0;
    231          }
    232          
    233          /*
    234          	output: 
    235          			package: one package that readout from tx ringbuffer
    236          	return:
    237          			0: no data need to be sent 
    238          			1: read one msg successfully
    239          		   -1: error data in ringbuffer,app caller shuld reset the tx ringbuffer
    240          */
    241          static int uart2_rd_one_package_from_tx_ringbuffer(uart2_data_package_t *package)
    242          {
    243          	uint16_t package_size=sizeof(uart2_data_package_t);
    244          	uint32_t ret_len;
    245          
    246          	if(rt_ringbuffer_data_len(&uart2_tx_ringbuffer_controller)<package_size)
    247          	{
    248          		return 0;
    249          	}
    250          
    251          	ret_len=rt_ringbuffer_get(	&uart2_tx_ringbuffer_controller,
    252                                			(uint8_t *)package,
    253                                 			 package_size );
    254          	if(ret_len==package_size)
    255          	{
    256          		return 1;
    257          	}
    258          	else if(ret_len==0)
    259          	{
    260          		return 0;
    261          	}
    262          	else
    263          	{
    264          		return -1;
    265          	}
    266          }
    267          
    268          
    269          /*
    270          	use to start one transmition by app caller,
    271           	or 
    272           	use to enable continue transmiting  in IRQ function
    273          
    274           	return:
    275          			1: tx one package successfully, will occur one tx INT soon,
    276          			   peripheral is in tx sending state.
    277          			0: tx ringbuffer is empty,trig fail,
    278          			   peripheral is in tx idle state.
    279          		   -1: read tx package from tx ringbuffer ok,but send fail.
    280          		   -2: error data format in ringbuffer,need to reset the ringbuffer.
    281          */
    282          static int uart2_trig_a_tx_interrupt(void)
    283          {
    284          	int ret;
    285          	uart2_data_package_t tx_data_package;
    286          	
    287          	ret = uart2_rd_one_package_from_tx_ringbuffer(&tx_data_package);
    288          	if(ret==1)
    289          	{
    290          		if(user_uart2_transmit_one_data_package(tx_data_package)==1)
    291          		{
    292          			uart2_send_sta=UART2_SEND_SENDING;
    293          			user_uart2_en_tx_int();
    294          			return 1;
    295          		}
    296          	}
    297          	else if(ret==0)
    298          	{
    299          		//no data in ringbuffer
    300          		user_uart2_dis_tx_int();
    301          		uart2_send_sta=UART2_SEND_IDLE;
    302          		return 0;
    303          	}
    304          	else if(ret==-1)
    305          	{
    306          		//error data in tx ringbuffer ,neet to be reset
    307          		user_uart2_dis_tx_int();
    308          		uart2_send_sta=UART2_SEND_IDLE;
    309          		return -2;
    310          	}
    311          
    312          	user_uart2_dis_tx_int();
    313          	uart2_send_sta=UART2_SEND_IDLE;
    314          	return 0;
    315          }
    316          
    317          
    318          /*
    319          	write (1 ~~ UART2_TX_RINGBUF_LEN) bytes to uart ringbuf
    320          
    321          	input:
    322          			buf: input data
    323          			len: bytes amount need to write
    324          	return:
    325          			the real amount that written to ringbuf,
    326          			it must be the 0 or len !!!!!!
    327          
    328          	note : this function is called by uart2_send_data() only, other app 
    329          	       function should not call this function
    330          */
    331          static int uart2_wr_tx_link_buf_max_len(uint8_t *buf, uint32_t len)
    332          {	
    333          	int empty_len;
    334          	int ret_len=0;
    335          	//int ret;
    336          
    337          	if(len>UART2_TX_RINGBUF_LEN)
    338          	{
    339          		return 0;
    340          	}
    341          	else
    342          	{
    343          		empty_len=rt_ringbuffer_space_len(&uart2_tx_ringbuffer_controller);
    344          		if(empty_len>=len)
    345          		{
    346          			//因为会改变ringbuffer控制器值,所以需要禁止发送中断,阻止在ISR中同时修改ringbuffer控制器
    347          			//user_uart2_dis_tx_int();
    348          			ret_len = rt_ringbuffer_put(&uart2_tx_ringbuffer_controller,buf,len);
    349          			//user_uart2_en_tx_int();
    350          			if(ret_len!=len)
    351          			{
    352          				ret_len=0;//error!!!!!
    353          			}
    354          			
    355          			if(uart2_send_sta==UART2_SEND_IDLE)
    356          			{				
    357          				//这里不需要禁止发送中断,因为是从发送空闲 到 发送激活的过程,在这个过程中不会有发送中断
    358          				uart2_trig_a_tx_interrupt();
    359          			}
    360          		}
    361          		else 
    362          		{
    363          			return 0;
    364          		}
    365          	}
    366          	return ret_len;
    367          }
    368          
    369          /*
    370          	brief: write one byte to the rx linkbuf
    371          
    372          	input: 
    373          			databyte: UART2 rx reg data
    374          	return:
    375          			0:failed
    376          			1:success
    377          */
    378          int uart2_wr_rx_link_buffer(uint8_t *buf, int len)
    379          {	  
    380          	return rt_ringbuffer_put(&uart2_rx_ringbuffer_controller,buf,len);
    381          }
    382          
    383          
    384          
    385          
    386          
    387          //-----------------------APP CALL----------------------------------------
    388          
    389          /*
    390          	brief: wr len bytes data to the tx linkbuf
    391          
    392          	input: 
    393          			buf: contain the data that want to send by can
    394          			len: bytes amount that want to write into linkbuf
    395          	return:
    396          			the real amount written to the tx link buff
    397          note:
    398          		APP call this function to send UART2 datas
    399          */
    400          int uart2_send_data(uint8_t *buf, uint32_t len)
    401          {	
    402          	int ret=0;
    403          	int ret_len=0;
    404          	int i=0,j=0,k=0;
    405          	uint16_t retry_times;
    406          	uint16_t retry_times_2;
    407          	
    408          	uint8_t *ptr;
    409          	
    410          	ptr=buf;
    411          
    412          	if(len>UART2_TX_RINGBUF_LEN)
    413          	{
    414          		i=(len/UART2_TX_RINGBUF_LEN); //
    415          		j=(len%UART2_TX_RINGBUF_LEN); //
    416          		
    417          		retry_times=UART2_SEND_DATA_RETRY_TIMES;
    418          		for(k=0;k<i;)
    419          		{
    420          			if(retry_times<=0)
    421          			{
    422          				break;
    423          			}
    424          			retry_times--;
    425          			
    426          			retry_times_2=UART2_SEND_DATA_RETRY_TIMES;
    427          			while(uart2_get_busy_state()==UART2_SEND_SENDING)
    428          			{
    429          				uart2_retry_delay();
    430          				if(retry_times_2<=0)
    431          				{
    432          					break;
    433          				}
    434          				retry_times_2--;
    435          			}
    436          			
    437          			if(retry_times_2<=0)
    438          			{
    439          				break;
    440          			}
    441          			
    442          			ret=uart2_wr_tx_link_buf_max_len(ptr,UART2_TX_RINGBUF_LEN);
    443          			ret_len+=ret;
    444          			if(ret == UART2_TX_RINGBUF_LEN)
    445          			{
    446          				retry_times=UART2_SEND_DATA_RETRY_TIMES;
    447          				ptr+=UART2_TX_RINGBUF_LEN;
    448          				k++;
    449          			}
    450          			else
    451          			{
    452          				break;
    453          			}
    454          		}
    455          
    456          		if(k==i)
    457          		{
    458          			if(j!=0)
    459          			{
    460          				retry_times=UART2_SEND_DATA_RETRY_TIMES;
    461          				while(1)
    462          				{
    463          					ret=uart2_wr_tx_link_buf_max_len(ptr,j);
    464          					if(ret==0)
    465          					{
    466          						uart2_retry_delay();
    467          					}
    468          					else
    469          					{
    470          						ret_len+=ret;
    471          						break;
    472          					}
    473          					
    474          					if(retry_times<=0)
    475          					{
    476          						break;
    477          					}
    478          					retry_times--;
    479          				}
    480          			}
    481          		}
    482          	}
    483          	else
    484          	{
    485          		retry_times=UART2_SEND_DATA_RETRY_TIMES;
    486          		while(1)
    487          		{
    488          			ret=uart2_wr_tx_link_buf_max_len(buf,len);
    489          			if(ret==0)
    490                      {
    491                        uart2_retry_delay();
    492                      }
    493                      else
    494                      {
    495                        ret_len+=ret;
    496                        break;
    497                      }
    498          			if(retry_times<=0)
    499          			{
    500          				break;
    501          			}
    502          			retry_times--;
    503          		}
    504          	}
    505          	
    506          	return ret_len;
    507          }
    508          
    509          
    510          /*
    511          	brief: read data from rx link buffer 
    512          	input:
    513          			len: bytes amount that want to read out
    514          	output:
    515          			buf: contain the read out datas
    516          	return:
    517          			the really read out bytes amount
    518          note:
    519          		APP call this function to read UART2 rx datas
    520          
    521          */
    522          int uart2_receive_data(uint8_t *buf,int read_len)
    523          {  
    524          	uint16_t package_size=sizeof(uart2_data_package_t);
    525          	uint32_t ringbuf_cache_len_in_bytes;
    526          
    527          	if(read_len>UART2_RX_RINGBUF_LEN)
    528          	{
    529          		return -1;
    530          	}
    531          
    532          	if(read_len%package_size!=0)
    533          	{
    534          		return -1;//illegal read length
    535          	}
    536          
    537          	ringbuf_cache_len_in_bytes=rt_ringbuffer_data_len(&uart2_rx_ringbuffer_controller);
    538          	
    539          	if(ringbuf_cache_len_in_bytes < package_size)
    540          	{//缓存的数据 < 最小数据单元
    541          		return 0;
    542          	}
    543          
    544          	if(read_len<=ringbuf_cache_len_in_bytes)
    545          	{//需读取 < 缓存
    546          		return rt_ringbuffer_get(  &uart2_rx_ringbuffer_controller,
    547          									buf,
    548          								   (uint16_t)read_len
    549          								);
    550          	}
    551          	else
    552          	{//需读取 > 缓存  --->先读出已缓存的数据(按package_size为最小单位读出)
    553          		return rt_ringbuffer_get(  &uart2_rx_ringbuffer_controller,
    554          								    buf,
    555          								 (((uint16_t)ringbuf_cache_len_in_bytes/sizeof(uart2_data_package_t))*sizeof(uart2_data_package_t)));
    556          	}
    557          }
    558          
    559          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART2_IRQHandler
        16   -> USART_GetITStatus
        16   -> uart2_trig_a_tx_interrupt
        16   -> uart2_wr_rx_link_buffer
        16   -> user_uart2_receive_one_data_package
       8   rt_ringbuffer_data_len
         8   -> rt_ringbuffer_status
       0   rt_ringbuffer_status
       0   uart2_get_busy_state
       8   uart2_init_link
         8   -> rt_ringbuffer_init
      16   uart2_rd_one_package_from_tx_ringbuffer
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_get
      16   uart2_receive_data
        16   -> rt_ringbuffer_data_len
         0   -> rt_ringbuffer_get
       0   uart2_retry_delay
      32   uart2_send_data
        32   -> uart2_get_busy_state
        32   -> uart2_retry_delay
        32   -> uart2_wr_tx_link_buf_max_len
       8   uart2_trig_a_tx_interrupt
         8   -> uart2_rd_one_package_from_tx_ringbuffer
         8   -> user_uart2_dis_tx_int
         8   -> user_uart2_en_tx_int
         8   -> user_uart2_transmit_one_data_package
       0   uart2_wr_rx_link_buffer
         0   -> rt_ringbuffer_put
      16   uart2_wr_tx_link_buf_max_len
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_put
        16   -> uart2_trig_a_tx_interrupt
       0   user_uart2_close
       0   user_uart2_dis_tx_int
         0   -> USART_ITConfig
       0   user_uart2_en_tx_int
         0   -> USART_ITConfig
      32   user_uart2_open
        32   -> GPIO_Init
        32   -> RCC_APB1PeriphClockCmd
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
        32   -> __aeabi_memclr4
        32   -> uart2_init_link
       0   user_uart2_receive_one_data_package
       8   user_uart2_reset
         8   -> user_uart2_close
         0   -> user_uart2_open
       0   user_uart2_sleep
      16   user_uart2_transmit_one_data_package
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       0   user_uart2_wakeup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
      16  ?_0
      58  USART2_IRQHandler
      60  rt_ringbuffer_data_len
      40  rt_ringbuffer_status
       6  uart2_get_busy_state
      36  uart2_init_link
      52  uart2_rd_one_package_from_tx_ringbuffer
      72  uart2_receive_data
      12  uart2_retry_delay
     190  uart2_send_data
     284  uart2_send_sta
          uart2_tx_ringbuffer_controller
          uart2_rx_ringbuffer_controller
          uart2_rx_ringbuf
          uart2_tx_ringbuf
      76  uart2_trig_a_tx_interrupt
      16  uart2_wr_rx_link_buffer
      66  uart2_wr_tx_link_buf_max_len
       2  user_uart2_close
      12  user_uart2_dis_tx_int
      12  user_uart2_en_tx_int
     132  user_uart2_open
      10  user_uart2_receive_one_data_package
      12  user_uart2_reset
       2  user_uart2_sleep
      30  user_uart2_transmit_one_data_package
       2  user_uart2_wakeup

 
 284 bytes in section .bss
  16 bytes in section .rodata
 914 bytes in section .text
 
 898 bytes of CODE  memory (+ 16 bytes shared)
  16 bytes of CONST memory
 284 bytes of DATA  memory

Errors: none
Warnings: none
