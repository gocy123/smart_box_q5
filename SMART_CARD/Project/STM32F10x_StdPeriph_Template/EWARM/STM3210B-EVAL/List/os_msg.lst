###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        01/Feb/2018  10:27:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_msg.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_msg.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\os_msg.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\os_msg.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_msg.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2011; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                              MESSAGE HANDLING SERVICES
     10          *
     11          * File    : OS_MSG.C
     12          * By      : JJL
     13          * Version : V3.02.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #include <os.h>
     34          
     35          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     36          const  CPU_CHAR  *os_msg__c = "$Id: $";
     37          #endif
     38          
     39          
     40          #if OS_MSG_EN > 0u
     41          /*
     42          ************************************************************************************************************************
     43          *                                            EXTEND THE POOL OF 'OS_MSG'
     44          *
     45          * Description: This function is called by your application to add OS_MSGs to the free list of OS_MSGs
     46          *
     47          * Arguments  : p_msg        is a pointer to the base address of an array of OS_MSG and should be declared as follows:
     48          *
     49          *                           OS_MSG  MyNewMsgTbl[size];
     50          *
     51          *              size         is the size of the above array
     52          *
     53          *              p_err        is a pointer to a variable that will contain an error code returned by this function.
     54          *
     55          *                               OS_ERR_MSG_POOL_NULL_PTR
     56          *                               OS_ERR_MSG_POOL_EMPTY
     57          *                               OS_ERR_NONE
     58          *
     59          * Returns    : none
     60          ************************************************************************************************************************
     61          */
     62          
     63          void  OSMsgPoolExtend (OS_MSG      *p_msg,
     64                                 OS_MSG_QTY   size,
     65                                 OS_ERR      *p_err)
     66          {
     67          #ifdef OS_SAFETY_CRITICAL
     68              if (p_err == (OS_ERR *)0) {
     69                  OS_SAFETY_CRITICAL_EXCEPTION();
     70                  return;
     71              }
     72          #endif
     73          
     74          #if OS_CFG_ARG_CHK_EN > 0u
     75              if (p_msg == (OS_MSG *)0) {
     76                 *p_err = OS_ERR_MSG_POOL_NULL_PTR;
     77                  return;
     78              }
     79              if (size == (OS_MSG_QTY)0) {
     80                 *p_err = OS_ERR_MSG_POOL_EMPTY;
     81                  return;
     82              }
     83          #endif
     84          
     85              OS_MsgPoolCreate(p_msg,                                 /* Create the singly linked list                          */
     86                               size);
     87              p_msg[size - 1u].NextPtr = OSMsgPool.NextPtr;           /* Link last OS_MSG of new list to current pool           */
     88              OSMsgPool.NextPtr       = p_msg;
     89              OSMsgPool.NbrFree      += size;                         /* All new OS_MSGs are now available                      */
     90             *p_err                   = OS_ERR_NONE;
     91          }
     92          
     93          /*$PAGE*/
     94          /*
     95          ************************************************************************************************************************
     96          *                                           CREATE A LINKED LIST OF 'OS_MSG'
     97          *
     98          * Description: This function is called to create a singly linked list of OS_MSGs which is used as a pool of available
     99          *              OS_MSGs to be used for sending messages.
    100          *
    101          * Arguments  : p_msg        is a pointer to the base address of an array of OS_MSG and should be declared as follows:
    102          *              -----
    103          *                               OS_MSG  MyMsgTbl[size];
    104          *
    105          *              size         is the size of the above array
    106          *
    107          * Returns    : none
    108          *
    109          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    110          ************************************************************************************************************************
    111          */
    112          
    113          void  OS_MsgPoolCreate (OS_MSG      *p_msg,
    114                                  OS_MSG_QTY   size)
    115          {
    116              OS_MSG      *p_msg1;
    117              OS_MSG      *p_msg2;
    118              OS_MSG_QTY   i;
    119              OS_MSG_QTY   loops;
    120          
    121          
    122          
    123              p_msg1 = p_msg;
    124              p_msg2 = p_msg;
    125              p_msg2++;
    126              loops  = size - 1u;
    127              for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
    128                  p_msg1->NextPtr = p_msg2;
    129                  p_msg1->MsgPtr  = (void      *)0;
    130                  p_msg1->MsgSize = (OS_MSG_SIZE)0u;
    131                  p_msg1->MsgTS   = (CPU_TS     )0u;
    132                  p_msg1++;
    133                  p_msg2++;
    134              }
    135              p_msg1->NextPtr = (OS_MSG    *)0;                       /* Last OS_MSG                                            */
    136              p_msg1->MsgPtr  = (void      *)0;
    137              p_msg1->MsgSize = (OS_MSG_SIZE)0u;
    138              p_msg1->MsgTS   = (CPU_TS     )0u;
    139          }
    140          
    141          /*$PAGE*/
    142          /*
    143          ************************************************************************************************************************
    144          *                                            INITIALIZE THE POOL OF 'OS_MSG'
    145          *
    146          * Description: This function is called by OSInit() to initialize the free list of OS_MSGs.
    147          *
    148          * Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
    149          *
    150          *                            OS_ERR_MSG_POOL_NULL_PTR
    151          *                            OS_ERR_MSG_POOL_EMPTY
    152          *                            OS_ERR_NONE
    153          *
    154          * Returns    : none
    155          *
    156          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    157          ************************************************************************************************************************
    158          */
    159          
    160          void  OS_MsgPoolInit (OS_ERR  *p_err)
    161          {
    162          #ifdef OS_SAFETY_CRITICAL
    163              if (p_err == (OS_ERR *)0) {
    164                  OS_SAFETY_CRITICAL_EXCEPTION();
    165                  return;
    166              }
    167          #endif
    168          
    169          #if OS_CFG_ARG_CHK_EN > 0u
    170              if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
    171                 *p_err = OS_ERR_MSG_POOL_NULL_PTR;
    172                  return;
    173              }
    174              if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) {
    175                 *p_err = OS_ERR_MSG_POOL_EMPTY;
    176                  return;
    177              }
    178          #endif
    179          
    180              OS_MsgPoolCreate(OSCfg_MsgPoolBasePtr,
    181                              OSCfg_MsgPoolSize);
    182              OSMsgPool.NextPtr =  OSCfg_MsgPoolBasePtr;
    183              OSMsgPool.NbrFree =  OSCfg_MsgPoolSize;
    184              OSMsgPool.NbrUsed = (OS_MSG_QTY)0;
    185             *p_err             =  OS_ERR_NONE;
    186          }
    187          
    188          /*$PAGE*/
    189          /*
    190          ************************************************************************************************************************
    191          *                                        RESET MESSAGE QUEUE ENTRIES PEAK TRACKING
    192          *
    193          * Description: This function clear the peak detection mechanism of the message queue
    194          *
    195          * Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure
    196          *              -------
    197          *
    198          * Returns    : none
    199          *
    200          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    201          ************************************************************************************************************************
    202          */
    203          
    204          void  OS_MsgQEntriesPeakReset (OS_MSG_Q  *p_msg_q)
    205          {
    206              CPU_SR_ALLOC();
    207          
    208          
    209              CPU_CRITICAL_ENTER();
    210              p_msg_q->NbrEntriesMax = (OS_MSG_QTY)0;
    211              CPU_CRITICAL_EXIT();
    212          }
    213          
    214          /*$PAGE*/
    215          /*
    216          ************************************************************************************************************************
    217          *                                        RELEASE ALL MESSAGE IN MESSAGE QUEUE
    218          *
    219          * Description: This function returns all the messages in a message queue to the free list.
    220          *
    221          * Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure containing messages to free.
    222          *              -------
    223          *
    224          * Returns    : the number of OS_MSGs returned to the free list
    225          *
    226          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    227          ************************************************************************************************************************
    228          */
    229          
    230          OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
    231          {
    232              OS_MSG      *p_msg;
    233              OS_MSG_QTY   qty;
    234          
    235          
    236          
    237              qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    238              if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
    239                  p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
    240                  p_msg->NextPtr          = OSMsgPool.NextPtr;
    241                  OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
    242                  OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
    243                  OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
    244                  p_msg_q->NbrEntries     = (OS_MSG_QTY)0;            /* Flush the message queue                                */
    245                  p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
    246                  p_msg_q->InPtr          = (OS_MSG   *)0;
    247                  p_msg_q->OutPtr         = (OS_MSG   *)0;
    248              }
    249              return (qty);
    250          }
    251          
    252          /*$PAGE*/
    253          /*
    254          ************************************************************************************************************************
    255          *                                               INITIALIZE A MESSAGE QUEUE
    256          *
    257          * Description: This function is called to initialize a message queue
    258          *
    259          * Arguments  : p_msg_q      is a pointer to the message queue to initialize
    260          *              -------
    261          *
    262          *              max          is the maximum number of entries that a message queue can have.
    263          *
    264          * Returns    : none
    265          *
    266          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    267          ************************************************************************************************************************
    268          */
    269          
    270          void  OS_MsgQInit (OS_MSG_Q     *p_msg_q,
    271                             OS_MSG_QTY    size)
    272          {
    273              p_msg_q->NbrEntriesSize = (OS_MSG_QTY)size;
    274              p_msg_q->NbrEntries     = (OS_MSG_QTY)0;
    275              p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
    276              p_msg_q->InPtr          = (OS_MSG   *)0;
    277              p_msg_q->OutPtr         = (OS_MSG   *)0;
    278          }
    279          
    280          /*$PAGE*/
    281          /*
    282          ************************************************************************************************************************
    283          *                                           RETRIEVE MESSAGE FROM MESSAGE QUEUE
    284          *
    285          * Description: This function retrieves a message from a message queue
    286          *
    287          * Arguments  : p_msg_q     is a pointer to the message queue where we want to extract the message from
    288          *              -------
    289          *
    290          *              p_msg_size  is a pointer to where the size (in bytes) of the message will be placed
    291          *
    292          *              p_ts        is a pointer to where the time stamp will be placed
    293          *
    294          *              p_err       is a pointer to an error code that will be returned from this call.
    295          *
    296          *                              OS_ERR_Q_EMPTY
    297          *                              OS_ERR_NONE
    298          *
    299          * Returns    : The message (a pointer)
    300          *
    301          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    302          ************************************************************************************************************************
    303          */
    304          
    305          void  *OS_MsgQGet (OS_MSG_Q    *p_msg_q,
    306                             OS_MSG_SIZE *p_msg_size,
    307                             CPU_TS      *p_ts,
    308                             OS_ERR      *p_err)
    309          {
    310              OS_MSG  *p_msg;
    311              void    *p_void;
    312          
    313          
    314          
    315          #ifdef OS_SAFETY_CRITICAL
    316              if (p_err == (OS_ERR *)0) {
    317                  OS_SAFETY_CRITICAL_EXCEPTION();
    318                  return ((void *)0);
    319              }
    320          #endif
    321          
    322              if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {
    323                 *p_msg_size = (OS_MSG_SIZE)0;
    324                  if (p_ts != (CPU_TS *)0) {
    325                     *p_ts  = (CPU_TS  )0;
    326                  }
    327                 *p_err = OS_ERR_Q_EMPTY;
    328                  return ((void *)0);
    329              }
    330          
    331              p_msg           = p_msg_q->OutPtr;
    332              p_void          = p_msg->MsgPtr;
    333              *p_msg_size     = p_msg->MsgSize;
    334              if (p_ts != (CPU_TS *)0) {
    335                 *p_ts  = p_msg->MsgTS;
    336              }
    337              p_msg_q->OutPtr = p_msg->NextPtr;
    338              if (p_msg_q->OutPtr == (OS_MSG *)0) {
    339                  p_msg_q->InPtr      = (OS_MSG   *)0;
    340                  p_msg_q->NbrEntries = (OS_MSG_QTY)0;
    341              } else {
    342                  p_msg_q->NbrEntries--;
    343              }
    344              p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
    345              OSMsgPool.NextPtr = p_msg;
    346              OSMsgPool.NbrFree++;
    347              OSMsgPool.NbrUsed--;
    348              *p_err            = OS_ERR_NONE;
    349              return (p_void);
    350          }
    351          
    352          /*
    353          ************************************************************************************************************************
    354          *                                           DEPOSIT MESSAGE IN MESSAGE QUEUE
    355          *
    356          * Description: This function places a message in a message queue
    357          *
    358          * Arguments  : p_msg_q     is a pointer to the OS_TCB of the task to post the message to
    359          *              -------
    360          *
    361          *              p_void      is a pointer to the message to send.
    362          *
    363          *              msg_size    is the size of the message (in bytes)
    364          *
    365          *              opt         specifies whether the message will be posted in FIFO or LIFO order
    366          *
    367          *                              OS_OPT_POST_FIFO
    368          *                              OS_OPT_POST_LIFO
    369          *
    370          *              ts          is a timestamp as to when the message was posted
    371          *
    372          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    373          *
    374          *                              OS_ERR_Q_MAX           if the queue is full
    375          *                              OS_ERR_MSG_POOL_EMPTY  if we no longer have any OS_MSG to use
    376          *                              OS_ERR_NONE            the message was deposited in the queue
    377          *
    378          * Returns    : none
    379          *
    380          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    381          ************************************************************************************************************************
    382          */
    383          
    384          void  OS_MsgQPut (OS_MSG_Q    *p_msg_q,
    385                            void        *p_void,
    386                            OS_MSG_SIZE  msg_size,
    387                            OS_OPT       opt,
    388                            CPU_TS       ts,
    389                            OS_ERR      *p_err)
    390          {
    391              OS_MSG  *p_msg;
    392              OS_MSG  *p_msg_in;
    393          
    394          
    395          
    396          #ifdef OS_SAFETY_CRITICAL
    397              if (p_err == (OS_ERR *)0) {
    398                  OS_SAFETY_CRITICAL_EXCEPTION();
    399                  return;
    400              }
    401          #endif
    402          
    403              if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
    404                 *p_err = OS_ERR_Q_MAX;                               /* Message queue cannot accept any more messages          */
    405                  return;
    406              }
    407          
    408              if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {
    409                 *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
    410                  return;
    411              }
    412          
    413              p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
    414              OSMsgPool.NextPtr = p_msg->NextPtr;
    415              OSMsgPool.NbrFree--;
    416              OSMsgPool.NbrUsed++;
    417              if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is this first message placed in the queue?             */
    418                  p_msg_q->InPtr         = p_msg;                     /* Yes                                                    */
    419                  p_msg_q->OutPtr        = p_msg;
    420                  p_msg_q->NbrEntries    = (OS_MSG_QTY)1;
    421              } else {
    422                  if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) { /* Assume FIFO if not LIFO                                */
    423                      p_msg_in           = p_msg_q->InPtr;            /* FIFO                                                   */
    424                      p_msg_in->NextPtr  = p_msg;
    425                      p_msg->NextPtr     = (OS_MSG *)0;
    426                      p_msg_q->InPtr     = p_msg;
    427                  } else {
    428                      p_msg->NextPtr     = p_msg_q->OutPtr;           /* LIFO                                                   */
    429                      p_msg_q->OutPtr    = p_msg;
    430                  }
    431                  p_msg_q->NbrEntries++;
    432              }
    433              if (p_msg_q->NbrEntries > p_msg_q->NbrEntriesMax) {
    434                  p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
    435              }
    436              p_msg->MsgPtr  = p_void;                                /* Deposit message in the message queue entry             */
    437              p_msg->MsgSize = msg_size;
    438              p_msg->MsgTS   = ts;
    439             *p_err          = OS_ERR_NONE;
    440          }
    441          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSMsgPoolExtend
        16   -> OS_MsgPoolCreate
       4   OS_MsgPoolCreate
      16   OS_MsgPoolInit
        16   -> OS_MsgPoolCreate
      16   OS_MsgQEntriesPeakReset
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       4   OS_MsgQFreeAll
      12   OS_MsgQGet
       0   OS_MsgQInit
      16   OS_MsgQPut


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      62  OSMsgPoolExtend
      56  OS_MsgPoolCreate
      60  OS_MsgPoolInit
      32  OS_MsgQEntriesPeakReset
      52  OS_MsgQFreeAll
      96  OS_MsgQGet
      14  OS_MsgQInit
     128  OS_MsgQPut

 
 512 bytes in section .text
 
 512 bytes of CODE memory

Errors: none
Warnings: none
