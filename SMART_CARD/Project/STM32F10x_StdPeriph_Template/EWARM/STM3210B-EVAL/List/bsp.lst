###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\BSP\bsp.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\BSP\bsp.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\bsp.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\bsp.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     MICIRUM BOARD SUPPORT PACKAGE
      4          *
      5          *                             (c) Copyright 2007; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                        BOARD SUPPORT PACKAGE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              on the
     21          *
     22          *                                     Micrium uC-Eval-STM32F107
     23          *                                        Evaluation Board
     24          *
     25          * Filename      : bsp.c
     26          * Version       : V1.00
     27          * Programmer(s) : EHS
     28          *********************************************************************************************************
     29          */
     30          
     31          /*
     32          *********************************************************************************************************
     33          *                                             INCLUDE FILES
     34          *********************************************************************************************************
     35          */
     36          
     37          #define  BSP_MODULE
     38          #include <bsp.h>
     39          #include "stm32f10x_rcc.h"
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            LOCAL DEFINES
     44          *********************************************************************************************************
     45          */
     46          
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                           LOCAL CONSTANTS
     51          *********************************************************************************************************
     52          */
     53          
     54          #define  BSP_LED_START_BIT  (13 - 1)                            /* LEDs[3:1] are sequentially connected to PTD[15:13].  */
     55          
     56          
     57          /*
     58          *********************************************************************************************************
     59          *                                          LOCAL DATA TYPES
     60          *********************************************************************************************************
     61          */
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL TABLES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                       LOCAL GLOBAL VARIABLES
     74          *********************************************************************************************************
     75          */
     76          
     77          CPU_INT32U  BSP_CPU_ClkFreq_MHz;
     78          
     79          
     80          /*
     81          *********************************************************************************************************
     82          *                                      LOCAL FUNCTION PROTOTYPES
     83          *********************************************************************************************************
     84          */
     85          
     86          static  void  BSP_LED_Init   (void);
     87          static  void  BSP_StatusInit (void);
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                             REGISTERS
     92          *********************************************************************************************************
     93          */
     94          
     95          #define  DWT_CR      *(CPU_REG32 *)0xE0001000
     96          #define  DWT_CYCCNT  *(CPU_REG32 *)0xE0001004
     97          #define  DEM_CR      *(CPU_REG32 *)0xE000EDFC
     98          #define  DBGMCU_CR   *(CPU_REG32 *)0xE0042004
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                            REGISTER BITS
    104          *********************************************************************************************************
    105          */
    106          
    107          #define  DBGMCU_CR_TRACE_IOEN_MASK       0x10
    108          #define  DBGMCU_CR_TRACE_MODE_ASYNC      0x00
    109          #define  DBGMCU_CR_TRACE_MODE_SYNC_01    0x40
    110          #define  DBGMCU_CR_TRACE_MODE_SYNC_02    0x80
    111          #define  DBGMCU_CR_TRACE_MODE_SYNC_04    0xC0
    112          #define  DBGMCU_CR_TRACE_MODE_MASK       0xC0
    113          
    114          #define  DEM_CR_TRCENA                   (1 << 24)
    115          
    116          #define  DWT_CR_CYCCNTENA                (1 <<  0)
    117          
    118          
    119          /*
    120          *********************************************************************************************************
    121          *                                     LOCAL CONFIGURATION ERRORS
    122          *********************************************************************************************************
    123          */
    124          
    125          #if ((CPU_CFG_TS_TMR_EN          != DEF_ENABLED) && \
    126               (APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    127               (OS_PROBE_HOOKS_EN          >  0u))
    128          #error  "CPU_CFG_TS_EN                  illegally #define'd in 'cpu.h'"
    129          #error  "                              [MUST be  DEF_ENABLED] when    "
    130          #error  "                               using uC/Probe COM modules    "
    131          #endif
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                               BSP_Init()
    137          *
    138          * Description : Initialize the Board Support Package (BSP).
    139          *
    140          * Argument(s) : none.
    141          *
    142          * Return(s)   : none.
    143          *
    144          * Caller(s)   : Application.
    145          *
    146          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
    147          *
    148          *               (2) CPU instruction / data tracing requires the use of the following pins :
    149          *                   (a) (1) Aysynchronous     :  PB[3]
    150          *                       (2) Synchronous 1-bit :  PE[3:2]
    151          *                       (3) Synchronous 2-bit :  PE[4:2]
    152          *                       (4) Synchronous 4-bit :  PE[6:2]
    153          *
    154          *                   (b) The uC-Eval board MAY utilize the following pins depending on the application :
    155          *                       (1) PE[5], MII_INT
    156          *                       (1) PE[6], SDCard_Detection
    157          *
    158          *                   (c) The application may wish to adjust the trace bus width depending on I/O
    159          *                       requirements.
    160          *********************************************************************************************************
    161          */
    162          
    163          void  BSP_Init (void)
    164          {
    165          #if 0
    166              BSP_IntInit();
    167          
    168              RCC_DeInit();
    169              RCC_HSEConfig(RCC_HSE_ON);                                  /* HSE = 25MHz ext. crystal.                            */
    170              RCC_WaitForHSEStartUp();
    171          
    172          
    173              RCC_PREDIV2Config(RCC_PREDIV2_Div5);                        /* Fprediv2 = HSE      /  5 =  5MHz.                    */
    174              RCC_PLL2Config(RCC_PLL2Mul_8);                              /* PLL2     = Fprediv2 *  8 = 40MHz.                    */
    175              RCC_PLL2Cmd(ENABLE);
    176              RCC_PLL3Config(RCC_PLL3Mul_10);                             /* PLL3     = Fprediv2 * 10 = 50MHz.                    */
    177              RCC_PLL3Cmd(ENABLE);
    178          
    179          
    180              RCC_HCLKConfig(RCC_SYSCLK_Div1);                            /* HCLK    = AHBCLK  = PLL1 / AHBPRES(1) = 72MHz.       */
    181              RCC_PCLK2Config(RCC_HCLK_Div1);                             /* APB2CLK = AHBCLK  / APB2DIV(1)  = 72MHz.             */
    182              RCC_PCLK1Config(RCC_HCLK_Div2);                             /* APB1CLK = AHBCLK  / APB1DIV(2)  = 36MHz (max).       */
    183              RCC_ADCCLKConfig(RCC_PCLK2_Div6);                           /* ADCCLK  = AHBCLK  / APB2DIV / 6 = 12MHz.             */
    184              RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLL1VCO_Div3);        /* OTGCLK  = PLL1VCO / USBPRES(3)  = 144MHz / 3 = 48MHz */
    185          
    186              FLASH_SetLatency(FLASH_Latency_2);                          /* 2 Flash wait states when HCLK > 48MHz.               */
    187              FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
    188          
    189              while (RCC_GetFlagStatus(RCC_FLAG_PLL2RDY) == RESET) {      /* Wait for PLL2 to lock.                               */
    190                  ;
    191              }
    192          
    193              while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET) {      /* Wait for PLL3 to lock.                               */
    194                  ;
    195              }
    196          
    197                                                                          /* Fprediv1 = PLL2 / 5 =  8MHz.                         */
    198              RCC_PREDIV1Config(RCC_PREDIV1_Source_PLL2, RCC_PREDIV1_Div5);
    199              RCC_PLL1Config(RCC_PLL1Source_PREDIV1, RCC_PLL1Mul_9);      /* PLL1 = Fprediv1 * 9 = 72Mhz.                         */
    200              RCC_PLL1Cmd(ENABLE);
    201              while (RCC_GetFlagStatus(RCC_FLAG_PLL1RDY) == RESET) {      /* Wait for PLL1 to lock.                               */
    202                  ;
    203              }
    204          
    205          
    206              RCC_SYSCLKConfig(RCC_SYSCLKSource_PLL1CLK);                 /* HCLK = SYSCLK = PLL1 = 72MHz.                        */
    207              while (RCC_GetSYSCLKSource() != 0x08) {
    208                  ;
    209              }
    210          
    211              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq() / (CPU_INT32U)1000000;
    212          
    213              BSP_CPU_ClkFreq_MHz = BSP_CPU_ClkFreq_MHz;                  /* Surpress compiler warning BSP_CPU_ClkFreq_MHz    ... */
    214                                                                          /* ... set and not used.                                */
    215          
    216              BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
    217          
    218              BSP_StatusInit();                                           /* Initialize the status input(s)                       */
    219          
    220          #ifdef TRACE_EN                                                 /* See project / compiler preprocessor options.         */
    221              DBGMCU_CR |=  DBGMCU_CR_TRACE_IOEN_MASK;                    /* Enable tracing (see Note #2).                        */
    222              DBGMCU_CR &= ~DBGMCU_CR_TRACE_MODE_MASK;                    /* Clr trace mode sel bits.                             */
    223              DBGMCU_CR |=  DBGMCU_CR_TRACE_MODE_SYNC_04;                 /* Cfg trace mode to synch 4-bit.                       */
    224          #endif
    225          #endif
    226          }
    227          
    228          
    229          /*
    230          *********************************************************************************************************
    231          *                                            BSP_CPU_ClkFreq()
    232          *
    233          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    234          *
    235          * Argument(s) : none.
    236          *
    237          * Return(s)   : The CPU clock frequency, in Hz.
    238          *
    239          * Caller(s)   : Application.
    240          *
    241          * Note(s)     : none.
    242          *********************************************************************************************************
    243          */
    244          
    245          CPU_INT32U  BSP_CPU_ClkFreq (void)
    246          {
    247              RCC_ClocksTypeDef  rcc_clocks;
    248          
    249          
    250              RCC_GetClocksFreq(&rcc_clocks);
    251          
    252              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
    253          }
    254          
    255          
    256          /*
    257          *********************************************************************************************************
    258          *********************************************************************************************************
    259          *                                              LED FUNCTIONS
    260          *********************************************************************************************************
    261          *********************************************************************************************************
    262          */
    263          
    264          /*
    265          *********************************************************************************************************
    266          *                                             BSP_LED_Init()
    267          *
    268          * Description : Initialize the I/O for the LEDs
    269          *
    270          * Argument(s) : none.
    271          *
    272          * Return(s)   : none.
    273          *
    274          * Caller(s)   : BSP_Init().
    275          *
    276          * Note(s)     : none.
    277          *********************************************************************************************************
    278          */
    279          
    280          static  void  BSP_LED_Init (void)
    281          {
    282          
    283          }
    284          
    285          
    286          /*
    287          *********************************************************************************************************
    288          *                                             BSP_LED_On()
    289          *
    290          * Description : Turn ON any or all the LEDs on the board.
    291          *
    292          * Argument(s) : led     The ID of the LED to control:
    293          *
    294          *                       0    turns ON ALL the LEDs
    295          *                       1    turns ON user LED1  on the board
    296          *                       2    turns ON user LED2  on the board
    297          *                       3    turns ON user LED3  on the board
    298          *
    299          * Return(s)   : none.
    300          *
    301          * Caller(s)   : Application.
    302          *
    303          * Note(s)     : none.
    304          *********************************************************************************************************
    305          */
    306          
    307          void  BSP_LED_On (CPU_INT08U led)
    308          {
    309            
    310          }
    311          
    312          
    313          /*
    314          *********************************************************************************************************
    315          *                                              BSP_LED_Off()
    316          *
    317          * Description : Turn OFF any or all the LEDs on the board.
    318          *
    319          * Argument(s) : led     The ID of the LED to control:
    320          *
    321          *                       0    turns OFF ALL the LEDs
    322          *                       1    turns OFF user LED1  on the board
    323          *                       2    turns OFF user LED2  on the board
    324          *                       3    turns OFF user LED3  on the board
    325          *
    326          * Return(s)   : none.
    327          *
    328          * Caller(s)   : Application.
    329          *
    330          * Note(s)     : none.
    331          *********************************************************************************************************
    332          */
    333          
    334          void  BSP_LED_Off (CPU_INT08U led)
    335          {
    336             
    337          }
    338          
    339          
    340          /*
    341          *********************************************************************************************************
    342          *                                            BSP_LED_Toggle()
    343          *
    344          * Description : TOGGLE any or all the LEDs on the board.
    345          *
    346          * Argument(s) : led     The ID of the LED to control:
    347          *
    348          *                       0    TOGGLE ALL the LEDs
    349          *                       1    TOGGLE user LED1  on the board
    350          *                       2    TOGGLE user LED2  on the board
    351          *                       3    TOGGLE user LED3  on the board
    352          *
    353          * Return(s)   : none.
    354          *
    355          * Caller(s)   : Application.
    356          *
    357          * Note(s)     : none.
    358          *********************************************************************************************************
    359          */
    360          
    361          void  BSP_LED_Toggle (CPU_INT08U led)
    362          {
    363              
    364          }
    365          
    366          
    367          /*
    368          *********************************************************************************************************
    369          *                                            BSP_StatusInit()
    370          *
    371          * Description : Initialize the status port(s)
    372          *
    373          * Argument(s) : none.
    374          *
    375          * Return(s)   : none.
    376          *
    377          * Caller(s)   : BSP_Init()
    378          *
    379          * Note(s)     : none.
    380          *********************************************************************************************************
    381          */
    382          
    383          static  void  BSP_StatusInit (void)
    384          {
    385           
    386          }
    387          
    388          
    389          /*
    390          *********************************************************************************************************
    391          *                                            BSP_StatusRd()
    392          *
    393          * Description : Get the current status of a status input
    394          *
    395          * Argument(s) : id    is the status you want to get.
    396          *
    397          * Return(s)   : DEF_ON    if the status is asserted
    398          *               DEF_OFF   if the status is negated
    399          *
    400          * Caller(s)   : application
    401          *
    402          * Note(s)     : none.
    403          *********************************************************************************************************
    404          */
    405          
    406          CPU_BOOLEAN  BSP_StatusRd (CPU_INT08U  id)
    407          {
    408             
    409              return 0;
    410          }
    411          
    412          
    413          /*
    414          *********************************************************************************************************
    415          *********************************************************************************************************
    416          *                                           OS PROBE FUNCTIONS
    417          *********************************************************************************************************
    418          *********************************************************************************************************
    419          */
    420          
    421          /*
    422          *********************************************************************************************************
    423          *                                           OSProbe_TmrInit()
    424          *
    425          * Description : Select & initialize a timer for use with the uC/Probe Plug-In for uC/OS-II.
    426          *
    427          * Argument(s) : none.
    428          *
    429          * Return(s)   : none.
    430          *
    431          * Caller(s)   : OSProbe_Init().
    432          *
    433          * Note(s)     : none.
    434          *********************************************************************************************************
    435          */
    436          
    437          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    438               (OS_PROBE_HOOKS_EN          == 1))
    439          void  OSProbe_TmrInit (void)
    440          {
    441          }
    442          #endif
    443          
    444          
    445          /*
    446          *********************************************************************************************************
    447          *                                            OSProbe_TmrRd()
    448          *
    449          * Description : Read the current counts of a free running timer.
    450          *
    451          * Argument(s) : none.
    452          *
    453          * Return(s)   : The 32-bit timer counts.
    454          *
    455          * Caller(s)   : OSProbe_TimeGetCycles().
    456          *
    457          * Note(s)     : none.
    458          *********************************************************************************************************
    459          */
    460          
    461          #if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \
    462               (OS_PROBE_HOOKS_EN          == 1))
    463          CPU_INT32U  OSProbe_TmrRd (void)
    464          {
    465              return ((CPU_INT32U)DWT_CYCCNT);
    466          }
    467          #endif
    468          
    469          
    470          /*$PAGE*/
    471          /*
    472          *********************************************************************************************************
    473          *                                          CPU_TS_TmrInit()
    474          *
    475          * Description : Initialize & start CPU timestamp timer.
    476          *
    477          * Argument(s) : none.
    478          *
    479          * Return(s)   : none.
    480          *
    481          * Caller(s)   : CPU_TS_Init().
    482          *
    483          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    484          *               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
    485          *
    486          * Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer
    487          *                   if either of the following CPU features is enabled :
    488          *
    489          *                   (a) CPU timestamps
    490          *                   (b) CPU interrupts disabled time measurements
    491          *
    492          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    493          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    494          *
    495          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    496          *                       data type.
    497          *
    498          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    499          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    500          *
    501          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    502          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    503          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    504          *
    505          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    506          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    507          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    508          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    509          *
    510          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    511          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    512          *
    513          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    514          *
    515          *                   (c) When applicable, timer period SHOULD be less than the typical measured time
    516          *                       but MUST be less than the maximum measured time; otherwise, timer resolution
    517          *                       inadequate to measure desired times.
    518          *
    519          *                   See also 'CPU_TS_TmrRd()  Note #2'.
    520          *********************************************************************************************************
    521          */
    522          
    523          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    524          void  CPU_TS_TmrInit (void)
    525          {
    526              CPU_INT32U  cpu_clk_freq_hz;
    527                
    528                
    529              DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    530              DWT_CYCCNT      = (CPU_INT32U)0u;
    531              DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
    532          
    533              cpu_clk_freq_hz = BSP_CPU_ClkFreq();    
    534              CPU_TS_TmrFreqSet(cpu_clk_freq_hz);
    535          }
    536          #endif
    537          
    538          
    539          /*$PAGE*/
    540          /*
    541          *********************************************************************************************************
    542          *                                           CPU_TS_TmrRd()
    543          *
    544          * Description : Get current CPU timestamp timer count value.
    545          *
    546          * Argument(s) : none.
    547          *
    548          * Return(s)   : Timestamp timer count (see Notes #2a & #2b).
    549          *
    550          * Caller(s)   : CPU_TS_Init(),
    551          *               CPU_TS_Get32(),
    552          *               CPU_TS_Get64(),
    553          *               CPU_IntDisMeasStart(),
    554          *               CPU_IntDisMeasStop().
    555          *
    556          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    557          *               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
    558          *
    559          * Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer
    560          *                   if either of the following CPU features is enabled :
    561          *
    562          *                   (a) CPU timestamps
    563          *                   (b) CPU interrupts disabled time measurements
    564          *
    565          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    566          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    567          *
    568          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    569          *                       data type.
    570          *
    571          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    572          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    573          *
    574          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    575          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    576          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    577          *
    578          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    579          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    580          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    581          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    582          *
    583          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    584          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    585          *
    586          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    587          *
    588          *                       (1) If timer is a 'down' counter whose values decrease with each time count,
    589          *                           then the returned timer value MUST be ones-complemented.
    590          *
    591          *                   (c) (1) When applicable, the amount of time measured by CPU timestamps is
    592          *                           calculated by either of the following equations :
    593          *
    594          *                           (A) Time measured  =  Number timer counts  *  Timer period
    595          *
    596          *                                   where
    597          *
    598          *                                       Number timer counts     Number of timer counts measured
    599          *                                       Timer period            Timer's period in some units of
    600          *                                                                   (fractional) seconds
    601          *                                       Time measured           Amount of time measured, in same
    602          *                                                                   units of (fractional) seconds
    603          *                                                                   as the Timer period
    604          *
    605          *                                                  Number timer counts
    606          *                           (B) Time measured  =  ---------------------
    607          *                                                    Timer frequency
    608          *
    609          *                                   where
    610          *
    611          *                                       Number timer counts     Number of timer counts measured
    612          *                                       Timer frequency         Timer's frequency in some units
    613          *                                                                   of counts per second
    614          *                                       Time measured           Amount of time measured, in seconds
    615          *
    616          *                       (2) Timer period SHOULD be less than the typical measured time but MUST be less
    617          *                           than the maximum measured time; otherwise, timer resolution inadequate to
    618          *                           measure desired times.
    619          *********************************************************************************************************
    620          */
    621          
    622          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    623          CPU_TS_TMR  CPU_TS_TmrRd (void)
    624          {
    625              return ((CPU_TS_TMR)DWT_CYCCNT);
    626          }
    627          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   BSP_CPU_ClkFreq
        24   -> RCC_GetClocksFreq
       0   BSP_Init
       0   BSP_LED_Off
       0   BSP_LED_On
       0   BSP_LED_Toggle
       0   BSP_StatusRd
       8   CPU_TS_TmrInit
         8   -> BSP_CPU_ClkFreq
         0   -> CPU_TS_TmrFreqSet
       0   CPU_TS_TmrRd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      16  BSP_CPU_ClkFreq
       4  BSP_CPU_ClkFreq_MHz
       2  BSP_Init
       2  BSP_LED_Off
       2  BSP_LED_On
       2  BSP_LED_Toggle
       4  BSP_StatusRd
      38  CPU_TS_TmrInit
       6  CPU_TS_TmrRd

 
  4 bytes in section .bss
 84 bytes in section .text
 
 84 bytes of CODE memory
  4 bytes of DATA memory

Errors: none
Warnings: 2
