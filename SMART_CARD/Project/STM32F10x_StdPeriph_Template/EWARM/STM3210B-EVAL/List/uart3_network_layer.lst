###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        30/Jan/2018  14:31:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart3\uart3_network_layer.c
#    Command line =  
#        D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart3\uart3_network_layer.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\uart3_network_layer.lst
#    Object file  =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\uart3_network_layer.o
#
###############################################################################

D:\SmartCardBox\SMART_CARD\Project\network_layer\nwl_uart3\uart3_network_layer.c
      1          // porting head file
      2          #include "stm32f10x.h"
      3          #include "platform_config.h"
      4          
      5          //static head file  
      6          #include <stdio.h>
      7          #include <stdarg.h>
      8          #include <string.h>
      9          #include <stdint.h>
     10          #include "ringbuffer.h"
     11          #include "uart3_network_layer.h"
     12          
     13          
     14          #define ___________UART3__PORT_AREA____START______
     15          
     16          static int uart3_init_link(void);
     17          inline int uart3_wr_rx_link_buffer(uint8_t *buf, int len);
     18          static int uart3_trig_a_tx_interrupt(void);
     19          
     20          #define UART3_SEND_DATA_RETRY_TIMES  (500)
     21          
     22          enum uart3_send_state{
     23          	UART3_SEND_IDLE=0,
     24          	UART3_SEND_SENDING
     25          };
     26          //rx ringbuffer
     27          #define UART3_RX_RINGBUF_LEN    (256*sizeof(uart3_data_package_t))
     28          static struct rt_ringbuffer uart3_rx_ringbuffer_controller={0};
     29          static uint8_t uart3_rx_ringbuf[UART3_RX_RINGBUF_LEN]={0};
     30          
     31          //tx ringbuffer
     32          #define UART3_TX_RINGBUF_LEN    (128*sizeof(uart3_data_package_t))
     33          static struct rt_ringbuffer uart3_tx_ringbuffer_controller={0};
     34          static uint8_t uart3_tx_ringbuf[UART3_TX_RINGBUF_LEN]={0};
     35          
     36          //sending status flag
     37          static enum uart3_send_state uart3_send_sta=UART3_SEND_IDLE;
     38          
     39          
     40          static void uart3_retry_delay(void)
     41          {
     42          	#if 0
     43          	OS_ERR os_err;
     44          	OSTimeDly(ms,OS_OPT_TIME_DLY,&os_err);
     45          	#else
     46          	uint32_t i;
     47          	i=0xFF;
     48          	while(i--)
     49          	{
     50          		
     51          	}
     52          	#endif
     53          }
     54          
     55          
     56          void user_uart3_open(void)
     57          {
     58          	#define PRINT_BARDRATE_UART3 (115200)
     59          	//#define PRINT_BARDRATE_UART1 (115200)
     60          	USART_InitTypeDef USART_InitStructure={0};
     61          	//NVIC_InitTypeDef NVIC_InitStructure={0};
     62          
     63          
     64          	GPIO_InitTypeDef GPIO_InitStructure;
     65          
     66          	/* Enable clock */
     67            	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
     68          
     69          	/* Configure USART2 Tx as alternate function push-pull */
     70          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
     71          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     72          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     73          	GPIO_Init(GPIOB, &GPIO_InitStructure);
     74          
     75          	/* Configure USART2 Rx as input floating */
     76          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
     77          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     78          	GPIO_Init(GPIOB, &GPIO_InitStructure);
     79          	
     80          
     81          	USART_InitStructure.USART_BaudRate = PRINT_BARDRATE_UART3;//*2;
     82          
     83          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     84          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
     85          	USART_InitStructure.USART_Parity = USART_Parity_No;
     86          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     87          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     88          
     89          	/* Configure USART2 */
     90          	USART_Init(USART3, &USART_InitStructure);
     91          
     92          	/* Enable USARTy Receive and Transmit interrupts */
     93          	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
     94          
     95          	/* Enable the USARTy */
     96          	USART_Cmd(USART3, ENABLE);
     97          	
     98          	//config link layer
     99          	uart3_init_link();
    100          }
    101          
    102          void user_uart3_close(void)
    103          {
    104          
    105          }
    106          
    107          void user_uart3_wakeup(void)
    108          {
    109          
    110          }
    111          
    112          void user_uart3_sleep(void)
    113          {
    114          
    115          }
    116          
    117          void user_uart3_reset(void)
    118          {
    119          	user_uart3_close();
    120          	user_uart3_open();
    121          }
    122          
    123          static void user_uart3_en_tx_int(void)
    124          {
    125          	USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
    126          }
    127          
    128          static void user_uart3_dis_tx_int(void)
    129          {
    130          	USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
    131          }
    132          
    133          
    134          
    135          /*
    136          	brief:  write one minimum data package to peripheral TX regs
    137          
    138          	input: 
    139          			databyte: one msg will be sent
    140          	return:
    141          			0: send fail
    142          			1: send ok
    143          */
    144          static int user_uart3_transmit_one_data_package(uart3_data_package_t package)
    145          {
    146          	//int ret_len;
    147          	uint8_t ret;
    148          	do
    149          	{
    150          		ret=USART_GetFlagStatus(USART3,USART_FLAG_TXE);
    151          	}while(ret==0);
    152          	USART_SendData(USART3, (uint8_t) package);
    153          
    154          	return 1;
    155          }
    156          
    157          /*
    158          	brief: read one minimum data package from the peripheral RX regs
    159          
    160          	input: 
    161          			databyte: pointer that point to the rx databyte
    162          	return:
    163          			0: receive one byte fail
    164          			1: receive one byte ok
    165          */
    166          static int user_uart3_receive_one_data_package(uart3_data_package_t *package)
    167          {
    168          	*package = (uart3_data_package_t)(USART3->DR);
    169          	return 1;
    170          }
    171          
    172          void USART3_IRQHandler(void)
    173          {
    174          	//uint32_t intsrc, tmp, tmp1;
    175          	uart3_data_package_t tempchar;
    176          
    177          	// Receive Data Available or Character time-out
    178          	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
    179          	{
    180          		if(user_uart3_receive_one_data_package(&tempchar)==1)
    181          		{
    182          			//InfoPrintf("%c",tempchar);
    183          		
    184          			if(uart3_wr_rx_link_buffer((uint8_t *)&tempchar,sizeof(tempchar))!=1)
    185          			{
    186          				//InfoPrintf("UART3 RX link buffer full\r\n");
    187          			}
    188          		}
    189          	}
    190          
    191          	// Transmit Holding Empty
    192          	if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
    193          	{
    194          			uart3_trig_a_tx_interrupt();
    195          	}
    196          
    197          }
    198          
    199          
    200          #define __________UART3__PORT_AREA____END________
    201          
    202          
    203          
    204          
    205          
    206          /*
    207          	return:
    208          			0: idle
    209          			1: busy,can`t write data to tx buf
    210          */
    211          int uart3_get_busy_state(void)
    212          {
    213          	return uart3_send_sta;
    214          }
    215          
    216          
    217          static int uart3_init_link(void)
    218          {
    219          	rt_ringbuffer_init(&uart3_rx_ringbuffer_controller,
    220          						uart3_rx_ringbuf,
    221          						UART3_RX_RINGBUF_LEN);
    222          	
    223          	rt_ringbuffer_init(&uart3_tx_ringbuffer_controller,
    224          							uart3_tx_ringbuf,
    225          							UART3_TX_RINGBUF_LEN);
    226          
    227          	uart3_send_sta=UART3_SEND_IDLE;
    228          
    229          	return 0;
    230          }
    231          
    232          /*
    233          	output: 
    234          			package: one package that readout from tx ringbuffer
    235          	return:
    236          			0: no data need to be sent 
    237          			1: read one msg successfully
    238          		   -1: error data in ringbuffer,app caller shuld reset the tx ringbuffer
    239          */
    240          static int uart3_rd_one_package_from_tx_ringbuffer(uart3_data_package_t *package)
    241          {
    242          	uint16_t package_size=sizeof(uart3_data_package_t);
    243          	uint32_t ret_len;
    244          
    245          	if(rt_ringbuffer_data_len(&uart3_tx_ringbuffer_controller)<package_size)
    246          	{
    247          		return 0;
    248          	}
    249          
    250          	ret_len=rt_ringbuffer_get(	&uart3_tx_ringbuffer_controller,
    251                                			(uint8_t *)package,
    252                                 			 package_size );
    253          	if(ret_len==package_size)
    254          	{
    255          		return 1;
    256          	}
    257          	else if(ret_len==0)
    258          	{
    259          		return 0;
    260          	}
    261          	else
    262          	{
    263          		return -1;
    264          	}
    265          }
    266          
    267          
    268          /*
    269          	use to start one transmition by app caller,
    270           	or 
    271           	use to enable continue transmiting  in IRQ function
    272          
    273           	return:
    274          			1: tx one package successfully, will occur one tx INT soon,
    275          			   peripheral is in tx sending state.
    276          			0: tx ringbuffer is empty,trig fail,
    277          			   peripheral is in tx idle state.
    278          		   -1: read tx package from tx ringbuffer ok,but send fail.
    279          		   -2: error data format in ringbuffer,need to reset the ringbuffer.
    280          */
    281          static int uart3_trig_a_tx_interrupt(void)
    282          {
    283          	int ret;
    284          	uart3_data_package_t tx_data_package;
    285          	
    286          	ret = uart3_rd_one_package_from_tx_ringbuffer(&tx_data_package);
    287          	if(ret==1)
    288          	{
    289          		if(user_uart3_transmit_one_data_package(tx_data_package)==1)
    290          		{
    291          			uart3_send_sta=UART3_SEND_SENDING;
    292          			user_uart3_en_tx_int();
    293          			return 1;
    294          		}
    295          	}
    296          	else if(ret==0)
    297          	{
    298          		//no data in ringbuffer
    299          		user_uart3_dis_tx_int();
    300          		uart3_send_sta=UART3_SEND_IDLE;
    301          		return 0;
    302          	}
    303          	else if(ret==-1)
    304          	{
    305          		//error data in tx ringbuffer ,neet to be reset
    306          		user_uart3_dis_tx_int();
    307          		uart3_send_sta=UART3_SEND_IDLE;
    308          		return -2;
    309          	}
    310          
    311          	user_uart3_dis_tx_int();
    312          	uart3_send_sta=UART3_SEND_IDLE;
    313          	return 0;
    314          }
    315          
    316          
    317          /*
    318          	write (1 ~~ UART3_TX_RINGBUF_LEN) bytes to uart ringbuf
    319          
    320          	input:
    321          			buf: input data
    322          			len: bytes amount need to write
    323          	return:
    324          			the real amount that written to ringbuf,
    325          			it must be the 0 or len !!!!!!
    326          
    327          	note : this function is called by uart3_send_data() only, other app 
    328          	       function should not call this function
    329          */
    330          static int uart3_wr_tx_link_buf_max_len(uint8_t *buf, uint32_t len)
    331          {	
    332          	int empty_len;
    333          	int ret_len=0;
    334          	//int ret;
    335          
    336          	if(len>UART3_TX_RINGBUF_LEN)
    337          	{
    338          		return 0;
    339          	}
    340          	else
    341          	{
    342          		empty_len=rt_ringbuffer_space_len(&uart3_tx_ringbuffer_controller);
    343          		if(empty_len>=len)
    344          		{
    345          			//因为会改变ringbuffer控制器值,所以需要禁止发送中断,阻止在ISR中同时修改ringbuffer控制器
    346          			//user_uart2_dis_tx_int();
    347          			ret_len = rt_ringbuffer_put(&uart3_tx_ringbuffer_controller,buf,len);
    348          			//user_uart2_en_tx_int();
    349          			if(ret_len!=len)
    350          			{
    351          				ret_len=0;//error!!!!!
    352          			}
    353          			
    354          			if(uart3_send_sta==UART3_SEND_IDLE)
    355          			{				
    356          				uart3_trig_a_tx_interrupt();
    357          			}
    358          		}
    359          		else 
    360          		{
    361          			return 0;
    362          		}
    363          	}
    364          	return ret_len;
    365          }
    366          
    367          /*
    368          	brief: write one byte to the rx linkbuf
    369          
    370          	input: 
    371          			databyte: UART3 rx reg data
    372          	return:
    373          			0:failed
    374          			1:success
    375          */
    376          int uart3_wr_rx_link_buffer(uint8_t *buf, int len)
    377          {	  
    378          	return rt_ringbuffer_put(&uart3_rx_ringbuffer_controller,buf,len);
    379          }
    380          
    381          
    382          
    383          
    384          
    385          //-----------------------APP CALL----------------------------------------
    386          
    387          /*
    388          	brief: wr len bytes data to the tx linkbuf
    389          
    390          	input: 
    391          			buf: contain the data that want to send by can
    392          			len: bytes amount that want to write into linkbuf
    393          	return:
    394          			the real amount written to the tx link buff
    395          note:
    396          		APP call this function to send UART0 datas
    397          */
    398          int uart3_send_data(uint8_t *buf, uint32_t len)
    399          {	
    400          	int ret=0;
    401          	int ret_len=0;
    402          	int i=0,j=0,k=0;
    403          	uint16_t retry_times;
    404          	uint16_t retry_times_2;
    405          	
    406          	uint8_t *ptr;
    407          	
    408          	ptr=buf;
    409          
    410          	if(len>UART3_TX_RINGBUF_LEN)
    411          	{
    412          		i=(len/UART3_TX_RINGBUF_LEN); //
    413          		j=(len%UART3_TX_RINGBUF_LEN); //
    414          		
    415          		retry_times=UART3_SEND_DATA_RETRY_TIMES;
    416          		for(k=0;k<i;)
    417          		{
    418          			if(retry_times<=0)
    419          			{
    420          				break;
    421          			}
    422          			retry_times--;
    423          			
    424          			retry_times_2=UART3_SEND_DATA_RETRY_TIMES;
    425          			while(uart3_get_busy_state()==UART3_SEND_SENDING)
    426          			{
    427          				uart3_retry_delay();
    428          				if(retry_times_2<=0)
    429          				{
    430          					break;
    431          				}
    432          				retry_times_2--;
    433          			}
    434          			
    435          			if(retry_times_2<=0)
    436          			{
    437          				break;
    438          			}
    439          			
    440          			ret=uart3_wr_tx_link_buf_max_len(ptr,UART3_TX_RINGBUF_LEN);
    441          			ret_len+=ret;
    442          			if(ret == UART3_TX_RINGBUF_LEN)
    443          			{
    444          				retry_times=UART3_SEND_DATA_RETRY_TIMES;
    445          				ptr+=UART3_TX_RINGBUF_LEN;
    446          				k++;
    447          			}
    448          			else
    449          			{
    450          				break;
    451          			}
    452          		}
    453          
    454          		if(k==i)
    455          		{
    456          			if(j!=0)
    457          			{
    458          				retry_times=UART3_SEND_DATA_RETRY_TIMES;
    459          				while(1)
    460          				{
    461          					ret=uart3_wr_tx_link_buf_max_len(ptr,j);
    462          					if(ret==0)
    463          					{
    464          						uart3_retry_delay();
    465          					}
    466          					else
    467          					{
    468          						ret_len+=ret;
    469          						break;
    470          					}
    471          					
    472          					if(retry_times<=0)
    473          					{
    474          						break;
    475          					}
    476          					retry_times--;
    477          				}
    478          			}
    479          		}
    480          	}
    481          	else
    482          	{
    483          		retry_times=UART3_SEND_DATA_RETRY_TIMES;
    484          		while(1)
    485          		{
    486          			ret=uart3_wr_tx_link_buf_max_len(buf,len);
    487          			if(ret==0)
    488                      {
    489                        uart3_retry_delay();
    490                      }
    491                      else
    492                      {
    493                        ret_len+=ret;
    494                        break;
    495                      }
    496          			if(retry_times<=0)
    497          			{
    498          				break;
    499          			}
    500          			retry_times--;
    501          		}
    502          	}
    503          	
    504          	return ret_len;
    505          }
    506          
    507          
    508          /*
    509          	brief: read data from rx link buffer 
    510          	input:
    511          			len: bytes amount that want to read out
    512          	output:
    513          			buf: contain the read out datas
    514          	return:
    515          			the really read out bytes amount
    516          note:
    517          		APP call this function to read UART1 rx datas
    518          
    519          */
    520          int uart3_receive_data(uint8_t *buf,int read_len)
    521          {  
    522          	uint16_t package_size=sizeof(uart3_data_package_t);
    523          	uint32_t ringbuf_cache_len_in_bytes;
    524          
    525          	if(read_len>UART3_RX_RINGBUF_LEN)
    526          	{
    527          		return -1;
    528          	}
    529          
    530          	if(read_len%package_size!=0)
    531          	{
    532          		return -1;//illegal read length
    533          	}
    534          
    535          	ringbuf_cache_len_in_bytes=rt_ringbuffer_data_len(&uart3_rx_ringbuffer_controller);
    536          	
    537          	if(ringbuf_cache_len_in_bytes < package_size)
    538          	{//缓存的数据 < 最小数据单元
    539          		return 0;
    540          	}
    541          
    542          	if(read_len<=ringbuf_cache_len_in_bytes)
    543          	{//需读取 < 缓存
    544          		return rt_ringbuffer_get(  &uart3_rx_ringbuffer_controller,
    545          									buf,
    546          								   (uint16_t)read_len
    547          								);
    548          	}
    549          	else
    550          	{//需读取 > 缓存  --->先读出已缓存的数据(按package_size为最小单位读出)
    551          		return rt_ringbuffer_get(  &uart3_rx_ringbuffer_controller,
    552          								    buf,
    553          								 (((uint16_t)ringbuf_cache_len_in_bytes/sizeof(uart3_data_package_t))*sizeof(uart3_data_package_t)));
    554          	}
    555          }
    556          
    557          
    558          
    559          
    560          
    561          
    562          
    563          
    564          
    565          
    566          
    567          
    568          
    569          
    570          
    571          
    572          
    573          
    574          
    575          
    576          
    577          
    578          
    579          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART3_IRQHandler
        16   -> USART_GetITStatus
        16   -> uart3_trig_a_tx_interrupt
        16   -> uart3_wr_rx_link_buffer
        16   -> user_uart3_receive_one_data_package
       8   rt_ringbuffer_data_len
         8   -> rt_ringbuffer_status
       0   rt_ringbuffer_status
       0   uart3_get_busy_state
       8   uart3_init_link
         8   -> rt_ringbuffer_init
      16   uart3_rd_one_package_from_tx_ringbuffer
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_get
      16   uart3_receive_data
        16   -> rt_ringbuffer_data_len
         0   -> rt_ringbuffer_get
       0   uart3_retry_delay
      32   uart3_send_data
        32   -> uart3_get_busy_state
        32   -> uart3_retry_delay
        32   -> uart3_wr_tx_link_buf_max_len
       8   uart3_trig_a_tx_interrupt
         8   -> uart3_rd_one_package_from_tx_ringbuffer
         8   -> user_uart3_dis_tx_int
         8   -> user_uart3_en_tx_int
         8   -> user_uart3_transmit_one_data_package
       0   uart3_wr_rx_link_buffer
         0   -> rt_ringbuffer_put
      16   uart3_wr_tx_link_buf_max_len
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_put
        16   -> uart3_trig_a_tx_interrupt
       0   user_uart3_close
       0   user_uart3_dis_tx_int
         0   -> USART_ITConfig
       0   user_uart3_en_tx_int
         0   -> USART_ITConfig
      32   user_uart3_open
        32   -> GPIO_Init
        32   -> RCC_APB1PeriphClockCmd
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
        32   -> __aeabi_memclr4
        32   -> uart3_init_link
       0   user_uart3_receive_one_data_package
       8   user_uart3_reset
         8   -> user_uart3_close
         0   -> user_uart3_open
       0   user_uart3_sleep
      16   user_uart3_transmit_one_data_package
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       0   user_uart3_wakeup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
      16  ?_0
      58  USART3_IRQHandler
      60  rt_ringbuffer_data_len
      40  rt_ringbuffer_status
       6  uart3_get_busy_state
      38  uart3_init_link
      52  uart3_rd_one_package_from_tx_ringbuffer
      74  uart3_receive_data
      12  uart3_retry_delay
     190  uart3_send_data
     412  uart3_send_sta
          uart3_tx_ringbuffer_controller
          uart3_rx_ringbuffer_controller
          uart3_rx_ringbuf
          uart3_tx_ringbuf
      76  uart3_trig_a_tx_interrupt
      16  uart3_wr_rx_link_buffer
      66  uart3_wr_tx_link_buf_max_len
       2  user_uart3_close
      12  user_uart3_dis_tx_int
      12  user_uart3_en_tx_int
     136  user_uart3_open
      10  user_uart3_receive_one_data_package
      12  user_uart3_reset
       2  user_uart3_sleep
      30  user_uart3_transmit_one_data_package
       2  user_uart3_wakeup

 
 412 bytes in section .bss
  16 bytes in section .rodata
 922 bytes in section .text
 
 906 bytes of CODE  memory (+ 16 bytes shared)
  16 bytes of CONST memory
 412 bytes of DATA  memory

Errors: none
Warnings: none
