###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        01/Feb/2018  10:27:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-CPU\ARM-Cortex-M3\IAR\cpu_c.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-CPU\ARM-Cortex-M3\IAR\cpu_c.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\cpu_c.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\cpu_c.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uC-CPU\ARM-Cortex-M3\IAR\cpu_c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/CPU
      4          *                                    CPU CONFIGURATION & PORT LAYER
      5          *
      6          *                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/CPU is provided in source form to registered licensees ONLY.  It is 
     11          *               illegal to distribute this source code to any third party unless you receive 
     12          *               written permission by an authorized Micrium representative.  Knowledge of 
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest 
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                            CPU PORT FILE
     26          *
     27          *                                            ARM-Cortex-M3
     28          *                                            IAR C Compiler
     29          *
     30          * Filename      : cpu_c.c
     31          * Version       : V1.28.01.00
     32          * Programmer(s) : JJL
     33          *                 BAN
     34          *********************************************************************************************************
     35          */
     36          
     37          
     38          /*
     39          *********************************************************************************************************
     40          *                                            INCLUDE FILES
     41          *********************************************************************************************************
     42          */
     43          
     44          #include  <cpu.h>
     45          #include  <cpu_core.h>
     46          
     47          #include  <lib_def.h>
     48          
     49          
     50          /*$PAGE*/
     51          /*
     52          *********************************************************************************************************
     53          *                                            LOCAL DEFINES
     54          *********************************************************************************************************
     55          */
     56          
     57          #define  CPU_INT_SRC_POS_MAX                  ((((CPU_REG_NVIC_NVIC + 1) & 0x1F) * 32) + 16)
     58          
     59          #define  CPU_BIT_BAND_SRAM_REG_LO                 0x20000000
     60          #define  CPU_BIT_BAND_SRAM_REG_HI                 0x200FFFFF
     61          #define  CPU_BIT_BAND_SRAM_BASE                   0x22000000
     62          
     63          
     64          #define  CPU_BIT_BAND_PERIPH_REG_LO               0x40000000
     65          #define  CPU_BIT_BAND_PERIPH_REG_HI               0x400FFFFF
     66          #define  CPU_BIT_BAND_PERIPH_BASE                 0x42000000
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                           LOCAL CONSTANTS
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                          LOCAL DATA TYPES
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                            LOCAL TABLES
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                       LOCAL GLOBAL VARIABLES
     93          *********************************************************************************************************
     94          */
     95          
     96          
     97          /*
     98          *********************************************************************************************************
     99          *                                      LOCAL FUNCTION PROTOTYPES
    100          *********************************************************************************************************
    101          */
    102          
    103          
    104          /*
    105          *********************************************************************************************************
    106          *                                     LOCAL CONFIGURATION ERRORS
    107          *********************************************************************************************************
    108          */
    109          
    110          
    111          /*$PAGE*/
    112          /*
    113          *********************************************************************************************************
    114          *                                          CPU_BitBandClr()
    115          *
    116          * Description : Clear bit in bit-band region.
    117          *
    118          * Argument(s) : addr            Byte address in memory space.
    119          *
    120          *               bit_nbr         Bit number in byte.
    121          *
    122          * Return(s)   : none.
    123          *
    124          * Caller(s)   : Application.
    125          *
    126          * Note(s)     : none.
    127          *********************************************************************************************************
    128          */
    129          
    130          void  CPU_BitBandClr (CPU_ADDR    addr,
    131                                CPU_INT08U  bit_nbr)
    132          {
    133              CPU_ADDR  bit_word_off;
    134              CPU_ADDR  bit_word_addr;
    135          
    136          
    137              if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
    138                  (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
    139                  bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
    140                  bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;
    141          
    142                *(volatile CPU_INT32U *)(bit_word_addr) = 0;
    143          
    144              } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
    145                         (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
    146                  bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
    147                  bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;
    148          
    149                *(volatile CPU_INT32U *)(bit_word_addr) = 0;
    150              }
    151          }
    152          
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                                          CPU_BitBandSet()
    158          *
    159          * Description : Set bit in bit-band region.
    160          *
    161          * Argument(s) : addr            Byte address in memory space.
    162          *
    163          *               bit_nbr         Bit number in byte.
    164          *
    165          * Return(s)   : none.
    166          *
    167          * Caller(s)   : Application.
    168          *
    169          * Note(s)     : none.
    170          *********************************************************************************************************
    171          */
    172          
    173          void  CPU_BitBandSet (CPU_ADDR    addr,
    174                                CPU_INT08U  bit_nbr)
    175          {
    176              CPU_ADDR  bit_word_off;
    177              CPU_ADDR  bit_word_addr;
    178          
    179          
    180              if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
    181                  (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
    182                  bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
    183                  bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;
    184          
    185                *(volatile CPU_INT32U *)(bit_word_addr) = 1;
    186          
    187              } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
    188                         (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
    189                  bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
    190                  bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;
    191          
    192                *(volatile CPU_INT32U *)(bit_word_addr) = 1;
    193              }
    194          }
    195          
    196          
    197          /*$PAGE*/
    198          /*
    199          *********************************************************************************************************
    200          *                                           CPU_IntSrcDis()
    201          *
    202          * Description : Disable an interrupt source.
    203          *
    204          * Argument(s) : pos     Position of interrupt vector in interrupt table :
    205          *
    206          *                           0       Invalid (see Note #1a).
    207          *                           1       Invalid (see Note #1b).
    208          *                           2       Non-maskable interrupt.
    209          *                           3       Hard Fault.
    210          *                           4       Memory Management.
    211          *                           5       Bus Fault.
    212          *                           6       Usage Fault.
    213          *                           7-10    Reserved.
    214          *                           11      SVCall
    215          *                           12      Debug monitor.
    216          *                           13      Reserved
    217          *                           14      PendSV.
    218          *                           15      SysTick.
    219          *                           16+     External Interrupt.
    220          *
    221          * Return(s)   : none.
    222          *
    223          * Caller(s)   : Application.
    224          *
    225          * Note(s)     : (1) Several table positions do not contain interrupt sources :
    226          *
    227          *                   (a) Position 0 contains the stack pointer.
    228          *                   (b) Positions 7-10, 13 are reserved.
    229          *
    230          *               (2) Several interrupts cannot be disabled/enabled :
    231          *
    232          *                   (a) Reset.
    233          *                   (b) NMI.
    234          *                   (c) Hard fault.
    235          *                   (d) SVCall.
    236          *                   (e) Debug monitor.
    237          *                   (f) PendSV.
    238          *
    239          *               (3) The maximum Cortex-M3 table position is 256.  A particular Cortex-M3 may have fewer
    240          *                   than 240 external exceptions and, consequently, fewer than 256 table positions.
    241          *                   This function assumes that the specified table position is valid if the interrupt
    242          *                   controller type register's INTLINESNUM field is large enough so that the position
    243          *                   COULD be valid.
    244          *********************************************************************************************************
    245          */
    246          /*$PAGE*/
    247          void  CPU_IntSrcDis (CPU_INT08U  pos)
    248          {
    249              CPU_INT08U  group;
    250              CPU_INT08U  pos_max;
    251              CPU_INT08U  nbr;
    252              CPU_SR_ALLOC();
    253          
    254          
    255              switch (pos) {
    256                  case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
    257                  case CPU_INT_RSVD_07:
    258                  case CPU_INT_RSVD_08:
    259                  case CPU_INT_RSVD_09:
    260                  case CPU_INT_RSVD_10:
    261                  case CPU_INT_RSVD_13:
    262                       break;
    263          
    264          
    265                                                                          /* ----------------- SYSTEM EXCEPTIONS ---------------- */
    266                  case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
    267                  case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
    268                  case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
    269                  case CPU_INT_SVCALL:                                    /* SVCall (see Note #2).                                */
    270                  case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
    271                  case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
    272                       break;
    273          
    274                  case CPU_INT_MEM:                                       /* Memory management.                                   */
    275                       CPU_CRITICAL_ENTER();
    276                       CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_MEMFAULTENA;
    277                       CPU_CRITICAL_EXIT();
    278                       break;
    279          
    280                  case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
    281                       CPU_CRITICAL_ENTER();
    282                       CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_BUSFAULTENA;
    283                       CPU_CRITICAL_EXIT();
    284                       break;
    285          
    286                  case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
    287                       CPU_CRITICAL_ENTER();
    288                       CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_USGFAULTENA;
    289                       CPU_CRITICAL_EXIT();
    290                       break;
    291          
    292                  case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
    293                       CPU_CRITICAL_ENTER();
    294                       CPU_REG_NVIC_ST_CTRL &= ~CPU_REG_NVIC_ST_CTRL_ENABLE;
    295                       CPU_CRITICAL_EXIT();
    296                       break;
    297          
    298          
    299                                                                          /* ---------------- EXTERNAL INTERRUPT ---------------- */
    300                  default:
    301                      pos_max = CPU_INT_SRC_POS_MAX;
    302                      if (pos < pos_max) {                                /* See Note #3.                                         */
    303                           group = (pos - 16) / 32;
    304                           nbr   = (pos - 16) % 32;
    305          
    306                           CPU_CRITICAL_ENTER();
    307                           CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
    308                           CPU_CRITICAL_EXIT();
    309                       }
    310                       break;
    311              }
    312          }
    313          
    314          
    315          /*$PAGE*/
    316          /*
    317          *********************************************************************************************************
    318          *                                           CPU_IntSrcEn()
    319          *
    320          * Description : Enable an interrupt source.
    321          *
    322          * Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
    323          *
    324          * Return(s)   : none.
    325          *
    326          * Caller(s)   : Application.
    327          *
    328          * Note(s)     : (1) See 'CPU_IntSrcDis()  Note #1'.
    329          *
    330          *               (2) See 'CPU_IntSrcDis()  Note #2'.
    331          *
    332          *               (3) See 'CPU_IntSrcDis()  Note #3'.
    333          *********************************************************************************************************
    334          */
    335          
    336          void  CPU_IntSrcEn (CPU_INT08U  pos)
    337          {
    338              CPU_INT08U  group;
    339              CPU_INT08U  nbr;
    340              CPU_INT08U  pos_max;
    341              CPU_SR_ALLOC();
    342          
    343          
    344              switch (pos) {
    345                  case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
    346                  case CPU_INT_RSVD_07:
    347                  case CPU_INT_RSVD_08:
    348                  case CPU_INT_RSVD_09:
    349                  case CPU_INT_RSVD_10:
    350                  case CPU_INT_RSVD_13:
    351                       break;
    352          
    353          
    354                                                                          /* ----------------- SYSTEM EXCEPTIONS ---------------- */
    355                  case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
    356                  case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
    357                  case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
    358                  case CPU_INT_SVCALL:                                    /* SVCall (see Note #2).                                */
    359                  case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
    360                  case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
    361                       break;
    362          
    363                  case CPU_INT_MEM:                                       /* Memory management.                                   */
    364                       CPU_CRITICAL_ENTER();
    365                       CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_MEMFAULTENA;
    366                       CPU_CRITICAL_EXIT();
    367                       break;
    368          
    369                  case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
    370                       CPU_CRITICAL_ENTER();
    371                       CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_BUSFAULTENA;
    372                       CPU_CRITICAL_EXIT();
    373                       break;
    374          
    375                  case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
    376                       CPU_CRITICAL_ENTER();
    377                       CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_USGFAULTENA;
    378                       CPU_CRITICAL_EXIT();
    379                       break;
    380          
    381                  case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
    382                       CPU_CRITICAL_ENTER();
    383                       CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_ENABLE;
    384                       CPU_CRITICAL_EXIT();
    385                       break;
    386          
    387          
    388                                                                          /* ---------------- EXTERNAL INTERRUPT ---------------- */
    389                  default:
    390                      pos_max = CPU_INT_SRC_POS_MAX;
    391                      if (pos < pos_max) {                                /* See Note #3.                                         */
    392                           group = (pos - 16) / 32;
    393                           nbr   = (pos - 16) % 32;
    394          
    395                           CPU_CRITICAL_ENTER();
    396                           CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
    397                           CPU_CRITICAL_EXIT();
    398                       }
    399                       break;
    400              }
    401          }
    402          
    403          /*$PAGE*/
    404          /*
    405          *********************************************************************************************************
    406          *                                         CPU_IntSrcPendClr()
    407          *
    408          * Description : Clear a pending interrupt.
    409          *
    410          * Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
    411          *
    412          * Return(s)   : none.
    413          *
    414          * Caller(s)   : Application.
    415          *
    416          * Note(s)     : (1) See 'CPU_IntSrcDis()  Note #1'.
    417          *
    418          *               (2) The pending status of several interrupts cannot be clear/set :
    419          *
    420          *                   (a) Reset.
    421          *                   (b) NMI.
    422          *                   (c) Hard fault.
    423          *                   (d) Memory Managment.
    424          *                   (e) Bus Fault.
    425          *                   (f) Usage Fault.
    426          *                   (g) SVCall.
    427          *                   (h) Debug monitor.
    428          *                   (i) PendSV.
    429          *                   (j) Systick 
    430          *
    431          *               (3) See 'CPU_IntSrcDis()  Note #3'.
    432          *********************************************************************************************************
    433          */
    434          
    435          void  CPU_IntSrcPendClr (CPU_INT08U  pos)
    436          
    437          {
    438              CPU_INT08U  group;
    439              CPU_INT08U  nbr;
    440              CPU_INT08U  pos_max;
    441              CPU_SR_ALLOC();
    442          
    443          
    444              switch (pos) {
    445                  case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
    446                  case CPU_INT_RSVD_07:
    447                  case CPU_INT_RSVD_08:
    448                  case CPU_INT_RSVD_09:
    449                  case CPU_INT_RSVD_10:
    450                  case CPU_INT_RSVD_13:
    451                       break;
    452                                                                          /* ----------------- SYSTEM EXCEPTIONS ---------------- */
    453                  case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
    454                  case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
    455                  case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
    456                  case CPU_INT_MEM:                                       /* Memory management (see Note #2).                     */
    457                  case CPU_INT_SVCALL:                                    /* SVCall (see Note #2).                                */
    458                  case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
    459                  case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
    460                  case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
    461                  case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
    462                  case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
    463                       break;
    464                                                                          /* ---------------- EXTERNAL INTERRUPT ---------------- */
    465                  default:
    466                      pos_max = CPU_INT_SRC_POS_MAX;
    467                      if (pos < pos_max) {                                /* See Note #3.                                         */
    468                           group = (pos - 16) / 32;
    469                           nbr   = (pos - 16) % 32;
    470          
    471                           CPU_CRITICAL_ENTER();
    472                           CPU_REG_NVIC_CLRPEND(group) = DEF_BIT(nbr);
    473                           CPU_CRITICAL_EXIT();
    474                       }
    475                       break;
    476              }
    477          }
    478          
    479          
    480          /*$PAGE*/
    481          /*
    482          *********************************************************************************************************
    483          *                                         CPU_IntSrcPrioSet()
    484          *
    485          * Description : Set priority of an interrupt source.
    486          *
    487          * Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
    488          *
    489          *               prio    Priority.  Use a lower priority number for a higher priority.
    490          *
    491          * Return(s)   : none.
    492          *
    493          * Caller(s)   : Application.
    494          *
    495          * Note(s)     : (1) See 'CPU_IntSrcDis()  Note #1'.
    496          *
    497          *               (2) Several interrupts priorities CANNOT be set :
    498          *
    499          *                   (a) Reset (always -3).
    500          *                   (b) NMI (always -2).
    501          *                   (c) Hard fault (always -1).
    502          *
    503          *               (3) See 'CPU_IntSrcDis()  Note #3'.
    504          *********************************************************************************************************
    505          */
    506          
    507          void  CPU_IntSrcPrioSet (CPU_INT08U  pos,
    508                                   CPU_INT08U  prio)
    509          {
    510              CPU_INT08U  group;
    511              CPU_INT08U  nbr;
    512              CPU_INT08U  pos_max;
    513              CPU_INT32U  prio_32;
    514              CPU_INT32U  temp;
    515              CPU_SR_ALLOC();
    516          
    517          
    518              prio_32 = CPU_RevBits((CPU_INT08U)prio);
    519              prio    = (CPU_INT08U)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
    520          
    521              switch (pos) {
    522                  case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
    523                  case CPU_INT_RSVD_07:
    524                  case CPU_INT_RSVD_08:
    525                  case CPU_INT_RSVD_09:
    526                  case CPU_INT_RSVD_10:
    527                  case CPU_INT_RSVD_13:
    528                       break;
    529          
    530          
    531                                                                          /* ----------------- SYSTEM EXCEPTIONS ---------------- */
    532                  case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
    533                  case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
    534                  case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
    535                       break;
    536          
    537                  case CPU_INT_MEM:                                       /* Memory management.                                   */
    538                       CPU_CRITICAL_ENTER();
    539                       temp                 = CPU_REG_NVIC_SHPRI1;
    540                       temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
    541                       temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
    542                       CPU_REG_NVIC_SHPRI1  = temp;
    543                       CPU_CRITICAL_EXIT();
    544                       break;
    545          
    546                  case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
    547                       CPU_CRITICAL_ENTER();
    548                       temp                 = CPU_REG_NVIC_SHPRI1;
    549                       temp                &= ~(DEF_OCTET_MASK << (1 * DEF_OCTET_NBR_BITS));
    550                       temp                |=  (prio           << (1 * DEF_OCTET_NBR_BITS));
    551                       CPU_REG_NVIC_SHPRI1  = temp;
    552                       CPU_CRITICAL_EXIT();
    553                       break;
    554          
    555                  case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
    556                       CPU_CRITICAL_ENTER();
    557                       temp                 = CPU_REG_NVIC_SHPRI1;
    558                       temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
    559                       temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
    560                       CPU_REG_NVIC_SHPRI1  = temp;
    561                       CPU_CRITICAL_EXIT();
    562                       break;
    563          
    564                  case CPU_INT_SVCALL:                                    /* SVCall.                                              */
    565                       CPU_CRITICAL_ENTER();
    566                       temp                 = CPU_REG_NVIC_SHPRI2;
    567                       temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
    568                       temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
    569                       CPU_REG_NVIC_SHPRI2  = temp;
    570                       CPU_CRITICAL_EXIT();
    571                       break;
    572          
    573                  case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
    574                       CPU_CRITICAL_ENTER();
    575                       temp                = CPU_REG_NVIC_SHPRI3;
    576                       temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
    577                       temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
    578                       CPU_REG_NVIC_SHPRI3  = temp;
    579                       CPU_CRITICAL_EXIT();
    580                       break;
    581          
    582                  case CPU_INT_PENDSV:                                    /* PendSV.                                              */
    583                       CPU_CRITICAL_ENTER();
    584                       temp                 = CPU_REG_NVIC_SHPRI3;
    585                       temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
    586                       temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
    587                       CPU_REG_NVIC_SHPRI3  = temp;
    588                       CPU_CRITICAL_EXIT();
    589                       break;
    590          
    591                  case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
    592                       CPU_CRITICAL_ENTER();
    593                       temp                 = CPU_REG_NVIC_SHPRI3;
    594                       temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
    595                       temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
    596                       CPU_REG_NVIC_SHPRI3  = temp;
    597                       CPU_CRITICAL_EXIT();
    598                       break;
    599          
    600          
    601                                                                          /* ---------------- EXTERNAL INTERRUPT ---------------- */
    602                  default:
    603                      pos_max = CPU_INT_SRC_POS_MAX;
    604                      if (pos < pos_max) {                                /* See Note #3.                                         */
    605                           group                    = (pos - 16) / 4;
    606                           nbr                      = (pos - 16) % 4;
    607          
    608                           CPU_CRITICAL_ENTER();
    609                           temp                     = CPU_REG_NVIC_PRIO(group);
    610                           temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
    611                           temp                    |=  (prio           << (nbr * DEF_OCTET_NBR_BITS));
    612                           CPU_REG_NVIC_PRIO(group) = temp;
    613                           CPU_CRITICAL_EXIT();
    614                       }
    615                       break;
    616              }
    617          }
    618          
    619          
    620          /*$PAGE*/
    621          /*
    622          *********************************************************************************************************
    623          *                                         CPU_IntSrcPrioGet()
    624          *
    625          * Description : Get priority of an interrupt source.
    626          *
    627          * Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
    628          *
    629          * Return(s)   : Priority of interrupt source.  If the interrupt source specified is invalid, then
    630          *               DEF_INT_16S_MIN_VAL is returned.
    631          *
    632          * Caller(s)   : Application.
    633          *
    634          * Note(s)     : (1) See 'CPU_IntSrcDis()      Note #1'.
    635          *
    636          *               (2) See 'CPU_IntSrcPrioSet()  Note #2'.
    637          *
    638          *               (3) See 'CPU_IntSrcDis()      Note #3'.
    639          *********************************************************************************************************
    640          */
    641          
    642          CPU_INT16S  CPU_IntSrcPrioGet (CPU_INT08U  pos)
    643          {
    644              CPU_INT08U  group;
    645              CPU_INT08U  nbr;
    646              CPU_INT08U  pos_max;
    647              CPU_INT16S  prio;
    648              CPU_INT32U  prio_32;
    649              CPU_INT32U  temp;
    650              CPU_SR_ALLOC();
    651          
    652          
    653              switch (pos) {
    654                  case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
    655                  case CPU_INT_RSVD_07:
    656                  case CPU_INT_RSVD_08:
    657                  case CPU_INT_RSVD_09:
    658                  case CPU_INT_RSVD_10:
    659                  case CPU_INT_RSVD_13:
    660                       prio = DEF_INT_16S_MIN_VAL;
    661                       break;
    662          
    663          
    664                                                                          /* ----------------- SYSTEM EXCEPTIONS ---------------- */
    665                  case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
    666                       prio = -3;
    667                       break;
    668          
    669                  case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
    670                       prio = -2;
    671                       break;
    672          
    673                  case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
    674                       prio = -1;
    675                       break;
    676          
    677          
    678                  case CPU_INT_MEM:                                       /* Memory management.                                   */
    679                       CPU_CRITICAL_ENTER();
    680                       temp = CPU_REG_NVIC_SHPRI1;
    681                       prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    682                       CPU_CRITICAL_EXIT();
    683                       break;
    684          
    685          
    686                  case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
    687                       CPU_CRITICAL_ENTER();
    688                       temp = CPU_REG_NVIC_SHPRI1;
    689                       prio = (temp >> (1 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    690                       CPU_CRITICAL_EXIT();
    691                       break;
    692          
    693          
    694                  case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
    695                       CPU_CRITICAL_ENTER();
    696                       temp = CPU_REG_NVIC_SHPRI1;
    697                       prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    698                       break;
    699          
    700                  case CPU_INT_SVCALL:                                    /* SVCall.                                              */
    701                       CPU_CRITICAL_ENTER();
    702                       temp = CPU_REG_NVIC_SHPRI2;
    703                       prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    704                       CPU_CRITICAL_EXIT();
    705                       break;
    706          
    707                  case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
    708                       CPU_CRITICAL_ENTER();
    709                       temp = CPU_REG_NVIC_SHPRI3;
    710                       prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    711                       CPU_CRITICAL_EXIT();
    712                       break;
    713          
    714                  case CPU_INT_PENDSV:                                    /* PendSV.                                              */
    715                       CPU_CRITICAL_ENTER();
    716                       temp = CPU_REG_NVIC_SHPRI3;
    717                       prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    718                       CPU_CRITICAL_EXIT();
    719                       break;
    720          
    721                  case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
    722                       CPU_CRITICAL_ENTER();
    723                       temp = CPU_REG_NVIC_SHPRI3;
    724                       prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    725                       CPU_CRITICAL_EXIT();
    726                       break;
    727          
    728          
    729                                                                          /* ---------------- EXTERNAL INTERRUPT ---------------- */
    730                  default:
    731                      pos_max = CPU_INT_SRC_POS_MAX;
    732                      if (pos < pos_max) {                                /* See Note #3.                                         */
    733                           group = (pos - 16) / 4;
    734                           nbr   = (pos - 16) % 4;
    735          
    736                           CPU_CRITICAL_ENTER();
    737                           temp  = CPU_REG_NVIC_PRIO(group);
    738                           CPU_CRITICAL_EXIT();
    739          
    740                           prio  = (temp >> (nbr * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
    741                       } else {
    742                           prio  = DEF_INT_16S_MIN_VAL;
    743                       }
    744                       break;
    745              }
    746          
    747              if (prio >= 0) {
    748                  prio_32 = CPU_RevBits((CPU_INT32U)prio);
    749                  prio    = (CPU_INT16S)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
    750              }
    751          
    752              return (prio);
    753          }
    754          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CPU_BitBandClr
       0   CPU_BitBandSet
      16   CPU_IntSrcDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   CPU_IntSrcEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   CPU_IntSrcPendClr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   CPU_IntSrcPrioGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_RevBits
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   CPU_IntSrcPrioSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_RevBits
         0   -> CPU_SR_Restore
        24   -> CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      52  CPU_BitBandClr
      52  CPU_BitBandSet
     246  CPU_IntSrcDis
     244  CPU_IntSrcEn
      78  CPU_IntSrcPendClr
     332  CPU_IntSrcPrioGet
     390  CPU_IntSrcPrioSet

 
 1 426 bytes in section .text
 
 1 426 bytes of CODE memory

Errors: none
Warnings: none
