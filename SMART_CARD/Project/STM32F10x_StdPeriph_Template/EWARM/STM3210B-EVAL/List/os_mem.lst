###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_mem.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_mem.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\os_mem.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\os_mem.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Source\os_mem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2011; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                             MEMORY PARTITION MANAGEMENT
     10          *
     11          * File    : OS_MEM.C
     12          * By      : JJL
     13          * Version : V3.02.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #include <os.h>
     34          
     35          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     36          const  CPU_CHAR  *os_mem__c = "$Id: $";
     37          #endif
     38          
     39          
     40          #if OS_CFG_MEM_EN > 0u
     41          /*
     42          ************************************************************************************************************************
     43          *                                               CREATE A MEMORY PARTITION
     44          *
     45          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-III.
     46          *
     47          * Arguments   : p_mem    is a pointer to a memory partition control block which is allocated in user memory space.
     48          *
     49          *               p_name   is a pointer to an ASCII string to provide a name to the memory partition.
     50          *
     51          *               p_addr   is the starting address of the memory partition
     52          *
     53          *               n_blks   is the number of memory blocks to create from the partition.
     54          *
     55          *               blk_size is the size (in bytes) of each block in the memory partition.
     56          *
     57          *               p_err    is a pointer to a variable containing an error message which will be set by this function to
     58          *                        either:
     59          *
     60          *                            OS_ERR_NONE                    if the memory partition has been created correctly.
     61          *                            OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the memory partition after you
     62          *                                                             called OSSafetyCriticalStart().
     63          *                            OS_ERR_MEM_INVALID_BLKS        user specified an invalid number of blocks (must be >= 2)
     64          *                            OS_ERR_MEM_INVALID_P_ADDR      if you are specifying an invalid address for the memory
     65          *                                                           storage of the partition or, the block does not align on a
     66          *                                                           pointer boundary
     67          *                            OS_ERR_MEM_INVALID_SIZE        user specified an invalid block size
     68          *                                                             - must be greater than the size of a pointer
     69          *                                                             - must be able to hold an integral number of pointers
     70          * Returns    : none
     71          ************************************************************************************************************************
     72          */
     73          
     74          void  OSMemCreate (OS_MEM      *p_mem,
     75                             CPU_CHAR    *p_name,
     76                             void        *p_addr,
     77                             OS_MEM_QTY   n_blks,
     78                             OS_MEM_SIZE  blk_size,
     79                             OS_ERR      *p_err)
     80          {
     81          #if OS_CFG_ARG_CHK_EN > 0u
     82              CPU_DATA       align_msk;
     83          #endif
     84              OS_MEM_QTY     i;
     85              OS_MEM_QTY     loops;
     86              CPU_INT08U    *p_blk;
     87              void         **p_link;
     88              CPU_SR_ALLOC();
     89          
     90          
     91          
     92          #ifdef OS_SAFETY_CRITICAL
     93              if (p_err == (OS_ERR *)0) {
     94                  OS_SAFETY_CRITICAL_EXCEPTION();
     95                  return;
     96              }
     97          #endif
     98          
     99          #ifdef OS_SAFETY_CRITICAL_IEC61508
    100              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    101                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    102                  return;
    103              }
    104          #endif
    105          
    106          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    107              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
    108                 *p_err = OS_ERR_MEM_CREATE_ISR;
    109                  return;
    110              }
    111          #endif
    112          
    113          #if OS_CFG_ARG_CHK_EN > 0u
    114              if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
    115                 *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
    116                  return;
    117              }
    118              if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
    119                 *p_err = OS_ERR_MEM_INVALID_BLKS;
    120                  return;
    121              }
    122              if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
    123                 *p_err = OS_ERR_MEM_INVALID_SIZE;
    124                  return;
    125              }
    126              align_msk = sizeof(void *) - 1u;
    127              if (align_msk > 0) {
    128                  if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
    129                     *p_err = OS_ERR_MEM_INVALID_P_ADDR;
    130                      return;
    131                  }
    132                  if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
    133                      *p_err = OS_ERR_MEM_INVALID_SIZE;
    134                  }
    135              }
    136          #endif
    137          
    138              p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
    139              p_blk  = p_addr;
    140              loops  = n_blks - 1u;
    141              for (i = 0u; i < loops; i++) {
    142                  p_blk +=  blk_size;
    143                 *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
    144                  p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
    145              }
    146              *p_link            = (void *)0;                         /* Last memory block points to NULL                       */
    147          
    148              OS_CRITICAL_ENTER();
    149              p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
    150              p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
    151              p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
    152              p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
    153              p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
    154              p_mem->NbrMax      = n_blks;
    155              p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
    156          
    157          #if OS_CFG_DBG_EN > 0u
    158              OS_MemDbgListAdd(p_mem);
    159          #endif
    160          
    161              OSMemQty++;
    162          
    163              OS_CRITICAL_EXIT();
    164             *p_err = OS_ERR_NONE;
    165          }
    166          
    167          /*$PAGE*/
    168          /*
    169          ************************************************************************************************************************
    170          *                                                  GET A MEMORY BLOCK
    171          *
    172          * Description : Get a memory block from a partition
    173          *
    174          * Arguments   : p_mem   is a pointer to the memory partition control block
    175          *
    176          *               p_err   is a pointer to a variable containing an error message which will be set by this function to
    177          *                       either:
    178          *
    179          *                       OS_ERR_NONE               if the memory partition has been created correctly.
    180          *                       OS_ERR_MEM_INVALID_P_MEM  if you passed a NULL pointer for 'p_mem'
    181          *                       OS_ERR_MEM_NO_FREE_BLKS   if there are no more free memory blocks to allocate to the caller
    182          *
    183          * Returns     : A pointer to a memory block if no error is detected
    184          *               A pointer to NULL if an error is detected
    185          ************************************************************************************************************************
    186          */
    187          
    188          void  *OSMemGet (OS_MEM  *p_mem,
    189                           OS_ERR  *p_err)
    190          {
    191              void    *p_blk;
    192              CPU_SR_ALLOC();
    193          
    194          
    195          
    196          #ifdef OS_SAFETY_CRITICAL
    197              if (p_err == (OS_ERR *)0) {
    198                  OS_SAFETY_CRITICAL_EXCEPTION();
    199                  return ((void *)0);
    200              }
    201          #endif
    202          
    203          #if OS_CFG_ARG_CHK_EN > 0u
    204              if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
    205                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
    206                  return ((void *)0);
    207              }
    208          #endif
    209          
    210              CPU_CRITICAL_ENTER();
    211              if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
    212                  CPU_CRITICAL_EXIT();
    213                 *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
    214                  return ((void *)0);                                 /*      Return NULL pointer to caller                     */
    215              }
    216              p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
    217              p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
    218              p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
    219              CPU_CRITICAL_EXIT();
    220             *p_err = OS_ERR_NONE;                                    /*      No error                                          */
    221              return (p_blk);                                         /*      Return memory block to caller                     */
    222          }
    223          
    224          /*$PAGE*/
    225          /*
    226          ************************************************************************************************************************
    227          *                                                 RELEASE A MEMORY BLOCK
    228          *
    229          * Description : Returns a memory block to a partition
    230          *
    231          * Arguments   : p_mem    is a pointer to the memory partition control block
    232          *
    233          *               p_blk    is a pointer to the memory block being released.
    234          *
    235          *               p_err    is a pointer to a variable that will contain an error code returned by this function.
    236          *
    237          *                            OS_ERR_NONE               if the memory block was inserted into the partition
    238          *                            OS_ERR_MEM_FULL           if you are returning a memory block to an already FULL memory
    239          *                                                      partition (You freed more blocks than you allocated!)
    240          *                            OS_ERR_MEM_INVALID_P_BLK  if you passed a NULL pointer for the block to release.
    241          *                            OS_ERR_MEM_INVALID_P_MEM  if you passed a NULL pointer for 'p_mem'
    242          ************************************************************************************************************************
    243          */
    244          
    245          void  OSMemPut (OS_MEM  *p_mem,
    246                          void    *p_blk,
    247                          OS_ERR  *p_err)
    248          {
    249              CPU_SR_ALLOC();
    250          
    251          
    252          
    253          #ifdef OS_SAFETY_CRITICAL
    254              if (p_err == (OS_ERR *)0) {
    255                  OS_SAFETY_CRITICAL_EXCEPTION();
    256                  return;
    257              }
    258          #endif
    259          
    260          #if OS_CFG_ARG_CHK_EN > 0u
    261              if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
    262                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
    263                  return;
    264              }
    265              if (p_blk == (void *)0) {                               /* Must release a valid block                             */
    266                 *p_err  = OS_ERR_MEM_INVALID_P_BLK;
    267                  return;
    268              }
    269          #endif
    270          
    271              CPU_CRITICAL_ENTER();
    272              if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
    273                  CPU_CRITICAL_EXIT();
    274                 *p_err = OS_ERR_MEM_FULL;
    275                  return;
    276              }
    277              *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
    278              p_mem->FreeListPtr = p_blk;
    279              p_mem->NbrFree++;                                       /* One more memory block in this partition                */
    280              CPU_CRITICAL_EXIT();
    281             *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
    282          }
    283          
    284          /*$PAGE*/
    285          /*
    286          ************************************************************************************************************************
    287          *                                           ADD MEMORY PARTITION TO DEBUG LIST
    288          *
    289          * Description : This function is called by OSMemCreate() to add the memory partition to the debug table.
    290          *
    291          * Arguments   : p_mem    Is a pointer to the memory partition
    292          *
    293          * Returns     : none
    294          *
    295          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    296          ************************************************************************************************************************
    297          */
    298          
    299          #if OS_CFG_DBG_EN > 0u
    300          void  OS_MemDbgListAdd (OS_MEM *p_mem)
    301          {
    302              p_mem->DbgPrevPtr               = (OS_MEM *)0;
    303              if (OSMemDbgListPtr == (OS_MEM *)0) {
    304                  p_mem->DbgNextPtr           = (OS_MEM *)0;
    305              } else {
    306                  p_mem->DbgNextPtr           =  OSMemDbgListPtr;
    307                  OSMemDbgListPtr->DbgPrevPtr =  p_mem;
    308              }
    309              OSMemDbgListPtr                 =  p_mem;
    310          }
    311          #endif
    312          
    313          /*$PAGE*/
    314          /*
    315          ************************************************************************************************************************
    316          *                                           INITIALIZE MEMORY PARTITION MANAGER
    317          *
    318          * Description : This function is called by uC/OS-III to initialize the memory partition manager.  Your
    319          *               application MUST NOT call this function.
    320          *
    321          * Arguments   : none
    322          *
    323          * Returns     : none
    324          *
    325          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    326          ************************************************************************************************************************
    327          */
    328          
    329          void  OS_MemInit (OS_ERR  *p_err)
    330          {
    331          #ifdef OS_SAFETY_CRITICAL
    332              if (p_err == (OS_ERR *)0) {
    333                  OS_SAFETY_CRITICAL_EXCEPTION();
    334                  return;
    335              }
    336          #endif
    337          
    338          #if OS_CFG_DBG_EN > 0u
    339              OSMemDbgListPtr = (OS_MEM   *)0;
    340          #endif
    341          
    342              OSMemQty        = (OS_OBJ_QTY)0;
    343             *p_err           = OS_ERR_NONE;
    344          }
    345          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSMemCreate
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_MemDbgListAdd
      24   OSMemGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSMemPut
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_MemDbgListAdd
       0   OS_MemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
     194  OSMemCreate
      86  OSMemGet
      96  OSMemPut
      28  OS_MemDbgListAdd
      14  OS_MemInit

 
 434 bytes in section .text
 
 434 bytes of CODE memory

Errors: none
Warnings: none
