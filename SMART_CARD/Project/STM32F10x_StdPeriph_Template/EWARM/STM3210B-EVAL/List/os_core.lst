###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        30/Jan/2018  14:31:28
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\SmartCardBox\SMART_CARD\Project\OS\uCOS-III\Source\os_core.c
#    Command line =  
#        D:\SmartCardBox\SMART_CARD\Project\OS\uCOS-III\Source\os_core.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\os_core.lst
#    Object file  =  
#        D:\SmartCardBox\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\os_core.o
#
###############################################################################

D:\SmartCardBox\SMART_CARD\Project\OS\uCOS-III\Source\os_core.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2011; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                    CORE FUNCTIONS
     10          *
     11          * File    : OS_CORE.C
     12          * By      : JJL
     13          * Version : V3.02.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #include  <os.h>
     34          
     35          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     36          const  CPU_CHAR  *os_core__c = "$Id: $";
     37          #endif
     38          
     39          /*
     40          ************************************************************************************************************************
     41          *                                                    INITIALIZATION
     42          *
     43          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     44          *              creating any uC/OS-III object and, prior to calling OS_Start().
     45          *
     46          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     47          *
     48          *                                OS_ERR_NONE    Initialization was successful
     49          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     50          * Returns    : none
     51          ************************************************************************************************************************
     52          */
     53          
     54          void  OSInit (OS_ERR  *p_err)
     55          {
     56              CPU_STK      *p_stk;
     57              CPU_STK_SIZE  size;
     58          
     59          
     60          
     61          #ifdef OS_SAFETY_CRITICAL
     62              if (p_err == (OS_ERR *)0) {
     63                  OS_SAFETY_CRITICAL_EXCEPTION();
     64                  return;
     65              }
     66          #endif
     67          
     68              OSInitHook();                                           /* Call port specific initialization code                 */
     69          
     70              OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
     71          
     72              OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
     73          
     74              OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
     75          
     76          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
     77              OSSchedLockTimeBegin            = (CPU_TS)0;
     78              OSSchedLockTimeMax              = (CPU_TS)0;
     79              OSSchedLockTimeMaxCur           = (CPU_TS)0;
     80          #endif
     81          
     82          #ifdef OS_SAFETY_CRITICAL_IEC61508
     83              OSSafetyCriticalStartFlag       =  DEF_FALSE;
     84          #endif
     85          
     86          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
     87              OSSchedRoundRobinEn             = DEF_FALSE;
     88              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
     89          #endif
     90          
     91              if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
     92                  p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
     93                  if (p_stk != (CPU_STK *)0) {
     94                      size  = OSCfg_ISRStkSize;
     95                      while (size > (CPU_STK_SIZE)0) {
     96                          size--;
     97                          *p_stk = (CPU_STK)0;
     98                          p_stk++;
     99                      }
    100                  }
    101              }
    102          
    103          #if OS_CFG_APP_HOOKS_EN > 0u
    104              OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
    105              OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    106              OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
    107          
    108              OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    109              OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    110              OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
    111              OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
    112          #endif
    113          
    114              OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
    115          
    116              OS_RdyListInit();                                       /* Initialize the Ready List                              */
    117          
    118              OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
    119              if (*p_err != OS_ERR_NONE) {
    120                  return;
    121              }
    122          
    123          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    124              OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
    125              if (*p_err != OS_ERR_NONE) {
    126                  return;
    127              }
    128          #endif
    129          
    130              OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
    131              if (*p_err != OS_ERR_NONE) {
    132                  return;
    133              }
    134          
    135              OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
    136              if (*p_err != OS_ERR_NONE) {
    137                  return;
    138              }
    139          
    140          
    141          #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
    142              OS_StatTaskInit(p_err);
    143              if (*p_err != OS_ERR_NONE) {
    144                  return;
    145              }
    146          #endif
    147          
    148          
    149          #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
    150              OS_FlagInit(p_err);
    151              if (*p_err != OS_ERR_NONE) {
    152                  return;
    153              }
    154          #endif
    155          
    156          
    157          #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
    158              OS_MemInit(p_err);
    159              if (*p_err != OS_ERR_NONE) {
    160                  return;
    161              }
    162          #endif
    163          
    164          
    165          #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
    166              OS_MsgPoolInit(p_err);
    167              if (*p_err != OS_ERR_NONE) {
    168                  return;
    169              }
    170          #endif
    171          
    172          
    173          #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
    174              OS_MutexInit(p_err);
    175              if (*p_err != OS_ERR_NONE) {
    176                  return;
    177              }
    178          #endif
    179          
    180          
    181          #if OS_CFG_Q_EN > 0u
    182              OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
    183              if (*p_err != OS_ERR_NONE) {
    184                  return;
    185              }
    186          #endif
    187          
    188          
    189          #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
    190              OS_SemInit(p_err);
    191              if (*p_err != OS_ERR_NONE) {
    192                  return;
    193              }
    194          #endif
    195          
    196          
    197          #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
    198              OS_TmrInit(p_err);
    199              if (*p_err != OS_ERR_NONE) {
    200                  return;
    201              }
    202          #endif
    203          
    204          
    205          #if OS_CFG_DBG_EN > 0u
    206              OS_Dbg_Init();
    207          #endif
    208          
    209              OSCfg_Init();
    210          }
    211          
    212          /*$PAGE*/
    213          /*
    214          ************************************************************************************************************************
    215          *                                                      ENTER ISR
    216          *
    217          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    218          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    219          *              the last nested ISR.
    220          *
    221          * Arguments  : none
    222          *
    223          * Returns    : none
    224          *
    225          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    226          *
    227          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    228          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    229          *                 uC/OS-III variables.
    230          *
    231          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    232          *
    233          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    234          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    235          *                 at the end of the ISR.
    236          *
    237          *              5) You are allowed to nest interrupts up to 250 levels deep.
    238          ************************************************************************************************************************
    239          */
    240          
    241          void  OSIntEnter (void)
    242          {
    243              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
    244                  return;                                             /* No                                                     */
    245              }
    246          
    247              if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
    248                  return;                                             /* Yes                                                    */
    249              }
    250          
    251              OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
    252          }
    253          
    254          /*$PAGE*/
    255          /*
    256          ************************************************************************************************************************
    257          *                                                       EXIT ISR
    258          *
    259          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    260          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    261          *              ready to run.
    262          *
    263          * Arguments  : none
    264          *
    265          * Returns    : none
    266          *
    267          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    268          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    269          *                 at the end of the ISR.
    270          *
    271          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    272          ************************************************************************************************************************
    273          */
    274          
    275          void  OSIntExit (void)
    276          {
    277              CPU_SR_ALLOC();
    278          
    279          
    280          
    281              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
    282                  return;                                             /* No                                                     */
    283              }
    284          
    285              CPU_INT_DIS();
    286              if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
    287                  CPU_INT_EN();
    288                  return;
    289              }
    290              OSIntNestingCtr--;
    291              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
    292                  CPU_INT_EN();                                       /* Yes                                                    */
    293                  return;
    294              }
    295          
    296              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
    297                  CPU_INT_EN();                                       /* Yes                                                    */
    298                  return;
    299              }
    300          
    301              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
    302              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
    303              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
    304                  CPU_INT_EN();                                       /* Yes                                                    */
    305                  return;
    306              }
    307          
    308          #if OS_CFG_TASK_PROFILE_EN > 0u
    309              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
    310          #endif
    311              OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
    312          
    313              OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
    314              CPU_INT_EN();
    315          }
    316          
    317          /*$PAGE*/
    318          /*
    319          ************************************************************************************************************************
    320          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    321          *
    322          * Description: This function is called by the application code to indicate that all initialization has been completed
    323          *              and that kernel objects are no longer allowed to be created.
    324          *
    325          * Arguments  : none
    326          *
    327          * Returns    : none
    328          *
    329          * Note(s)    : none
    330          ************************************************************************************************************************
    331          */
    332          
    333          #ifdef OS_SAFETY_CRITICAL_IEC61508
    334          void  OSSafetyCriticalStart (void)
    335          {
    336              OSSafetyCriticalStartFlag = DEF_TRUE;
    337          }
    338          
    339          #endif
    340          
    341          /*$PAGE*/
    342          /*
    343          ************************************************************************************************************************
    344          *                                                      SCHEDULER
    345          *
    346          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    347          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    348          *              from ISRs (see OSIntExit() for ISR rescheduling).
    349          *
    350          * Arguments  : none
    351          *
    352          * Returns    : none
    353          *
    354          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    355          ************************************************************************************************************************
    356          */
    357          
    358          void  OSSched (void)
    359          {
    360              CPU_SR_ALLOC();
    361          
    362          
    363          
    364              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
    365                  return;                                             /* Yes ... only schedule when no nested ISRs              */
    366              }
    367          
    368              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
    369                  return;                                             /* Yes                                                    */
    370              }
    371          
    372              CPU_INT_DIS();
    373              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
    374              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
    375              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
    376                  CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
    377                  return;
    378              }
    379          
    380          #if OS_CFG_TASK_PROFILE_EN > 0u
    381              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
    382          #endif
    383              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
    384          
    385              OS_TASK_SW();                                           /* Perform a task level context switch                    */
    386              CPU_INT_EN();
    387          }
    388          
    389          /*$PAGE*/
    390          /*
    391          ************************************************************************************************************************
    392          *                                                 PREVENT SCHEDULING
    393          *
    394          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    395          *              context switches until you are ready to permit context switching.
    396          *
    397          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    398          *
    399          *                            OS_ERR_NONE                 The scheduler is locked
    400          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    401          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet.
    402          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR.
    403          *
    404          * Returns    : none
    405          *
    406          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    407          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    408          ************************************************************************************************************************
    409          */
    410          
    411          void  OSSchedLock (OS_ERR  *p_err)
    412          {
    413              CPU_SR_ALLOC();
    414          
    415          
    416          
    417          #ifdef OS_SAFETY_CRITICAL
    418              if (p_err == (OS_ERR *)0) {
    419                  OS_SAFETY_CRITICAL_EXCEPTION();
    420                  return;
    421              }
    422          #endif
    423          
    424          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    425              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
    426                  *p_err = OS_ERR_SCHED_LOCK_ISR;
    427                  return;
    428              }
    429          #endif
    430          
    431              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
    432                 *p_err = OS_ERR_OS_NOT_RUNNING;
    433                  return;
    434              }
    435          
    436              if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
    437                 *p_err = OS_ERR_LOCK_NESTING_OVF;
    438                  return;
    439              }
    440          
    441              CPU_CRITICAL_ENTER();
    442              OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
    443          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    444              OS_SchedLockTimeMeasStart();
    445          #endif
    446              CPU_CRITICAL_EXIT();
    447             *p_err = OS_ERR_NONE;
    448          }
    449          
    450          /*$PAGE*/
    451          /*
    452          ************************************************************************************************************************
    453          *                                                  ENABLE SCHEDULING
    454          *
    455          * Description: This function is used to re-allow rescheduling.
    456          *
    457          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    458          *
    459          *                            OS_ERR_NONE
    460          *                            OS_ERR_OS_NOT_RUNNING       The scheduler has been enabled
    461          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    462          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    463          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR.
    464          *
    465          * Returns    : none
    466          *
    467          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    468          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    469          ************************************************************************************************************************
    470          */
    471          
    472          void  OSSchedUnlock (OS_ERR  *p_err)
    473          {
    474              CPU_SR_ALLOC();
    475          
    476          
    477          
    478          #ifdef OS_SAFETY_CRITICAL
    479              if (p_err == (OS_ERR *)0) {
    480                  OS_SAFETY_CRITICAL_EXCEPTION();
    481                  return;
    482              }
    483          #endif
    484          
    485          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    486              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
    487                  *p_err = OS_ERR_SCHED_UNLOCK_ISR;
    488                  return;
    489              }
    490          #endif
    491          
    492              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
    493                 *p_err = OS_ERR_OS_NOT_RUNNING;
    494                  return;
    495              }
    496          
    497              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
    498                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
    499                  return;
    500              }
    501          
    502              CPU_CRITICAL_ENTER();
    503              OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
    504              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
    505                  CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
    506                 *p_err = OS_ERR_SCHED_LOCKED;
    507                  return;
    508              }
    509          
    510          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    511              OS_SchedLockTimeMeasStop();
    512          #endif
    513          
    514              CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
    515              OSSched();                                              /* Run the scheduler                                      */
    516             *p_err = OS_ERR_NONE;
    517          }
    518          
    519          /*$PAGE*/
    520          /*
    521          ************************************************************************************************************************
    522          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    523          *
    524          * Description: This function is called to change the round-robin scheduling parameters.
    525          *
    526          * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
    527          *
    528          *              dflt_time_quanta  default number of ticks between time slices.  0 means assumes OSCfg_TickRate_Hz / 10.
    529          *
    530          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    531          *
    532          *                                    OS_ERR_NONE    The call was successful
    533          *
    534          * Returns    : none
    535          ************************************************************************************************************************
    536          */
    537          
    538          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    539          void  OSSchedRoundRobinCfg (CPU_BOOLEAN  en,
    540                                      OS_TICK      dflt_time_quanta,
    541                                      OS_ERR      *p_err)
    542          {
    543              CPU_SR_ALLOC();
    544          
    545          
    546          
    547          #ifdef OS_SAFETY_CRITICAL
    548              if (p_err == (OS_ERR *)0) {
    549                  OS_SAFETY_CRITICAL_EXCEPTION();
    550                  return;
    551              }
    552          #endif
    553          
    554              CPU_CRITICAL_ENTER();
    555              if (en != DEF_ENABLED) {
    556                  OSSchedRoundRobinEn = DEF_DISABLED;
    557              } else {
    558                  OSSchedRoundRobinEn = DEF_ENABLED;
    559              }
    560          
    561              if (dflt_time_quanta > (OS_TICK)0) {
    562                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
    563              } else {
    564                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
    565              }
    566              CPU_CRITICAL_EXIT();
    567             *p_err = OS_ERR_NONE;
    568          }
    569          #endif
    570          
    571          /*$PAGE*/
    572          /*
    573          ************************************************************************************************************************
    574          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    575          *
    576          * Description: This function is called to give up the CPU when it is done executing before its time slice expires.
    577          *
    578          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    579          *
    580          *                             OS_ERR_NONE                   The call was successful
    581          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    582          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    583          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    584          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    585          *
    586          * Returns    : none
    587          *
    588          * Note(s)    : 1) This function MUST be called from a task.
    589          ************************************************************************************************************************
    590          */
    591          
    592          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    593          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    594          {
    595              OS_RDY_LIST  *p_rdy_list;
    596              OS_TCB       *p_tcb;
    597              CPU_SR_ALLOC();
    598          
    599          
    600          
    601          #ifdef OS_SAFETY_CRITICAL
    602              if (p_err == (OS_ERR *)0) {
    603                  OS_SAFETY_CRITICAL_EXCEPTION();
    604                  return;
    605              }
    606          #endif
    607          
    608          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    609              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
    610                 *p_err = OS_ERR_YIELD_ISR;
    611                  return;
    612              }
    613          #endif
    614          
    615              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
    616                 *p_err = OS_ERR_SCHED_LOCKED;
    617                  return;
    618              }
    619          
    620              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
    621                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
    622                  return;
    623              }
    624          
    625              CPU_CRITICAL_ENTER();
    626              p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
    627              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
    628                  CPU_CRITICAL_EXIT();
    629                 *p_err = OS_ERR_ROUND_ROBIN_1;
    630                  return;
    631              }
    632          
    633              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
    634              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
    635              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
    636                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    637              } else {
    638                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
    639              }
    640          
    641              CPU_CRITICAL_EXIT();
    642          
    643              OSSched();                                              /* Run new task                                           */
    644             *p_err = OS_ERR_NONE;
    645          }
    646          #endif
    647          
    648          /*$PAGE*/
    649          /*
    650          ************************************************************************************************************************
    651          *                                                 START MULTITASKING
    652          *
    653          * Description: This function is used to start the multitasking process which lets uC/OS-III manages the task that you
    654          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    655          *              one application task.
    656          *
    657          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    658          *
    659          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned.
    660          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    661          *
    662          * Returns    : none
    663          *
    664          * Note(s)    : 1) OSStartHighRdy() MUST:
    665          *                 a) Call OSTaskSwHook() then,
    666          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    667          *                 c) Execute the task.
    668          *
    669          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    670          ************************************************************************************************************************
    671          */
    672          
    673          void  OSStart (OS_ERR  *p_err)
    674          {
    675          #ifdef OS_SAFETY_CRITICAL
    676              if (p_err == (OS_ERR *)0) {
    677                  OS_SAFETY_CRITICAL_EXCEPTION();
    678                  return;
    679              }
    680          #endif
    681          
    682              if (OSRunning == OS_STATE_OS_STOPPED) {
    683                  OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
    684                  OSPrioCur       = OSPrioHighRdy;
    685                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
    686                  OSTCBCurPtr     = OSTCBHighRdyPtr;
    687                  OSRunning       = OS_STATE_OS_RUNNING;
    688                  OSStartHighRdy();                                   /* Execute target specific code to start task             */
    689                 *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
    690              } else {
    691                 *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
    692              }
    693          }
    694          
    695          /*$PAGE*/
    696          /*
    697          ************************************************************************************************************************
    698          *                                                    GET VERSION
    699          *
    700          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    701          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    702          *
    703          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    704          *                      variable to
    705          *
    706          *                         OS_ERR_NONE
    707          *
    708          * Returns    : The version number of uC/OS-III multiplied by 10000.
    709          ************************************************************************************************************************
    710          */
    711          
    712          CPU_INT16U  OSVersion (OS_ERR  *p_err)
    713          {
    714          #ifdef OS_SAFETY_CRITICAL
    715              if (p_err == (OS_ERR *)0) {
    716                  OS_SAFETY_CRITICAL_EXCEPTION();
    717                  return ((CPU_INT16U)0u);
    718              }
    719          #endif
    720          
    721             *p_err = OS_ERR_NONE;
    722              return (OS_VERSION);
    723          }
    724          
    725          /*$PAGE*/
    726          /*
    727          ************************************************************************************************************************
    728          *                                                      IDLE TASK
    729          *
    730          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    731          *              they are ALL waiting for event(s) to occur.
    732          *
    733          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    734          *
    735          * Returns    : none
    736          *
    737          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    738          *
    739          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    740          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    741          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    742          *                 uC/OS-III would thus never recognize interrupts.
    743          *
    744          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    745          ************************************************************************************************************************
    746          */
    747          
    748          void  OS_IdleTask (void *p_arg)
    749          {
    750              CPU_SR_ALLOC();
    751          
    752          
    753          
    754              p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    755          
    756              while (DEF_ON) {
    757                  CPU_CRITICAL_ENTER();
    758                  OSIdleTaskCtr++;
    759          #if OS_CFG_STAT_TASK_EN > 0u
    760                  OSStatTaskCtr++;
    761          #endif
    762                  CPU_CRITICAL_EXIT();
    763          
    764                  OSIdleTaskHook();                                   /* Call user definable HOOK                               */
    765              }
    766          }
    767          
    768          /*$PAGE*/
    769          /*
    770          ************************************************************************************************************************
    771          *                                               INITIALIZE THE IDLE TASK
    772          *
    773          * Description: This function initializes the idle task
    774          *
    775          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    776          *
    777          * Returns    : none
    778          *
    779          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    780          ************************************************************************************************************************
    781          */
    782          
    783          void  OS_IdleTaskInit (OS_ERR  *p_err)
    784          {
    785          #ifdef OS_SAFETY_CRITICAL
    786              if (p_err == (OS_ERR *)0) {
    787                  OS_SAFETY_CRITICAL_EXCEPTION();
    788                  return;
    789              }
    790          #endif
    791          
    792              OSIdleTaskCtr = (OS_IDLE_CTR)0;
    793                                                                      /* ---------------- CREATE THE IDLE TASK ---------------- */
    794              OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
    795                           (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
    796                           (OS_TASK_PTR)OS_IdleTask,
    797                           (void       *)0,
    798                           (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
    799                           (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
    800                           (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
    801                           (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
    802                           (OS_MSG_QTY  )0u,
    803                           (OS_TICK     )0u,
    804                           (void       *)0,
    805                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
    806                           (OS_ERR     *)p_err);
    807          }
    808          
    809          /*$PAGE*/
    810          /*
    811          ************************************************************************************************************************
    812          *                                             BLOCK A TASK PENDING ON EVENT
    813          *
    814          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    815          *              exist because it is common to a number of OSxxxPend() services.
    816          *
    817          * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
    818          *              -----------    pending on the desired object.
    819          
    820          *              p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    821          *              -----          the caller must pass a NULL pointer.
    822          *
    823          *              pending_on     Specifies what the task will be pending on:
    824          *
    825          *                                 OS_TASK_PEND_ON_FLAG
    826          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    827          *                                 OS_TASK_PEND_ON_MUTEX
    828          *                                 OS_TASK_PEND_ON_Q
    829          *                                 OS_TASK_PEND_ON_SEM
    830          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
    831          *
    832          *              timeout        Is the amount of time the task will wait for the event to occur.
    833          *
    834          * Returns    : none
    835          *
    836          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    837          ************************************************************************************************************************
    838          */
    839          
    840          void  OS_Pend (OS_PEND_DATA  *p_pend_data,
    841                         OS_PEND_OBJ   *p_obj,
    842                         OS_STATE       pending_on,
    843                         OS_TICK        timeout)
    844          {
    845              OS_PEND_LIST  *p_pend_list;
    846          
    847          
    848          
    849              OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
    850              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
    851          
    852              OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
    853                           timeout);
    854          
    855              if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
    856                  p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
    857                  p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
    858                  OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
    859                                  (OS_PEND_DATA *)p_pend_data,
    860                                  (OS_OBJ_QTY    )1);
    861                  OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
    862                                        p_pend_data);
    863              } else {
    864                  OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
    865                  OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
    866              }
    867          #if OS_CFG_DBG_EN > 0u
    868              OS_PendDbgNameAdd(p_obj,
    869                                OSTCBCurPtr);
    870          #endif
    871          }
    872          
    873          /*$PAGE*/
    874          /*
    875          ************************************************************************************************************************
    876          *                                                     ABORT PENDING
    877          *
    878          * Description: This function is called by OSxxxPendAbort() functions to abort pending on an event.
    879          *
    880          * Arguments  : p_obj          Is a pointer to the object to pend abort.
    881          *              -----
    882          *
    883          *              p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
    884          *              -----
    885          *
    886          *              ts             The is a timestamp as to when the pend abort occurred
    887          *
    888          * Returns    : none
    889          *
    890          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    891          ************************************************************************************************************************
    892          */
    893          
    894          void   OS_PendAbort (OS_PEND_OBJ *p_obj,
    895                               OS_TCB      *p_tcb,
    896                               CPU_TS       ts)
    897          {
    898              switch (p_tcb->TaskState) {
    899                  case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
    900                  case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
    901                  case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
    902                  case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
    903                       break;
    904          
    905                  case OS_TASK_STATE_PEND:
    906                  case OS_TASK_STATE_PEND_TIMEOUT:
    907                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
    908                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    909                                         p_tcb,
    910                                         ts);
    911                       }
    912          #if (OS_MSG_EN > 0u)
    913                       p_tcb->MsgPtr     = (void      *)0;
    914                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
    915          #endif
    916                       p_tcb->TS         = ts;
    917                       if (p_obj != (OS_PEND_OBJ *)0) {
    918                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
    919                       }
    920                       OS_TaskRdy(p_tcb);
    921                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
    922                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
    923                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
    924                       break;
    925          
    926                  case OS_TASK_STATE_PEND_SUSPENDED:
    927                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    928                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
    929                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    930                                         p_tcb,
    931                                         ts);
    932                       }
    933          #if (OS_MSG_EN > 0u)
    934                       p_tcb->MsgPtr     = (void      *)0;
    935                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
    936          #endif
    937                       p_tcb->TS         = ts;
    938                       if (p_obj != (OS_PEND_OBJ *)0) {
    939                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
    940                       }
    941                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
    942                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
    943                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
    944                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
    945                       break;
    946          
    947                  default:
    948                       break;
    949              }
    950          }
    951          
    952          /*$PAGE*/
    953          /*
    954          ************************************************************************************************************************
    955          *                                           PEND ABORT A TASK PENDING ON MULTIPLE OBJECTS
    956          *
    957          * Description: This function is called when a task is pending on multiple objects and one of the objects has been pend
    958          *              aborted.  This function needs to indicate to the caller which object was pend aborted by placing the
    959          *              address of the object in the OS_PEND_DATA table corresponding to the pend aborted object.
    960          *
    961          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
    962          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries of the
    963          *              OS_TCB would be set to six (6) in this case.  As shown, when the pend call returns because a task pend
    964          *              aborted 'Obj C' then, only the one entry contains the .RdyObjPtr filled in data and the other entries
    965          *              contains NULL pointers and zero data.
    966          *
    967          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
    968          *
    969          *
    970          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
    971          *                                         +--------------+--------------+--------------+--------------+--------------+
    972          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
    973          *                                         +--------------+--------------+--------------+--------------+--------------+
    974          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
    975          *                                         +--------------+--------------+--------------+--------------+--------------+
    976          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
    977          *                                         +--------------+--------------+--------------+--------------+--------------+
    978          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
    979          *                                         +--------------+--------------+--------------+--------------+--------------+
    980          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
    981          *                                         +--------------+--------------+--------------+--------------+--------------+
    982          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
    983          *                                         +--------------+--------------+--------------+--------------+--------------+
    984          *
    985          *
    986          * Arguments  : p_obj        is a pointer to the object being pend aborted to
    987          *              -----
    988          *
    989          *              p_tcb        is a pointer to the OS_TCB of the task that we'll abort he pend for
    990          *              -----
    991          *
    992          *              ts           is the time stamp of when the pend abort occurred
    993          *
    994          * Returns    : none
    995          *
    996          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    997          ************************************************************************************************************************
    998          */
    999          
   1000          void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
   1001                               OS_TCB       *p_tcb,
   1002                               CPU_TS        ts)
   1003          {
   1004              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1005              OS_PEND_DATA   *p_pend_data;
   1006          
   1007          
   1008          
   1009              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   1010              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   1011          
   1012              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1013                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
   1014                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1015                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
   1016                      break;
   1017                  }
   1018                  p_pend_data++;
   1019                  n_pend_list--;
   1020              }
   1021          }
   1022          
   1023          /*$PAGE*/
   1024          /*
   1025          ************************************************************************************************************************
   1026          *                                              INITIALIZE A WAIT LIST TABLE
   1027          *
   1028          * Description: This function is called to initialize the fields of a table of OS_PEND_DATA entries.  It's assumed that
   1029          *              the .PendObjPtr field of each entry in the table is set by the caller and thus will NOT be touched by
   1030          *              this function.
   1031          *
   1032          * Arguments  : p_tcb              is a pointer to the TCB of the task that we want to pend abort.
   1033          *              -----
   1034          *
   1035          *              p_pend_data_tbl    is a pointer to a table (see below) of OS_PEND_DATA elements to initialize.
   1036          *              ---------------
   1037          *
   1038          *                                  .PendObjPtr .RdyObjPtr .RdyMsgPtr .RdyMsgSize .RdyTS .TCBPtr .NextPtr .PrevPtr
   1039          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    ^
   1040          *               p_pend_data_tbl-> |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1041          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1042          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1043          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1044          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1045          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+  size
   1046          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1047          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1048          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1049          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1050          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1051          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    V
   1052          *
   1053          *              tbl_size           is the size of the table in number of entries
   1054          *
   1055          * Returns    : none
   1056          *
   1057          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1058          *
   1059          *              2) It's possible for the table to be of size 1 when multi-pend is not used
   1060          *
   1061          *              3) Note that the .PendObjPtr is NOT touched because it's assumed to be set by the caller.
   1062          ************************************************************************************************************************
   1063          */
   1064          
   1065          void  OS_PendDataInit (OS_TCB        *p_tcb,
   1066                                 OS_PEND_DATA  *p_pend_data_tbl,
   1067                                 OS_OBJ_QTY     tbl_size)
   1068          {
   1069              OS_OBJ_QTY  i;
   1070          
   1071          
   1072          
   1073              p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
   1074              p_tcb->PendDataTblPtr     = p_pend_data_tbl;
   1075          
   1076              for (i = 0u; i < tbl_size; i++) {
   1077                  p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
   1078                  p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
   1079                  p_pend_data_tbl->RdyObjPtr  = (void         *)0;
   1080                  p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
   1081                  p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
   1082                  p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
   1083                  p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
   1084                  p_pend_data_tbl++;
   1085              }
   1086          }
   1087          
   1088          /*$PAGE*/
   1089          /*
   1090          ************************************************************************************************************************
   1091          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1092          *
   1093          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1094          *              using a kernel aware tool.
   1095          *
   1096          * Arguments  : p_obj              is a pointer to the object being pended on
   1097          *
   1098          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1099          *
   1100          * Returns    : none
   1101          *
   1102          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1103          ************************************************************************************************************************
   1104          */
   1105          
   1106          
   1107          #if OS_CFG_DBG_EN > 0u
   1108          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1109                                   OS_TCB       *p_tcb)
   1110          {
   1111              OS_PEND_LIST  *p_pend_list;
   1112              OS_PEND_DATA  *p_pend_data;
   1113              OS_TCB        *p_tcb1;
   1114          
   1115          
   1116              if (p_obj != (OS_PEND_OBJ *)0) {
   1117                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
   1118                  p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
   1119                  p_pend_data       =  p_pend_list->HeadPtr;
   1120                  p_tcb1            =  p_pend_data->TCBPtr;
   1121                  p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
   1122              } else {
   1123                  switch (p_tcb->PendOn) {
   1124                      case OS_TASK_PEND_ON_TASK_Q:
   1125                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   1126                           break;
   1127          
   1128                      case OS_TASK_PEND_ON_TASK_SEM:
   1129                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   1130                           break;
   1131          
   1132                      default:
   1133                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1134                           break;
   1135                  }
   1136              }
   1137          }
   1138          
   1139          
   1140          
   1141          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1142                                      OS_TCB       *p_tcb)
   1143          {
   1144              OS_PEND_LIST  *p_pend_list;
   1145              OS_PEND_DATA  *p_pend_data;
   1146              OS_TCB        *p_tcb1;
   1147          
   1148          
   1149              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
   1150              p_pend_list       = &p_obj->PendList;
   1151              p_pend_data       =  p_pend_list->HeadPtr;
   1152              if (p_pend_data  != (OS_PEND_DATA *)0) {
   1153                  p_tcb1            = p_pend_data->TCBPtr;
   1154                  p_obj->DbgNamePtr = p_tcb1->NamePtr;
   1155              } else {
   1156                  p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
   1157              }
   1158          }
   1159          #endif
   1160          
   1161          /*$PAGE*/
   1162          /*
   1163          ************************************************************************************************************************
   1164          *                               CHANGE THE PRIORITY OF A TASK WAITING IN ONE OR MORE PEND LISTS
   1165          *
   1166          * Description: This function is called to change the position of a task waiting in one or more pend lists.  Because a
   1167          *              task can be waiting on multiple objects then each pend list needs to be updated.  Specifically, the
   1168          *              task can be the highest priority task waiting on one pend list, the lowest priority task waiting in yet
   1169          *              another pend list or somewhere else in another pend list.  Because of this, we need to be able to change
   1170          *              each of those pend lists individually.
   1171          *
   1172          *              The drawing below shows an example of a task (OS_TCB) that belongs to 3 separate pend lists.  Each
   1173          *              pend list can contain multiple tasks (the .PrevPtr and .NextPtr show a '?' to indicate this).  The OS_TCB
   1174          *              contains a pointer (.PendDataTblPtr) to the first entry in the list of pend lists.
   1175          *
   1176          *                                                                                                          OS_TCB
   1177          *                                                                                                   +--------------------+
   1178          *                                                                                                   |                    |
   1179          *                                                                                                   +--------------------+
   1180          *                                                                                                   | PendDataTblEntries |
   1181          *                                      Point to first entry in the OS_PEND_DATA table (i.e. [0])    +--------------------+
   1182          *                                          /-----------------------------<------------------------- | PendDataTblPtr     |
   1183          *                                          |                                                        +--------------------+
   1184          *                                          |                                                                 ^
   1185          *              OS_PEND_LIST                |                                                                 |
   1186          *              +------------+              |                                                                 |
   1187          *              | TailPtr    |              |                                                                 |
   1188          *              +------------+              |                                                                 |
   1189          *              | HeadPtr    |              |                                                                 |
   1190          *              +------------+              |                                        /---------->-------------/
   1191          *              | NbrEntries |              |                                        |                        |
   1192          *              +------------+     [0]      V   OS_PEND_DATA                         |                        |
   1193          *                                     +---------+------------+-------+---------+--------+---------+          |
   1194          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1195          *                                     +---------+------------+-------+---------+--------+---------+          |
   1196          *                                                                                                            |
   1197          *                                                                                                            |
   1198          *                                                                                                            |
   1199          *                                                                                                            |
   1200          *                                                                                                            |
   1201          *              OS_PEND_LIST                                                                Point back to TCB |
   1202          *              +------------+                                                                                |
   1203          *              | TailPtr    |                                                                                |
   1204          *              +------------+                                                                                |
   1205          *              | HeadPtr    |                                                                                |
   1206          *              +------------+                                                      /----------->-------------/
   1207          *              | NbrEntries |                                                      |                         |
   1208          *              +------------+     [1]          OS_PEND_DATA                        |                         |
   1209          *                                     +---------+------------+-------+---------+--------+---------+          |
   1210          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1211          *                                     +---------+------------+-------+---------+--------+---------+          |
   1212          *                                                                                                            |
   1213          *                                                                                                            |
   1214          *                                                                                                            |
   1215          *                                                                                                            |
   1216          *                                                                                                            |
   1217          *              OS_PEND_LIST                                                                                  |
   1218          *              +------------+                                                                                |
   1219          *              | TailPtr    |                                                                                |
   1220          *              +------------+                                                                                |
   1221          *              | HeadPtr    |                                                                                |
   1222          *              +------------+                                                      /----------->-------------/
   1223          *              | NbrEntries |                                                      |
   1224          *              +------------+     [2]          OS_PEND_DATA                        |
   1225          *                                     +---------+------------+-------+---------+--------+---------+
   1226          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | ----> ?
   1227          *                                     +---------+------------+-------+---------+--------+---------+
   1228          *
   1229          *
   1230          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1231          *              -----
   1232          *
   1233          *              prio_new    is the new priority for the task
   1234          *
   1235          * Returns    : none
   1236          *
   1237          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1238          *
   1239          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1240          ************************************************************************************************************************
   1241          */
   1242          
   1243          void  OS_PendListChangePrio (OS_TCB  *p_tcb,
   1244                                       OS_PRIO  prio_new)
   1245          {
   1246              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1247              OS_PEND_DATA   *p_pend_data;
   1248              OS_PEND_LIST   *p_pend_list;
   1249              OS_PEND_OBJ    *p_obj;
   1250          
   1251          
   1252              p_tcb->Prio = prio_new;
   1253              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
   1254              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
   1255          
   1256              while (n_pend_list > 0u) {
   1257                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1258                  p_pend_list = &p_obj->PendList;
   1259                  if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
   1260                      OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
   1261                                         p_pend_data);
   1262                      OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
   1263                                            p_pend_data);
   1264                  }
   1265                  p_pend_data++;                                              /* Point to next wait list                        */
   1266                  n_pend_list--;
   1267              }
   1268          }
   1269          
   1270          /*$PAGE*/
   1271          /*
   1272          ************************************************************************************************************************
   1273          *                                                INITIALIZE A WAIT LIST
   1274          *
   1275          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1276          *
   1277          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1278          *              -----------
   1279          *
   1280          * Returns    : none
   1281          *
   1282          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1283          ************************************************************************************************************************
   1284          */
   1285          
   1286          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   1287          {
   1288              p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
   1289              p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
   1290              p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
   1291          }
   1292          
   1293          /*$PAGE*/
   1294          /*
   1295          ************************************************************************************************************************
   1296          *                                     INSERT PEND DATA AT THE BEGINNING OF A WAIT LIST
   1297          *
   1298          * Description: This function is called to place an OS_PEND_DATA entry at the beginning of a linked list as follows:
   1299          *
   1300          *              CASE 0: Insert in an empty list.
   1301          *
   1302          *                     OS_PEND_LIST
   1303          *                     +--------------+
   1304          *                     | TailPtr      |-> 0
   1305          *                     +--------------+
   1306          *                     | HeadPtr      |-> 0
   1307          *                     +--------------+
   1308          *                     | NbrEntries=0 |
   1309          *                     +--------------+
   1310          *
   1311          *
   1312          *
   1313          *              CASE 1: Insert BEFORE the current head of list
   1314          *
   1315          *                     OS_PEND_LIST
   1316          *                     +--------------+         OS_PEND_DATA
   1317          *                     | TailPtr      |--+---> +------------+
   1318          *                     +--------------+  |     | NextPtr    |->0
   1319          *                     | HeadPtr      |--/     +------------+
   1320          *                     +--------------+     0<-| PrevPtr    |
   1321          *                     | NbrEntries=1 |        +------------+
   1322          *                     +--------------+        |            |
   1323          *                                             +------------+
   1324          *                                             |            |
   1325          *                                             +------------+
   1326          *
   1327          *
   1328          * Arguments  : p_pend_list    is a pointer to a wait list found inside an object.  The OS_PEND_DATA entry will be
   1329          *              -----------    inserted at the head of the list.
   1330          *
   1331          *              p_pend_data    is a pointer to the OS_PEND_DATA entry to add to the list
   1332          *              -----------
   1333          *
   1334          * Returns    : none
   1335          *
   1336          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1337          ************************************************************************************************************************
   1338          */
   1339          
   1340          void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
   1341                                       OS_PEND_DATA  *p_pend_data)
   1342          {
   1343              OS_PEND_DATA  *p_pend_data_next;
   1344          
   1345          
   1346          
   1347              p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
   1348              p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
   1349              p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
   1350              p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
   1351              if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
   1352                  p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
   1353              }
   1354              p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
   1355              if (p_pend_list->NbrEntries == 1u) {
   1356                  p_pend_list->TailPtr = p_pend_data;
   1357              }
   1358          }
   1359          
   1360          /*$PAGE*/
   1361          /*
   1362          ************************************************************************************************************************
   1363          *                                   INSERT PEND DATA BASED ON IT'S PRIORITY IN A LIST
   1364          *
   1365          * Description: This function is called to place an OS_PEND_DATA entry in a linked list based on its priority.  The
   1366          *              highest priority being placed at the head of the list.  It's assumed that the OS_PEND_DATA entry to
   1367          *              insert points to the TCB of the task being inserted.  The TCB is also assumed to contain the priority
   1368          *              of the task in its .Prio field.
   1369          *
   1370          *              CASE 0: Insert in an empty list.
   1371          *
   1372          *                     OS_PEND_LIST
   1373          *                     +---------------+
   1374          *                     | TailPtr       |-> 0
   1375          *                     +---------------+
   1376          *                     | HeadPtr       |-> 0
   1377          *                     +---------------+
   1378          *                     | NbrEntries=0  |
   1379          *                     +---------------+
   1380          *
   1381          *
   1382          *
   1383          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1384          *
   1385          *                     OS_PEND_LIST
   1386          *                     +--------------+         OS_PEND_DATA
   1387          *                     | TailPtr      |--+---> +------------+
   1388          *                     +--------------+  |     | NextPtr    |->0
   1389          *                     | HeadPtr      |--/     +------------+
   1390          *                     +--------------+     0<-| PrevPtr    |
   1391          *                     | NbrEntries=1 |        +------------+
   1392          *                     +--------------+        |            |
   1393          *                                             +------------+
   1394          *                                             |            |
   1395          *                                             +------------+
   1396          *
   1397          *
   1398          *                     OS_PEND_LIST
   1399          *                     +--------------+
   1400          *                     | TailPtr      |-----------------------------------------------+
   1401          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1402          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1403          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1404          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1405          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1406          *                                             +------------+       +------------+        +------------+
   1407          *                                             |            |       |            |        |            |
   1408          *                                             +------------+       +------------+        +------------+
   1409          *                                             |            |       |            |        |            |
   1410          *                                             +------------+       +------------+        +------------+
   1411          *
   1412          *
   1413          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_PEND_DATA entry will be inserted
   1414          *              -----------
   1415          *
   1416          *              p_pend_data    is the OS_PEND_DATA to insert in the list
   1417          *              -----------
   1418          *
   1419          * Returns    : none
   1420          *
   1421          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1422          *
   1423          *              2) 'p_pend_data->TCBPtr->Prio' contains the priority of the TCB associated with the entry to insert.
   1424          *                 We can compare this priority with the priority of other entries in the list.
   1425          ************************************************************************************************************************
   1426          */
   1427          
   1428          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   1429                                       OS_PEND_DATA  *p_pend_data)
   1430          {
   1431              OS_PRIO        prio;
   1432              OS_TCB        *p_tcb;
   1433              OS_TCB        *p_tcb_next;
   1434              OS_PEND_DATA  *p_pend_data_prev;
   1435              OS_PEND_DATA  *p_pend_data_next;
   1436          
   1437          
   1438          
   1439              p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
   1440              prio  = p_tcb->Prio;
   1441              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
   1442                  p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
   1443                  p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
   1444                  p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
   1445                  p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
   1446                  p_pend_list->TailPtr    = p_pend_data;
   1447              } else {
   1448                  p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
   1449                  p_pend_data_next = p_pend_list->HeadPtr;
   1450                  while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
   1451                      p_tcb_next   = p_pend_data_next->TCBPtr;
   1452                      if (prio < p_tcb_next->Prio) {
   1453                          break;                                                /*         Found! ... insert BEFORE current     */
   1454                      } else {
   1455                          p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
   1456                      }
   1457                  }
   1458                  if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
   1459                      p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
   1460                      p_pend_data_prev          = p_pend_list->TailPtr;
   1461                      p_pend_data->PrevPtr      = p_pend_data_prev;
   1462                      p_pend_data_prev->NextPtr = p_pend_data;
   1463                      p_pend_list->TailPtr      = p_pend_data;
   1464                  } else {
   1465                      if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
   1466                          p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
   1467                          p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
   1468                          p_pend_data->NextPtr       = p_pend_data_next;
   1469                          p_pend_list->HeadPtr       = p_pend_data;
   1470                      } else {
   1471                          p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
   1472                          p_pend_data->PrevPtr       = p_pend_data_prev;
   1473                          p_pend_data->NextPtr       = p_pend_data_next;
   1474                          p_pend_data_prev->NextPtr  = p_pend_data;
   1475                          p_pend_data_next->PrevPtr  = p_pend_data;
   1476                      }
   1477                  }
   1478              }
   1479          }
   1480          
   1481          /*$PAGE*/
   1482          /*
   1483          ************************************************************************************************************************
   1484          *                           REMOVE TASK FROM PEND LIST(s) KNOWING ONLY WHICH TCB TO REMOVE
   1485          *
   1486          * Description: This function is called to remove a task from a pend list knowing only the TCB of the task to remove
   1487          *
   1488          *
   1489          *              CASE 0: OS_PEND_DATA list is empty, nothing to do.
   1490          *
   1491          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1492          *
   1493          *                     OS_PEND_LIST
   1494          *                     +--------------+         OS_PEND_DATA
   1495          *                     | TailPtr      |--+---> +------------+
   1496          *                     +--------------+  |     | NextPtr    |->0
   1497          *                     | HeadPtr      |--/     +------------+
   1498          *                     +--------------+     0<-| PrevPtr    |
   1499          *                     | NbrEntries=1 |        +------------+
   1500          *                     +--------------+        |            |
   1501          *                                             +------------+
   1502          *                                             |            |
   1503          *                                             +------------+
   1504          *
   1505          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1506          *
   1507          *                     OS_PEND_LIST
   1508          *                     +--------------+
   1509          *                     | TailPtr      |-----------------------------------------------+
   1510          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1511          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1512          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1513          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1514          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1515          *                                             +------------+       +------------+        +------------+
   1516          *                                             |            |       |            |        |            |
   1517          *                                             +------------+       +------------+        +------------+
   1518          *                                             |            |       |            |        |            |
   1519          *                                             +------------+       +------------+        +------------+
   1520          *
   1521          *
   1522          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from all pend lists
   1523          *              -----
   1524          *
   1525          * Returns    : none
   1526          *
   1527          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1528          ************************************************************************************************************************
   1529          */
   1530          
   1531          void  OS_PendListRemove (OS_TCB  *p_tcb)
   1532          {
   1533              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1534              OS_PEND_DATA   *p_pend_data;
   1535              OS_PEND_LIST   *p_pend_list;
   1536              OS_PEND_OBJ    *p_obj;
   1537          
   1538          
   1539          
   1540              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   1541              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   1542          
   1543              while (n_pend_list > (OS_OBJ_QTY)0) {
   1544                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1545                  p_pend_list = &p_obj->PendList;
   1546                  OS_PendListRemove1(p_pend_list,
   1547                                     p_pend_data);
   1548                  p_pend_data++;
   1549                  n_pend_list--;
   1550              }
   1551              p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
   1552              p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
   1553          }
   1554          
   1555          /*$PAGE*/
   1556          /*
   1557          ************************************************************************************************************************
   1558          *                               REMOVE AN 'OS_PEND_DATA' ENTRY from a 'OS_PEND_LIST'
   1559          *
   1560          * Description: This function is called to remove a task from a wait list knowing only the TCB of the task to remove
   1561          *
   1562          *
   1563          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1564          *
   1565          *                     OS_PEND_LIST
   1566          *                     +--------------+         OS_PEND_DATA
   1567          *                     | TailPtr      |--+---> +------------+
   1568          *                     +--------------+  |     | NextPtr    |->0
   1569          *                     | HeadPtr      |--/      +------------+
   1570          *                     +--------------+     0<-| PrevPtr    |
   1571          *                     | NbrEntries=1 |        +------------+
   1572          *                     +--------------+        |            |
   1573          *                                             +------------+
   1574          *                                             |            |
   1575          *                                             +------------+
   1576          *
   1577          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1578          *
   1579          *                     OS_PEND_LIST
   1580          *                     +--------------+
   1581          *                     | TailPtr      |-----------------------------------------------+
   1582          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1583          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1584          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1585          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1586          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1587          *                                             +------------+       +------------+        +------------+
   1588          *                                             |            |       |            |        |            |
   1589          *                                             +------------+       +------------+        +------------+
   1590          *                                             |            |       |            |        |            |
   1591          *                                             +------------+       +------------+        +------------+
   1592          *
   1593          *
   1594          * Arguments  : p_pend_list     is a pointer to the pend list where 'p_pend_data' will be removed from
   1595          *              -----------
   1596          *
   1597          *              p_pend_data     is a pointer to the OS_PEND_DATA to remove from the pend list
   1598          *              -----------
   1599          *
   1600          * Returns    : none
   1601          *
   1602          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1603          ************************************************************************************************************************
   1604          */
   1605          
   1606          void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
   1607                                    OS_PEND_DATA  *p_pend_data)
   1608          {
   1609              OS_PEND_DATA  *p_prev;
   1610              OS_PEND_DATA  *p_next;
   1611          
   1612          
   1613          
   1614              if (p_pend_list->NbrEntries == 1u) {
   1615                  p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
   1616                  p_pend_list->TailPtr = (OS_PEND_DATA *)0;
   1617          
   1618              } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
   1619                  p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
   1620                  p_next->PrevPtr      = (OS_PEND_DATA *)0;
   1621                  p_pend_list->HeadPtr = p_next;
   1622          
   1623              } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
   1624                  p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
   1625                  p_prev->NextPtr      = (OS_PEND_DATA *)0;
   1626                  p_pend_list->TailPtr = p_prev;
   1627          
   1628              } else {
   1629                  p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
   1630                  p_next               = p_pend_data->NextPtr;
   1631                  p_prev->NextPtr      = p_next;
   1632                  p_next->PrevPtr      = p_prev;
   1633              }
   1634              p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
   1635              p_pend_data->NextPtr = (OS_PEND_DATA *)0;
   1636              p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
   1637          }
   1638          
   1639          /*$PAGE*/
   1640          /*
   1641          ************************************************************************************************************************
   1642          *                                READY A TASK THAT WAS PENDING ON AN OBJECT BEING DELETED
   1643          *
   1644          * Description: This function is called when a object is to make a task ready-to-run.
   1645          *
   1646          * Arguments  : p_obj          is a pointer to the object being deleted
   1647          *              -----
   1648          *
   1649          *              p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   1650          *              -----
   1651          *
   1652          *              ts             is a timestamp to indicate when the object was deleted
   1653          *
   1654          * Returns    : none
   1655          *
   1656          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1657          ************************************************************************************************************************
   1658          */
   1659          
   1660          void   OS_PendObjDel (OS_PEND_OBJ *p_obj,
   1661                                OS_TCB      *p_tcb,
   1662                                CPU_TS       ts)
   1663          {
   1664              switch (p_tcb->TaskState) {
   1665                  case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
   1666                  case OS_TASK_STATE_DLY:
   1667                  case OS_TASK_STATE_SUSPENDED:
   1668                  case OS_TASK_STATE_DLY_SUSPENDED:
   1669                       break;
   1670          
   1671                  case OS_TASK_STATE_PEND:
   1672                  case OS_TASK_STATE_PEND_TIMEOUT:
   1673                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1674                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1675                                          p_tcb,
   1676                                          ts);
   1677                       }
   1678          #if (OS_MSG_EN > 0u)
   1679                       p_tcb->MsgPtr     = (void *)0;
   1680                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   1681          #endif
   1682                       p_tcb->TS         = ts;
   1683                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   1684                       OS_TaskRdy(p_tcb);
   1685                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
   1686                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
   1687                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
   1688                       break;
   1689          
   1690                  case OS_TASK_STATE_PEND_SUSPENDED:
   1691                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1692                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1693                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1694                                          p_tcb,
   1695                                          ts);
   1696                       }
   1697          #if (OS_MSG_EN > 0u)
   1698                       p_tcb->MsgPtr     = (void      *)0;
   1699                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   1700          #endif
   1701                       p_tcb->TS         = ts;
   1702                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   1703                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   1704                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
   1705                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
   1706                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   1707                       break;
   1708          
   1709                  default:
   1710                       break;
   1711              }
   1712          }
   1713          
   1714          /*$PAGE*/
   1715          /*
   1716          ************************************************************************************************************************
   1717          *                                    DELETE AN OBJECT FROM A TASK PENDING ON MULTIPLE OBJECTS
   1718          *
   1719          * Description: This function is called when a task is pending on multiple objects and the object is being deleted.
   1720          *              This function needs to indicate to the caller which object was deleted by placing the address of the
   1721          *              object in the OS_PEND_DATA table corresponding to the deleted object.
   1722          *
   1723          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1724          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1725          *              set to six (6) in this case.  As shown, when the pend call returns because a task deleted 'Obj C' then,
   1726          *              only the one entry contains the filled in data and the other entries contains NULL pointers and zero
   1727          *              data.
   1728          *
   1729          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1730          *
   1731          *
   1732          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1733          *                                         +--------------+--------------+--------------+--------------+--------------+
   1734          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1735          *                                         +--------------+--------------+--------------+--------------+--------------+
   1736          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1737          *                                         +--------------+--------------+--------------+--------------+--------------+
   1738          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1739          *                                         +--------------+--------------+--------------+--------------+--------------+
   1740          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1741          *                                         +--------------+--------------+--------------+--------------+--------------+
   1742          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1743          *                                         +--------------+--------------+--------------+--------------+--------------+
   1744          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1745          *                                         +--------------+--------------+--------------+--------------+--------------+
   1746          *
   1747          *
   1748          * Arguments  : p_obj        is a pointer to the object being deleted
   1749          *              -----
   1750          *
   1751          *              p_tcb        is the OS_TCB of the task pending on the object being deleted
   1752          *              -----
   1753          *
   1754          *              ts           is the time stamp of when the object was deleted
   1755          *
   1756          * Returns    : none
   1757          *
   1758          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1759          ************************************************************************************************************************
   1760          */
   1761          
   1762          void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
   1763                                OS_TCB       *p_tcb,
   1764                                CPU_TS        ts)
   1765          {
   1766              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1767              OS_PEND_DATA   *p_pend_data;
   1768          
   1769          
   1770          
   1771              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   1772              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   1773          
   1774              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1775                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
   1776                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1777                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
   1778                      break;
   1779                  }
   1780                  p_pend_data++;
   1781                  n_pend_list--;
   1782              }
   1783          }
   1784          
   1785          /*$PAGE*/
   1786          /*
   1787          ************************************************************************************************************************
   1788          *                                                   POST TO A TASK
   1789          *
   1790          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1791          *              OSxxxPost() services.
   1792          *
   1793          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1794          *              -----
   1795          *
   1796          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1797          *              -----
   1798          *
   1799          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1800          *
   1801          *              msg_size       If we are posting a message to a task, this is the size of the message
   1802          *
   1803          *              ts             The timestamp as to when the post occurred
   1804          *
   1805          * Returns    : none
   1806          *
   1807          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1808          ************************************************************************************************************************
   1809          */
   1810          
   1811          void   OS_Post (OS_PEND_OBJ  *p_obj,
   1812                          OS_TCB       *p_tcb,
   1813                          void         *p_void,
   1814                          OS_MSG_SIZE   msg_size,
   1815                          CPU_TS        ts)
   1816          {
   1817              switch (p_tcb->TaskState) {
   1818                  case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
   1819                  case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
   1820                  case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
   1821                  case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
   1822                       break;
   1823          
   1824                  case OS_TASK_STATE_PEND:
   1825                  case OS_TASK_STATE_PEND_TIMEOUT:
   1826                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1827                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1828                                    p_tcb,
   1829                                    p_void,
   1830                                    msg_size,
   1831                                    ts);
   1832                       } else {
   1833          #if (OS_MSG_EN > 0u)
   1834                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   1835                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   1836          #endif
   1837                           p_tcb->TS      = ts;
   1838                       }
   1839                       if (p_obj != (OS_PEND_OBJ *)0) {
   1840                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   1841          #if OS_CFG_DBG_EN > 0u
   1842                           OS_PendDbgNameRemove(p_obj,
   1843                                                p_tcb);
   1844          #endif
   1845                       }
   1846                       OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
   1847                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   1848                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   1849                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   1850                       break;
   1851          
   1852                  case OS_TASK_STATE_PEND_SUSPENDED:
   1853                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1854                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1855                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1856                                    p_tcb,
   1857                                    p_void,
   1858                                    msg_size,
   1859                                    ts);
   1860                       } else {
   1861          #if (OS_MSG_EN > 0u)
   1862                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   1863                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   1864          #endif
   1865                           p_tcb->TS      = ts;
   1866                       }
   1867                       OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
   1868                       if (p_obj != (OS_PEND_OBJ *)0) {
   1869                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   1870          #if OS_CFG_DBG_EN > 0u
   1871                           OS_PendDbgNameRemove(p_obj,
   1872                                                p_tcb);
   1873          #endif
   1874                       }
   1875                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   1876                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   1877                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   1878                       break;
   1879          
   1880                  default:
   1881                       break;
   1882              }
   1883          }
   1884          
   1885          /*$PAGE*/
   1886          /*
   1887          ************************************************************************************************************************
   1888          *                                           POST TO A TASK PENDING ON MULTIPLE OBJECTS
   1889          *
   1890          * Description: This function is called when a task is pending on multiple objects and the object has been posted to.
   1891          *              This function needs to indicate to the caller which object was posted to by placing the address of the
   1892          *              object in the OS_PEND_DATA table corresponding to the posted object.
   1893          *
   1894          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1895          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1896          *              set to six (6) in this case.  As shown, when the pend call returns because a task or an ISR posted to
   1897          *              'Obj C' then, only the one entry contains the filled in data and the other entries contains NULL pointers
   1898          *              and zero data.
   1899          *
   1900          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1901          *
   1902          *
   1903          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1904          *                                         +--------------+--------------+--------------+--------------+--------------+
   1905          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1906          *                                         +--------------+--------------+--------------+--------------+--------------+
   1907          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1908          *                                         +--------------+--------------+--------------+--------------+--------------+
   1909          *                                         |  Obj C       |  Obj C       | Msg Ptr      | Msg Size     | TS           |
   1910          *                                         +--------------+--------------+--------------+--------------+--------------+
   1911          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1912          *                                         +--------------+--------------+--------------+--------------+--------------+
   1913          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1914          *                                         +--------------+--------------+--------------+--------------+--------------+
   1915          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1916          *                                         +--------------+--------------+--------------+--------------+--------------+
   1917          *
   1918          *
   1919          * Arguments  : p_obj        is a pointer to the object being posted to
   1920          *              -----
   1921          *
   1922          *              p_tcb        is the OS_TCB of the task receiving the signal or the message
   1923          *              -----
   1924          *
   1925          *              p_void       is the actual message (assuming posting to a message queue).  A NULL pointer otherwise.
   1926          *
   1927          *              msg_size     is the size of the message sent (if posted to a message queue)
   1928          *
   1929          *              ts           is the time stamp of when the post occurred
   1930          *
   1931          * Returns    : none
   1932          *
   1933          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1934          ************************************************************************************************************************
   1935          */
   1936          
   1937          void  OS_Post1 (OS_PEND_OBJ  *p_obj,
   1938                          OS_TCB       *p_tcb,
   1939                          void         *p_void,
   1940                          OS_MSG_SIZE   msg_size,
   1941                          CPU_TS        ts)
   1942          {
   1943              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1944              OS_PEND_DATA   *p_pend_data;
   1945          
   1946          
   1947          
   1948              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   1949              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   1950          
   1951              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1952                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
   1953                      p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
   1954                      p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
   1955                      p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
   1956                      p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
   1957                      break;
   1958                  }
   1959                  p_pend_data++;
   1960                  n_pend_list--;
   1961              }
   1962          }
   1963          
   1964          /*$PAGE*/
   1965          /*
   1966          ************************************************************************************************************************
   1967          *                                                    INITIALIZATION
   1968          *                                               READY LIST INITIALIZATION
   1969          *
   1970          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   1971          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   1972          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   1973          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   1974          *
   1975          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   1976          *              to.
   1977          *
   1978          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   1979          *
   1980          *                               +---------------+--------------+
   1981          *                               |               | TailPtr      |-----> 0
   1982          *                          [0]  | NbrEntries=0  +--------------+
   1983          *                               |               | HeadPtr      |-----> 0
   1984          *                               +---------------+--------------+
   1985          *                               |               | TailPtr      |-----> 0
   1986          *                          [1]  | NbrEntries=0  +--------------+
   1987          *                               |               | HeadPtr      |-----> 0
   1988          *                               +---------------+--------------+
   1989          *                                       :              :
   1990          *                                       :              :
   1991          *                                       :              :
   1992          *                               +---------------+--------------+
   1993          *                               |               | TailPtr      |-----> 0
   1994          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   1995          *                               |               | HeadPtr      |-----> 0
   1996          *                               +---------------+--------------+
   1997          *
   1998          *
   1999          * Arguments  : none
   2000          *
   2001          * Returns    : none
   2002          *
   2003          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2004          ************************************************************************************************************************
   2005          */
   2006          
   2007          void  OS_RdyListInit (void)
   2008          {
   2009              OS_PRIO       i;
   2010              OS_RDY_LIST  *p_rdy_list;
   2011          
   2012          
   2013          
   2014              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
   2015                  p_rdy_list = &OSRdyList[i];
   2016                  p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
   2017                  p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   2018                  p_rdy_list->TailPtr    = (OS_TCB   *)0;
   2019              }
   2020          }
   2021          
   2022          /*$PAGE*/
   2023          /*
   2024          ************************************************************************************************************************
   2025          *                                             INSERT TCB IN THE READY LIST
   2026          *
   2027          * Description: This function is called to insert a TCB in the ready list.
   2028          *
   2029          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   2030          *              current task.  The TCB is inserted at the head of the list if not.
   2031          *
   2032          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   2033          *              -----
   2034          *
   2035          * Returns    : none
   2036          *
   2037          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2038          ************************************************************************************************************************
   2039          */
   2040          
   2041          void  OS_RdyListInsert (OS_TCB *p_tcb)
   2042          {
   2043              OS_PrioInsert(p_tcb->Prio);
   2044              if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
   2045                  OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
   2046              } else {
   2047                  OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
   2048              }
   2049          }
   2050          
   2051          
   2052          /*
   2053          ************************************************************************************************************************
   2054          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   2055          *
   2056          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   2057          *
   2058          *              CASE 0: Insert in an empty list.
   2059          *
   2060          *                     OS_RDY_LIST
   2061          *                     +--------------+
   2062          *                     | TailPtr      |-> 0
   2063          *                     +--------------+
   2064          *                     | HeadPtr      |-> 0
   2065          *                     +--------------+
   2066          *                     | NbrEntries=0 |
   2067          *                     +--------------+
   2068          *
   2069          *
   2070          *
   2071          *              CASE 1: Insert BEFORE the current head of list
   2072          *
   2073          *                     OS_RDY_LIST
   2074          *                     +--------------+          OS_TCB
   2075          *                     | TailPtr      |--+---> +------------+
   2076          *                     +--------------+  |     | NextPtr    |->0
   2077          *                     | HeadPtr      |--/     +------------+
   2078          *                     +--------------+     0<-| PrevPtr    |
   2079          *                     | NbrEntries=1 |        +------------+
   2080          *                     +--------------+        :            :
   2081          *                                             :            :
   2082          *                                             +------------+
   2083          *
   2084          *
   2085          *                     OS_RDY_LIST
   2086          *                     +--------------+
   2087          *                     | TailPtr      |-----------------------------------------------+
   2088          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2089          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2090          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2091          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2092          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2093          *                                             +------------+       +------------+        +------------+
   2094          *                                             :            :       :            :        :            :
   2095          *                                             :            :       :            :        :            :
   2096          *                                             +------------+       +------------+        +------------+
   2097          *
   2098          *
   2099          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2100          *              -----
   2101          *
   2102          * Returns    : none
   2103          *
   2104          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2105          ************************************************************************************************************************
   2106          */
   2107          
   2108          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   2109          {
   2110              OS_RDY_LIST  *p_rdy_list;
   2111              OS_TCB       *p_tcb2;
   2112          
   2113          
   2114          
   2115              p_rdy_list = &OSRdyList[p_tcb->Prio];
   2116              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   2117                  p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   2118                  p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   2119                  p_tcb->PrevPtr         =  (OS_TCB   *)0;
   2120                  p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   2121                  p_rdy_list->TailPtr    =  p_tcb;
   2122              } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
   2123                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   2124                  p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
   2125                  p_tcb->PrevPtr         = (OS_TCB    *)0;
   2126                  p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
   2127                  p_tcb2->PrevPtr        = p_tcb;
   2128                  p_rdy_list->HeadPtr    = p_tcb;
   2129              }
   2130          }
   2131          
   2132          /*$PAGE*/
   2133          /*
   2134          ************************************************************************************************************************
   2135          *                                           INSERT TCB AT THE END OF A LIST
   2136          *
   2137          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   2138          *
   2139          *              CASE 0: Insert in an empty list.
   2140          *
   2141          *                     OS_RDY_LIST
   2142          *                     +--------------+
   2143          *                     | TailPtr      |-> 0
   2144          *                     +--------------+
   2145          *                     | HeadPtr      |-> 0
   2146          *                     +--------------+
   2147          *                     | NbrEntries=0 |
   2148          *                     +--------------+
   2149          *
   2150          *
   2151          *
   2152          *              CASE 1: Insert AFTER the current tail of list
   2153          *
   2154          *                     OS_RDY_LIST
   2155          *                     +--------------+          OS_TCB
   2156          *                     | TailPtr      |--+---> +------------+
   2157          *                     +--------------+  |     | NextPtr    |->0
   2158          *                     | HeadPtr      |--/     +------------+
   2159          *                     +--------------+     0<-| PrevPtr    |
   2160          *                     | NbrEntries=1 |        +------------+
   2161          *                     +--------------+        :            :
   2162          *                                             :            :
   2163          *                                             +------------+
   2164          *
   2165          *
   2166          *                     OS_RDY_LIST
   2167          *                     +--------------+
   2168          *                     | TailPtr      |-----------------------------------------------+
   2169          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2170          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2171          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2172          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2173          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2174          *                                             +------------+       +------------+        +------------+
   2175          *                                             :            :       :            :        :            :
   2176          *                                             :            :       :            :        :            :
   2177          *                                             +------------+       +------------+        +------------+
   2178          *
   2179          *
   2180          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2181          *              -----
   2182          *
   2183          * Returns    : none
   2184          *
   2185          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2186          ************************************************************************************************************************
   2187          */
   2188          
   2189          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   2190          {
   2191              OS_RDY_LIST  *p_rdy_list;
   2192              OS_TCB       *p_tcb2;
   2193          
   2194          
   2195          
   2196              p_rdy_list = &OSRdyList[p_tcb->Prio];
   2197              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   2198                  p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   2199                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   2200                  p_tcb->PrevPtr          = (OS_TCB   *)0;
   2201                  p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   2202                  p_rdy_list->TailPtr     = p_tcb;
   2203              } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
   2204                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   2205                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
   2206                  p_tcb2                  = p_rdy_list->TailPtr;
   2207                  p_tcb->PrevPtr          = p_tcb2;
   2208                  p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
   2209                  p_rdy_list->TailPtr     = p_tcb;
   2210              }
   2211          }
   2212          
   2213          /*$PAGE*/
   2214          /*
   2215          ************************************************************************************************************************
   2216          *                                                MOVE TCB AT HEAD TO TAIL
   2217          *
   2218          * Description: This function is called to move the current head of a list to the tail of the list.
   2219          *
   2220          *
   2221          *              CASE 0: TCB list is empty, nothing to do.
   2222          *
   2223          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   2224          *
   2225          *              CASE 2: Only 2 OS_TCBs in the list.
   2226          *
   2227          *                     OS_RDY_LIST
   2228          *                     +--------------+
   2229          *                     | TailPtr      |--------------------------+
   2230          *                     +--------------+          OS_TCB          |     OS_TCB
   2231          *                     | HeadPtr      |------> +------------+    +-> +------------+
   2232          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   2233          *                     | NbrEntries=2 |        +------------+        +------------+
   2234          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   2235          *                                             +------------+        +------------+
   2236          *                                             :            :        :            :
   2237          *                                             :            :        :            :
   2238          *                                             +------------+        +------------+
   2239          *
   2240          *
   2241          *              CASE N: More than 2 OS_TCBs in the list.
   2242          *
   2243          *                     OS_RDY_LIST
   2244          *                     +--------------+
   2245          *                     | TailPtr      |-----------------------------------------------+
   2246          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2247          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2248          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2249          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2250          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2251          *                                             +------------+       +------------+        +------------+
   2252          *                                             :            :       :            :        :            :
   2253          *                                             :            :       :            :        :            :
   2254          *                                             +------------+       +------------+        +------------+
   2255          *
   2256          *
   2257          * Arguments  : p_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   2258          *              ------
   2259          *
   2260          * Returns    : none
   2261          *
   2262          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2263          ************************************************************************************************************************
   2264          */
   2265          
   2266          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   2267          {
   2268              OS_TCB  *p_tcb1;
   2269              OS_TCB  *p_tcb2;
   2270              OS_TCB  *p_tcb3;
   2271          
   2272          
   2273          
   2274              switch (p_rdy_list->NbrEntries) {
   2275                  case 0:
   2276                  case 1:
   2277                       break;
   2278          
   2279                  case 2:                                             /* SWAP the TCBs                                          */
   2280                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   2281                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   2282                       p_tcb1->PrevPtr     = p_tcb2;
   2283                       p_tcb1->NextPtr     = (OS_TCB *)0;
   2284                       p_tcb2->PrevPtr     = (OS_TCB *)0;
   2285                       p_tcb2->NextPtr     = p_tcb1;
   2286                       p_rdy_list->HeadPtr = p_tcb2;
   2287                       p_rdy_list->TailPtr = p_tcb1;
   2288                       break;
   2289          
   2290                  default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
   2291                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   2292                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   2293                       p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
   2294                       p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
   2295                       p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
   2296                       p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
   2297                       p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
   2298                       p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
   2299                       p_rdy_list->TailPtr = p_tcb1;
   2300                       break;
   2301              }
   2302          }
   2303          
   2304          /*$PAGE*/
   2305          /*
   2306          ************************************************************************************************************************
   2307          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   2308          *
   2309          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   2310          *              remove.
   2311          *
   2312          *
   2313          *              CASE 0: TCB list is empty, nothing to do.
   2314          *
   2315          *              CASE 1: Only 1 OS_TCBs in the list.
   2316          *
   2317          *                     OS_RDY_LIST
   2318          *                     +--------------+          OS_TCB
   2319          *                     | TailPtr      |--+---> +------------+
   2320          *                     +--------------+  |     | NextPtr    |->0
   2321          *                     | HeadPtr      |--/     +------------+
   2322          *                     +--------------+     0<-| PrevPtr    |
   2323          *                     | NbrEntries=1 |        +------------+
   2324          *                     +--------------+        :            :
   2325          *                                             :            :
   2326          *                                             +------------+
   2327          *
   2328          *              CASE N: Two or more OS_TCBs in the list.
   2329          *
   2330          *                     OS_RDY_LIST
   2331          *                     +--------------+
   2332          *                     | TailPtr      |-----------------------------------------------+
   2333          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2334          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2335          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2336          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2337          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2338          *                                             +------------+       +------------+        +------------+
   2339          *                                             :            :       :            :        :            :
   2340          *                                             :            :       :            :        :            :
   2341          *                                             +------------+       +------------+        +------------+
   2342          *
   2343          *
   2344          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   2345          *              -----
   2346          *
   2347          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   2348          *
   2349          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2350          ************************************************************************************************************************
   2351          */
   2352          
   2353          void  OS_RdyListRemove (OS_TCB *p_tcb)
   2354          {
   2355              OS_RDY_LIST  *p_rdy_list;
   2356              OS_TCB       *p_tcb1;
   2357              OS_TCB       *p_tcb2;
   2358          
   2359          
   2360          
   2361              p_rdy_list = &OSRdyList[p_tcb->Prio];
   2362              p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
   2363              p_tcb2     = p_tcb->NextPtr;
   2364              if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
   2365                  if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
   2366                      p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
   2367                      p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   2368                      p_rdy_list->TailPtr    = (OS_TCB   *)0;
   2369                      OS_PrioRemove(p_tcb->Prio);
   2370                  } else {
   2371                      p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
   2372                      p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
   2373                      p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
   2374                  }
   2375              } else {
   2376                  p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
   2377                  p_tcb1->NextPtr = p_tcb2;
   2378                  if (p_tcb2 == (OS_TCB *)0) {
   2379                      p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
   2380                  } else {
   2381                      p_tcb2->PrevPtr     = p_tcb1;
   2382                  }
   2383              }
   2384              p_tcb->PrevPtr = (OS_TCB *)0;
   2385              p_tcb->NextPtr = (OS_TCB *)0;
   2386          }
   2387          
   2388          /*$PAGE*/
   2389          /*
   2390          ************************************************************************************************************************
   2391          *                                             SCHEDULE THE ISR HANDLER TASK
   2392          *
   2393          * Description: This function is called by other uC/OS-III services to schedule task at priority 0 which is always the
   2394          *              ISR handler task.
   2395          *
   2396          * Arguments  : none
   2397          *
   2398          * Returns    : none
   2399          *
   2400          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2401          ************************************************************************************************************************
   2402          */
   2403          
   2404          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   2405          void  OS_Sched0 (void)
   2406          {
   2407              CPU_SR_ALLOC();
   2408          
   2409          
   2410          
   2411              CPU_INT_DIS();
   2412              OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
   2413              OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
   2414          #if OS_CFG_TASK_PROFILE_EN > 0u
   2415              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   2416          #endif
   2417              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   2418              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   2419              CPU_INT_EN();
   2420          }
   2421          #endif
   2422          
   2423          /*$PAGE*/
   2424          /*
   2425          ************************************************************************************************************************
   2426          *                                               SCHEDULER LOCK TIME MEASUREMENT
   2427          *
   2428          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   2429          *
   2430          * Arguments  : none
   2431          *
   2432          * Returns    : none
   2433          *
   2434          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2435          *
   2436          *              2) It's assumed that these functions are called when interrupts are disabled.
   2437          *
   2438          *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
   2439          *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
   2440          *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
   2441          *                 real-time system.
   2442          ************************************************************************************************************************
   2443          */
   2444          
   2445          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   2446          void  OS_SchedLockTimeMeasStart (void)
   2447          {
   2448              if (OSSchedLockNestingCtr == 1u) {
   2449                  OSSchedLockTimeBegin = CPU_TS_TmrRd();
   2450              }
   2451          }
   2452          
   2453          
   2454          
   2455          
   2456          void  OS_SchedLockTimeMeasStop (void)
   2457          {
   2458              CPU_TS_TMR  delta;
   2459          
   2460          
   2461              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
   2462                  delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
   2463                        - OSSchedLockTimeBegin;
   2464                  if (delta > OSSchedLockTimeMax) {                   /* Detect peak value                                      */
   2465                      OSSchedLockTimeMax    = delta;
   2466                  }
   2467                  if (delta > OSSchedLockTimeMaxCur) {                /* Detect peak value (for resetable value)                */
   2468                      OSSchedLockTimeMaxCur = delta;
   2469                  }
   2470              }
   2471          }
   2472          #endif
   2473          
   2474          /*$PAGE*/
   2475          /*
   2476          ************************************************************************************************************************
   2477          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2478          *
   2479          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2480          *
   2481          *
   2482          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2483          *              ----------
   2484          *
   2485          * Returns    : none
   2486          *
   2487          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2488          ************************************************************************************************************************
   2489          */
   2490          
   2491          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
   2492          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2493          {
   2494              OS_TCB   *p_tcb;
   2495              CPU_SR_ALLOC();
   2496          
   2497          
   2498          
   2499              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   2500                  return;
   2501              }
   2502          
   2503              CPU_CRITICAL_ENTER();
   2504              p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
   2505          
   2506              if (p_tcb == (OS_TCB *)0) {
   2507                  CPU_CRITICAL_EXIT();
   2508                  return;
   2509              }
   2510          
   2511              if (p_tcb == &OSIdleTaskTCB) {
   2512                  CPU_CRITICAL_EXIT();
   2513                  return;
   2514              }
   2515          
   2516              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
   2517                  p_tcb->TimeQuantaCtr--;
   2518              }
   2519          
   2520              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
   2521                  CPU_CRITICAL_EXIT();
   2522                  return;
   2523              }
   2524          
   2525              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
   2526                  CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
   2527                  return;
   2528              }
   2529          
   2530              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
   2531                  CPU_CRITICAL_EXIT();
   2532                  return;
   2533              }
   2534          
   2535              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   2536              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   2537              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   2538                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   2539              } else {
   2540                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   2541              }
   2542              CPU_CRITICAL_EXIT();
   2543          }
   2544          #endif
   2545          
   2546          /*$PAGE*/
   2547          /*
   2548          ************************************************************************************************************************
   2549          *                                                     BLOCK A TASK
   2550          *
   2551          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2552          *              the specified timeout is non-zero.
   2553          *
   2554          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2555          *              -----
   2556          *
   2557          *              timeout        is the desired timeout
   2558          *
   2559          * Returns    : none
   2560          *
   2561          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2562          ************************************************************************************************************************
   2563          */
   2564          
   2565          void  OS_TaskBlock (OS_TCB   *p_tcb,
   2566                              OS_TICK   timeout)
   2567          {
   2568              OS_ERR  err;
   2569          
   2570          
   2571              if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
   2572                  OS_TickListInsert(p_tcb,
   2573                                    timeout,
   2574                                    OS_OPT_TIME_TIMEOUT,
   2575                                   &err);
   2576                  if (err == OS_ERR_NONE) {
   2577                      p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   2578                  } else {
   2579                      p_tcb->TaskState = OS_TASK_STATE_PEND;
   2580                  }
   2581              } else {
   2582                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   2583              }
   2584              OS_RdyListRemove(p_tcb);
   2585          }
   2586          
   2587          /*$PAGE*/
   2588          /*
   2589          ************************************************************************************************************************
   2590          *                                                     READY A TASK
   2591          *
   2592          * Description: This function is called to make a task ready-to-run.
   2593          *
   2594          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   2595          *              -----
   2596          *
   2597          * Returns    : none
   2598          *
   2599          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2600          ************************************************************************************************************************
   2601          */
   2602          
   2603          void   OS_TaskRdy (OS_TCB *p_tcb)
   2604          {
   2605              OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
   2606              if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
   2607                  OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
   2608              }
   2609          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSInit
         0   -> OSCfg_Init
         8   -> OSInitHook
         8   -> OS_Dbg_Init
         8   -> OS_FlagInit
         8   -> OS_IdleTaskInit
         8   -> OS_MemInit
         8   -> OS_MsgPoolInit
         8   -> OS_MutexInit
         8   -> OS_PrioInit
         8   -> OS_QInit
         8   -> OS_RdyListInit
         8   -> OS_SemInit
         8   -> OS_TaskInit
         8   -> OS_TickTaskInit
         8   -> OS_TmrInit
       0   OSIntEnter
       8   OSIntExit
         0   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
       8   OSSched
         0   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
      16   OSSchedLock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_SchedLockTimeMeasStart
      24   OSSchedRoundRobinCfg
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSSchedRoundRobinYield
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListMoveHeadToTail
      16   OSSchedUnlock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_SchedLockTimeMeasStop
      16   OSStart
        16   -> OSStartHighRdy
        16   -> OS_PrioGetHighest
       0   OSVersion
       8   OS_IdleTask
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIdleTaskHook
      40   OS_IdleTaskInit
        40   -> OSTaskCreate
      16   OS_Pend
        16   -> OS_PendDataInit
         0   -> OS_PendDbgNameAdd
        16   -> OS_PendListInsertPrio
        16   -> OS_TaskBlock
      24   OS_PendAbort
        24   -> OS_PendAbort1
        24   -> OS_PendListRemove
        24   -> OS_TaskRdy
        24   -> OS_TickListRemove
       4   OS_PendAbort1
       4   OS_PendDataInit
       0   OS_PendDbgNameAdd
       0   OS_PendDbgNameRemove
      16   OS_PendListChangePrio
        16   -> OS_PendListInsertPrio
        16   -> OS_PendListRemove1
       0   OS_PendListInit
       0   OS_PendListInsertHead
       4   OS_PendListInsertPrio
      16   OS_PendListRemove
        16   -> OS_PendListRemove1
       0   OS_PendListRemove1
      16   OS_PendObjDel
        16   -> OS_PendListRemove
        16   -> OS_PendObjDel1
        16   -> OS_TaskRdy
        16   -> OS_TickListRemove
       4   OS_PendObjDel1
      24   OS_Post
        24   -> OS_PendDbgNameRemove
        24   -> OS_PendListRemove
        24   -> OS_Post1
        24   -> OS_TaskRdy
        24   -> OS_TickListRemove
       8   OS_Post1
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         0   -> OS_RdyListInsertHead
         0   -> OS_RdyListInsertTail
       0   OS_RdyListInsertHead
       0   OS_RdyListInsertTail
       4   OS_RdyListMoveHeadToTail
       8   OS_RdyListRemove
         8   -> OS_PrioRemove
       8   OS_SchedLockTimeMeasStart
         8   -> CPU_TS_TmrRd
       8   OS_SchedLockTimeMeasStop
         8   -> CPU_TS_TmrRd
      16   OS_SchedRoundRobin
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
         0   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_RdyListMoveHeadToTail
      16   OS_TaskBlock
        16   -> OS_RdyListRemove
        16   -> OS_TickListInsert
       8   OS_TaskRdy
         0   -> OS_RdyListInsert
         8   -> OS_TickListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_27
       4  ??DataTable24_28
       4  ??DataTable24_29
       4  ??DataTable24_3
       4  ??DataTable24_30
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
      20  ?_0
       8  ?_1
      12  ?_2
       2  ?_3
     290  OSInit
      26  OSIntEnter
     168  OSIntExit
     120  OSSched
      94  OSSchedLock
      78  OSSchedRoundRobinCfg
     156  OSSchedRoundRobinYield
     122  OSSchedUnlock
      78  OSStart
      10  OSVersion
      38  OS_IdleTask
      76  OS_IdleTaskInit
      80  OS_Pend
     128  OS_PendAbort
      32  OS_PendAbort1
      40  OS_PendDataInit
      62  OS_PendDbgNameAdd
      24  OS_PendDbgNameRemove
      52  OS_PendListChangePrio
      10  OS_PendListInit
      34  OS_PendListInsertHead
     102  OS_PendListInsertPrio
      38  OS_PendListRemove
      60  OS_PendListRemove1
     118  OS_PendObjDel
      32  OS_PendObjDel1
     148  OS_Post
      38  OS_Post1
      30  OS_RdyListInit
      36  OS_RdyListInsert
      56  OS_RdyListInsertHead
      54  OS_RdyListInsertTail
      62  OS_RdyListMoveHeadToTail
      90  OS_RdyListRemove
      22  OS_SchedLockTimeMeasStart
      48  OS_SchedLockTimeMeasStop
     104  OS_SchedRoundRobin
      56  OS_TaskBlock
      26  OS_TaskRdy

 
     2 bytes in section .rodata
 3 006 bytes in section .text
 
 3 006 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none
