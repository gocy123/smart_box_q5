###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        01/Feb/2018  10:27:29
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\network_layer\nwl_uart1\uart1_network_layer.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\network_layer\nwl_uart1\uart1_network_layer.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\uart1_network_layer.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\uart1_network_layer.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\network_layer\nwl_uart1\uart1_network_layer.c
      1          // porting head file
      2          #include "stm32f10x.h"
      3          #include "platform_config.h"
      4          
      5          //static head file  
      6          #include <stdio.h>
      7          #include <stdarg.h>
      8          #include <string.h>
      9          #include <stdint.h>
     10          #include "ringbuffer.h"
     11          #include "uart1_network_layer.h"
     12          
     13          
     14          
     15          #define ___________UART1__PORT_AREA____START______
     16          
     17          static int uart1_init_link(void);
     18          inline int uart1_wr_rx_link_buffer(uint8_t *buf, int len);
     19          static int uart1_trig_a_tx_interrupt(void);
     20          
     21          #define UART1_SEND_DATA_RETRY_TIMES  (500)
     22          
     23          enum uart1_send_state{
     24          	UART1_SEND_IDLE=0,
     25          	UART1_SEND_SENDING
     26          };
     27          //rx ringbuffer
     28          #define UART1_RX_RINGBUF_LEN    (128*sizeof(uart1_data_package_t))
     29          static struct rt_ringbuffer uart1_rx_ringbuffer_controller={0};
     30          static uint8_t uart1_rx_ringbuf[UART1_RX_RINGBUF_LEN]={0};
     31          
     32          //tx ringbuffer
     33          #define UART1_TX_RINGBUF_LEN    (256*sizeof(uart1_data_package_t))
     34          static struct rt_ringbuffer uart1_tx_ringbuffer_controller={0};
     35          static uint8_t uart1_tx_ringbuf[UART1_TX_RINGBUF_LEN]={0};
     36          
     37          //sending status flag
     38          static enum uart1_send_state uart1_send_sta=UART1_SEND_IDLE;
     39          
     40          
     41          static void uart1_retry_delay(void)
     42          {
     43          	#if 0
     44          	OS_ERR os_err;
     45          	OSTimeDly(ms,OS_OPT_TIME_DLY,&os_err);
     46          	#else
     47          	uint32_t i;
     48          	i=0xFF;
     49          	while(i--)
     50          	{
     51          		
     52          	}
     53          	#endif
     54          }
     55          
     56          
     57          void user_uart1_open(void)
     58          {	
     59          	#define PRINT_BARDRATE_UART1 (115200)
     60          	//#define PRINT_BARDRATE_UART1 (115200)
     61          	USART_InitTypeDef USART_InitStructure={0};
     62          	//NVIC_InitTypeDef NVIC_InitStructure={0};
     63          
     64          	GPIO_InitTypeDef GPIO_InitStructure;
     65          	
     66          	/* Enable clock */
     67          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); 
     68          
     69          	/* Configure USART1 Tx as alternate function push-pull */
     70          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
     71          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     72          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     73          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     74          
     75          	/* Configure USART1 Rx as input floating */
     76          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
     77          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     78          	GPIO_Init(GPIOA, &GPIO_InitStructure);
     79          	
     80          
     81          	USART_InitStructure.USART_BaudRate = PRINT_BARDRATE_UART1;//*2;
     82          
     83          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     84          	USART_InitStructure.USART_StopBits = USART_StopBits_1;
     85          	USART_InitStructure.USART_Parity = USART_Parity_No;
     86          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     87          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     88          
     89          	/* Configure USART1 */
     90          	USART_Init(USART1, &USART_InitStructure);
     91          
     92          	/* Enable USARTy Receive and Transmit interrupts */
     93          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
     94          
     95          	/* Enable the USARTy */
     96          	USART_Cmd(USART1, ENABLE);
     97          	
     98          	//config link layer
     99          	uart1_init_link();
    100          }
    101          
    102          void user_uart1_close(void)
    103          {
    104          
    105          }
    106          
    107          void user_uart1_wakeup(void)
    108          {
    109          
    110          }
    111          
    112          void user_uart1_sleep(void)
    113          {
    114          
    115          }
    116          
    117          void user_uart1_reset(void)
    118          {
    119          	user_uart1_close();
    120          	user_uart1_open();
    121          }
    122          
    123          static void user_uart1_en_tx_int(void)
    124          {
    125          	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
    126          }
    127          
    128          static void user_uart1_dis_tx_int(void)
    129          {
    130          	USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
    131          }
    132          
    133          
    134          
    135          /*
    136          	brief:  write one minimum data package to peripheral TX regs
    137          
    138          	input: 
    139          			databyte: one msg will be sent
    140          	return:
    141          			0: send fail
    142          			1: send ok
    143          */
    144          static int user_uart1_transmit_one_data_package(uart1_data_package_t package)
    145          {
    146          	//int ret_len;
    147          	uint8_t ret;
    148          	do
    149          	{
    150          		ret=USART_GetFlagStatus(USART1,USART_FLAG_TXE);
    151          	}while(ret==0);
    152          	USART_SendData(USART1, (uint8_t) package);
    153          
    154          	return 1;
    155          }
    156          
    157          /*
    158          	brief: read one minimum data package from the peripheral RX regs
    159          
    160          	input: 
    161          			databyte: pointer that point to the rx databyte
    162          	return:
    163          			0: receive one byte fail
    164          			1: receive one byte ok
    165          */
    166          static int user_uart1_receive_one_data_package(uart1_data_package_t *package)
    167          {
    168          	*package = (uart1_data_package_t)(USART1->DR);
    169          	return 1;
    170          }
    171          
    172          void USART1_IRQHandler(void)
    173          {
    174          	//uint32_t intsrc, tmp, tmp1;
    175          	uart1_data_package_t tempchar;
    176          
    177          	// Receive Data Available or Character time-out
    178          	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    179          	{
    180          		if(user_uart1_receive_one_data_package(&tempchar)==1)
    181          		{
    182          			//InfoPrintf("%c",tempchar);
    183          		
    184          			if(uart1_wr_rx_link_buffer((uint8_t *)&tempchar,sizeof(tempchar))!=1)
    185          			{
    186          				//InfoPrintf("UART1 RX link buffer full\r\n");
    187          			}
    188          		}
    189          	}
    190          
    191          	// Transmit Holding Empty
    192          	if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
    193          	{
    194          			uart1_trig_a_tx_interrupt();
    195          	}
    196          
    197          }
    198          
    199          
    200          #define __________UART1__PORT_AREA____END________
    201          
    202          
    203          
    204          
    205          
    206          /*
    207          	return:
    208          			0: idle
    209          			1: busy,can`t write data to tx buf
    210          */
    211          int uart1_get_busy_state(void)
    212          {
    213          	return uart1_send_sta;
    214          }
    215          
    216          
    217          static int uart1_init_link(void)
    218          {
    219          	rt_ringbuffer_init(&uart1_rx_ringbuffer_controller,
    220          						uart1_rx_ringbuf,
    221          						UART1_RX_RINGBUF_LEN);
    222          	
    223          	rt_ringbuffer_init(&uart1_tx_ringbuffer_controller,
    224          							uart1_tx_ringbuf,
    225          							UART1_TX_RINGBUF_LEN);
    226          
    227          	uart1_send_sta=UART1_SEND_IDLE;
    228          
    229          	return 0;
    230          }
    231          
    232          /*
    233          	output: 
    234          			package: one package that readout from tx ringbuffer
    235          	return:
    236          			0: no data need to be sent 
    237          			1: read one msg successfully
    238          		   -1: error data in ringbuffer,app caller shuld reset the tx ringbuffer
    239          */
    240          static int uart1_rd_one_package_from_tx_ringbuffer(uart1_data_package_t *package)
    241          {
    242          	uint16_t package_size=sizeof(uart1_data_package_t);
    243          	uint32_t ret_len;
    244          
    245          	if(rt_ringbuffer_data_len(&uart1_tx_ringbuffer_controller)<package_size)
    246          	{
    247          		return 0;
    248          	}
    249          
    250          	ret_len=rt_ringbuffer_get(	&uart1_tx_ringbuffer_controller,
    251                                			(uint8_t *)package,
    252                                 			 package_size );
    253          	if(ret_len==package_size)
    254          	{
    255          		return 1;
    256          	}
    257          	else if(ret_len==0)
    258          	{
    259          		return 0;
    260          	}
    261          	else
    262          	{
    263          		return -1;
    264          	}
    265          }
    266          
    267          
    268          /*
    269          	use to start one transmition by app caller,
    270           	or 
    271           	use to enable continue transmiting  in IRQ function
    272          
    273           	return:
    274          			1: tx one package successfully, will occur one tx INT soon,
    275          			   peripheral is in tx sending state.
    276          			0: tx ringbuffer is empty,trig fail,
    277          			   peripheral is in tx idle state.
    278          		   -1: read tx package from tx ringbuffer ok,but send fail.
    279          		   -2: error data format in ringbuffer,need to reset the ringbuffer.
    280          */
    281          static int uart1_trig_a_tx_interrupt(void)
    282          {
    283          	int ret;
    284          	uart1_data_package_t tx_data_package;
    285          	
    286          	ret = uart1_rd_one_package_from_tx_ringbuffer(&tx_data_package);
    287          	if(ret==1)
    288          	{
    289          		if(user_uart1_transmit_one_data_package(tx_data_package)==1)
    290          		{
    291          			uart1_send_sta=UART1_SEND_SENDING;
    292          			user_uart1_en_tx_int();
    293          			return 1;
    294          		}
    295          	}
    296          	else if(ret==0)
    297          	{
    298          		//no data in ringbuffer
    299          		user_uart1_dis_tx_int();
    300          		uart1_send_sta=UART1_SEND_IDLE;
    301          		return 0;
    302          	}
    303          	else if(ret==-1)
    304          	{
    305          		//error data in tx ringbuffer ,neet to be reset
    306          		user_uart1_dis_tx_int();
    307          		uart1_send_sta=UART1_SEND_IDLE;
    308          		return -2;
    309          	}
    310          
    311          	user_uart1_dis_tx_int();
    312          	uart1_send_sta=UART1_SEND_IDLE;
    313          	return 0;
    314          }
    315          
    316          
    317          /*
    318          	write (1 ~~ UART1_TX_RINGBUF_LEN) bytes to uart ringbuf
    319          
    320          	input:
    321          			buf: input data
    322          			len: bytes amount need to write
    323          	return:
    324          			the real amount that written to ringbuf,
    325          			it must be the 0 or len !!!!!!
    326          
    327          	note : this function is called by uart1_send_data() only, other app 
    328          	       function should not call this function
    329          */
    330          static int uart1_wr_tx_link_buf_max_len(uint8_t *buf, uint32_t len)
    331          {	
    332          	int empty_len;
    333          	int ret_len=0;
    334          	//int ret;
    335          
    336          	if(len>UART1_TX_RINGBUF_LEN)
    337          	{
    338          		return 0;
    339          	}
    340          	else
    341          	{
    342          		empty_len=rt_ringbuffer_space_len(&uart1_tx_ringbuffer_controller);
    343          		if(empty_len>=len)
    344          		{
    345          			//因为会改变ringbuffer控制器值,所以需要禁止发送中断,阻止在ISR中同时修改ringbuffer控制器
    346          			//user_uart1_dis_tx_int();
    347          			ret_len = rt_ringbuffer_put(&uart1_tx_ringbuffer_controller,buf,len);
    348          			//user_uart1_en_tx_int();
    349          			if(ret_len!=len)
    350          			{
    351          				ret_len=0;//error!!!!!
    352          			}
    353          			
    354          			if(uart1_send_sta==UART1_SEND_IDLE)
    355          			{				
    356          				//这里不需要禁止发送中断,因为是从发送空闲 到 发送激活的过程,在这个过程中不会有发送中断
    357          				uart1_trig_a_tx_interrupt();
    358          			}
    359          		}
    360          		else 
    361          		{
    362          			return 0;
    363          		}
    364          	}
    365          	return ret_len;
    366          }
    367          
    368          /*
    369          	brief: write one byte to the rx linkbuf
    370          
    371          	input: 
    372          			databyte: UART1 rx reg data
    373          	return:
    374          			0:failed
    375          			1:success
    376          */
    377          int uart1_wr_rx_link_buffer(uint8_t *buf, int len)
    378          {	  
    379          	return rt_ringbuffer_put(&uart1_rx_ringbuffer_controller,buf,len);
    380          }
    381          
    382          
    383          
    384          
    385          
    386          //-----------------------APP CALL----------------------------------------
    387          
    388          /*
    389          	brief: wr len bytes data to the tx linkbuf
    390          
    391          	input: 
    392          			buf: contain the data that want to send by can
    393          			len: bytes amount that want to write into linkbuf
    394          	return:
    395          			the real amount written to the tx link buff
    396          note:
    397          		APP call this function to send UART1 datas
    398          */
    399          int uart1_send_data(uint8_t *buf, uint32_t len)
    400          {	
    401          	int ret=0;
    402          	int ret_len=0;
    403          	int i=0,j=0,k=0;
    404          	uint16_t retry_times;
    405          	uint16_t retry_times_2;
    406          	
    407          	uint8_t *ptr;
    408          	
    409          	ptr=buf;
    410          
    411          	if(len>UART1_TX_RINGBUF_LEN)
    412          	{
    413          		i=(len/UART1_TX_RINGBUF_LEN); //
    414          		j=(len%UART1_TX_RINGBUF_LEN); //
    415          		
    416          		retry_times=UART1_SEND_DATA_RETRY_TIMES;
    417          		for(k=0;k<i;)
    418          		{
    419          			if(retry_times<=0)
    420          			{
    421          				break;
    422          			}
    423          			retry_times--;
    424          			
    425          			retry_times_2=UART1_SEND_DATA_RETRY_TIMES;
    426          			while(uart1_get_busy_state()==UART1_SEND_SENDING)
    427          			{
    428          				uart1_retry_delay();
    429          				if(retry_times_2<=0)
    430          				{
    431          					break;
    432          				}
    433          				retry_times_2--;
    434          			}
    435          			
    436          			if(retry_times_2<=0)
    437          			{
    438          				break;
    439          			}
    440          			
    441          			ret=uart1_wr_tx_link_buf_max_len(ptr,UART1_TX_RINGBUF_LEN);
    442          			ret_len+=ret;
    443          			if(ret == UART1_TX_RINGBUF_LEN)
    444          			{
    445          				retry_times=UART1_SEND_DATA_RETRY_TIMES;
    446          				ptr+=UART1_TX_RINGBUF_LEN;
    447          				k++;
    448          			}
    449          			else
    450          			{
    451          				break;
    452          			}
    453          		}
    454          
    455          		if(k==i)
    456          		{
    457          			if(j!=0)
    458          			{
    459          				retry_times=UART1_SEND_DATA_RETRY_TIMES;
    460          				while(1)
    461          				{
    462          					ret=uart1_wr_tx_link_buf_max_len(ptr,j);
    463          					if(ret==0)
    464          					{
    465          						uart1_retry_delay();
    466          					}
    467          					else
    468          					{
    469          						ret_len+=ret;
    470          						break;
    471          					}
    472          					
    473          					if(retry_times<=0)
    474          					{
    475          						break;
    476          					}
    477          					retry_times--;
    478          				}
    479          			}
    480          		}
    481          	}
    482          	else
    483          	{
    484          		retry_times=UART1_SEND_DATA_RETRY_TIMES;
    485          		while(1)
    486          		{
    487          			ret=uart1_wr_tx_link_buf_max_len(buf,len);
    488          			if(ret==0)
    489                      {
    490                        uart1_retry_delay();
    491                      }
    492                      else
    493                      {
    494                        ret_len+=ret;
    495                        break;
    496                      }
    497          			if(retry_times<=0)
    498          			{
    499          				break;
    500          			}
    501          			retry_times--;
    502          		}
    503          	}
    504          	
    505          	return ret_len;
    506          }
    507          
    508          
    509          /*
    510          	brief: read data from rx link buffer 
    511          	input:
    512          			len: bytes amount that want to read out
    513          	output:
    514          			buf: contain the read out datas
    515          	return:
    516          			the really read out bytes amount
    517          note:
    518          		APP call this function to read UART1 rx datas
    519          
    520          */
    521          int uart1_receive_data(uint8_t *buf,int read_len)
    522          {  
    523          	uint16_t package_size=sizeof(uart1_data_package_t);
    524          	uint32_t ringbuf_cache_len_in_bytes;
    525          
    526          	if(read_len>UART1_RX_RINGBUF_LEN)
    527          	{
    528          		return -1;
    529          	}
    530          
    531          	if(read_len%package_size!=0)
    532          	{
    533          		return -1;//illegal read length
    534          	}
    535          
    536          	ringbuf_cache_len_in_bytes=rt_ringbuffer_data_len(&uart1_rx_ringbuffer_controller);
    537          	
    538          	if(ringbuf_cache_len_in_bytes < package_size)
    539          	{//缓存的数据 < 最小数据单元
    540          		return 0;
    541          	}
    542          
    543          	if(read_len<=ringbuf_cache_len_in_bytes)
    544          	{//需读取 < 缓存
    545          		return rt_ringbuffer_get(  &uart1_rx_ringbuffer_controller,
    546          									buf,
    547          								   (uint16_t)read_len
    548          								);
    549          	}
    550          	else
    551          	{//需读取 > 缓存  --->先读出已缓存的数据(按package_size为最小单位读出)
    552          		return rt_ringbuffer_get(  &uart1_rx_ringbuffer_controller,
    553          								    buf,
    554          								 (((uint16_t)ringbuf_cache_len_in_bytes/sizeof(uart1_data_package_t))*sizeof(uart1_data_package_t)));
    555          	}
    556          }
    557          
    558          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART1_IRQHandler
        16   -> USART_GetITStatus
        16   -> uart1_trig_a_tx_interrupt
        16   -> uart1_wr_rx_link_buffer
        16   -> user_uart1_receive_one_data_package
       8   rt_ringbuffer_data_len
         8   -> rt_ringbuffer_status
       0   rt_ringbuffer_status
       0   uart1_get_busy_state
       8   uart1_init_link
         8   -> rt_ringbuffer_init
      16   uart1_rd_one_package_from_tx_ringbuffer
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_get
      16   uart1_receive_data
        16   -> rt_ringbuffer_data_len
         0   -> rt_ringbuffer_get
       0   uart1_retry_delay
      32   uart1_send_data
        32   -> uart1_get_busy_state
        32   -> uart1_retry_delay
        32   -> uart1_wr_tx_link_buf_max_len
       8   uart1_trig_a_tx_interrupt
         8   -> uart1_rd_one_package_from_tx_ringbuffer
         8   -> user_uart1_dis_tx_int
         8   -> user_uart1_en_tx_int
         8   -> user_uart1_transmit_one_data_package
       0   uart1_wr_rx_link_buffer
         0   -> rt_ringbuffer_put
      16   uart1_wr_tx_link_buf_max_len
        16   -> rt_ringbuffer_data_len
        16   -> rt_ringbuffer_put
        16   -> uart1_trig_a_tx_interrupt
       0   user_uart1_close
       0   user_uart1_dis_tx_int
         0   -> USART_ITConfig
       0   user_uart1_en_tx_int
         0   -> USART_ITConfig
      32   user_uart1_open
        32   -> GPIO_Init
        32   -> RCC_APB2PeriphClockCmd
        32   -> USART_Cmd
        32   -> USART_ITConfig
        32   -> USART_Init
        32   -> __aeabi_memclr4
        32   -> uart1_init_link
       0   user_uart1_receive_one_data_package
       8   user_uart1_reset
         8   -> user_uart1_close
         0   -> user_uart1_open
       0   user_uart1_sleep
      16   user_uart1_transmit_one_data_package
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       0   user_uart1_wakeup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
      16  ?_0
      58  USART1_IRQHandler
      60  rt_ringbuffer_data_len
      40  rt_ringbuffer_status
       6  uart1_get_busy_state
      38  uart1_init_link
      52  uart1_rd_one_package_from_tx_ringbuffer
      72  uart1_receive_data
      12  uart1_retry_delay
     194  uart1_send_data
     412  uart1_send_sta
          uart1_tx_ringbuffer_controller
          uart1_rx_ringbuffer_controller
          uart1_rx_ringbuf
          uart1_tx_ringbuf
      76  uart1_trig_a_tx_interrupt
      16  uart1_wr_rx_link_buffer
      68  uart1_wr_tx_link_buf_max_len
       2  user_uart1_close
      12  user_uart1_dis_tx_int
      12  user_uart1_en_tx_int
     136  user_uart1_open
      10  user_uart1_receive_one_data_package
      12  user_uart1_reset
       2  user_uart1_sleep
      30  user_uart1_transmit_one_data_package
       2  user_uart1_wakeup

 
 412 bytes in section .bss
  16 bytes in section .rodata
 926 bytes in section .text
 
 910 bytes of CODE  memory (+ 16 bytes shared)
  16 bytes of CONST memory
 412 bytes of DATA  memory

Errors: none
Warnings: none
