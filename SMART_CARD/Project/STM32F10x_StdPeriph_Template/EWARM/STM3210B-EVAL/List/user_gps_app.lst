###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        01/Feb/2018  10:27:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\gps\user_gps_app.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\gps\user_gps_app.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\user_gps_app.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\user_gps_app.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\App\gps\user_gps_app.c
      1          //static head file
      2          #include <stdio.h>
      3          #include <stdarg.h>
      4          #include <string.h>
      5          #include <stdint.h>
      6          #include <math.h>
      7          
      8          //porting head files
      9          #include "heads.h"
     10          
     11          #include "user_debug_app.h"
     12          #include "os.h"
     13          #include "os_cfg_app.h"
     14          
     15          
     16          
     17          #define GPS_CFG_NUM 6
     18          const unsigned char gpsbuf[GPS_CFG_NUM][14]={
     19          /*1*/	{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x02,0x2E},//GPVTG
     20          /*2*/	{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0xFF,0x1F},//GPGSA
     21          /*3*/	{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x24},//GPGSV
     22          /*4*/	{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0xFE,0x1A},//GPGLL
     23          /*5*/	{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x08,0x00,0x00,0x00,0x00,0x05,0x3D},//GPZDA
     24          /*6*/	{0xB5,0x62,0x06,0x08,0x06,0x00,0xF4,0x01,0x01,0x00,0x01,0x00,0x0B,0x77} //GPRMC 2Hz report
     25          /*7*/	//{0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A} //GPRMC 5Hz report
     26          
     27          /*8*/	//{0xB5,0x62,0x06,0x01,0x06,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0xFD,0x15} //GPGGA
     28          };
     29          
     30          OS_SEM gps_lock;
     31          
     32          #define READ_FROM_LINK_BUF_LEN    (128)
     33          #define EXTRACTED_FRAME_BUF_LEN   (155)
     34          static uint8_t read_from_link_buf[READ_FROM_LINK_BUF_LEN]={0};
     35          static uint8_t extracted_frame_buf[EXTRACTED_FRAME_BUF_LEN]={0};
     36          static gps_location_info_T gps_location_info={0};
     37          //static gps_time_t gps_time={0};
     38          
     39          
     40          /*
     41          	input:
     42          			On_Off:
     43          					0: power off
     44          					1: power on
     45          	return:
     46          			0: success
     47          			1: error para
     48          */
     49          static void gps_power_ctl(uint8_t On_Off)
     50          {
     51          	//modem PWRKEY
     52          	/*PINSEL_ConfigPin(1, 26, 0);
     53          	GPIO_SetDir(1, (1<<26), GPIO_DIRECTION_OUTPUT);
     54          
     55          	if(On_Off==0)
     56          	{
     57          		GPIO_OutputValue(1, (1<<26), 0);	//power off 
     58          	}
     59          	else if(On_Off==1)
     60          	{
     61          		GPIO_OutputValue(1, (1<<26), 1);	//power on 
     62          	}*/
     63          }
     64          
     65          /*
     66          	input:
     67          			en_reset:
     68          					0: normal
     69          					1: reset gps module 
     70          					2: low power dissipation
     71          */
     72          static void gps_reset_ctl(uint8_t en_reset)
     73          {
     74          	/*PINSEL_ConfigPin(4, 14, 0);
     75          	GPIO_SetDir(1, (4<<14), GPIO_DIRECTION_OUTPUT);
     76          	
     77          	if(en_reset==0)
     78          	{
     79          		GPIO_OutputValue(4, (1<<14), 1);
     80          	}
     81          	else if(en_reset==1)
     82          	{
     83          		GPIO_OutputValue(4, (1<<14), 0);
     84          	}
     85          	else if(en_reset==2)
     86          	{
     87          		//Chip_IOCON_PinMuxSet(LPC_IOCON, 4, 14,IOCON_FUNC0 | IOCON_OPENDRAIN_EN);
     88          		//Chip_GPIO_SetPinDIR(LPC_GPIO,4,14,1);
     89          		//Chip_GPIO_SetPinOutHigh(LPC_GPIO,4,14);
     90          	}*/
     91          }
     92          
     93          /*
     94          	brief:config the GPS moudule itself, such as: gps frame`s report freq ...
     95          	return: 
     96          			0: success
     97          			1: error
     98          */
     99          static void gps_config_module(void)
    100          {
    101          	//OS_ERR os_err;
    102          	int i;
    103          	for (i=0;i<GPS_CFG_NUM;i++)
    104          	{
    105          		//uart_write(GPS_UART_PORT, (unsigned char*)&gpsbuf[i][0], 14 );
    106          		uart2_send_data((unsigned char*)&gpsbuf[i][0], 14);
    107          		user_delay_ms(200);
    108          	}
    109          }
    110          
    111          
    112          static void gps_init_ant_ck_pin(void)
    113          {
    114          	//OS_ERR err;
    115          	
    116          	/*PINSEL_ConfigPin(1, 28, 0);
    117          	GPIO_SetDir(1, (1<<28), GPIO_DIRECTION_OUTPUT);
    118          	GPIO_OutputValue(1, (1<<28), 1);
    119          
    120          	user_delay_ms(200);
    121          	
    122          	PINSEL_ConfigPin(1, 28, 0);
    123          	GPIO_SetDir(0, (1<<28), GPIO_DIRECTION_OUTPUT);*/
    124          }
    125          
    126          
    127          
    128          void gps_open_module(void)
    129          {
    130          	user_uart2_open();
    131          	//gps_power_ctl(1);
    132          	//gps_reset_ctl(0);
    133          	//user_delay_ms(TIME_10ms);
    134          	//gps_config_module();
    135          	//gps_init_ant_ck_pin();
    136          }
    137          
    138          void gps_close_module(void)
    139          {
    140          	user_uart2_close();	
    141          	gps_power_ctl(0);
    142          }
    143          
    144          #if 0
    145          
    146          //GPS纠偏算法 20161027
    147          /*
    148          	brief: get location info from the gps frame
    149          	
    150          	input:
    151          			*buf: pointer of the frame that according to gps NMEA-0183 format data
    152          	return:
    153          			0		: content of the frame is corrcet
    154          			others	: content error
    155          */
    156          static int parse_gps_frame_data(uint8_t *buf)
    157          {
    158          	OS_ERR os_err;
    159          	int n;
    160          	uint32_t temp;
    161          	RTC rtc_time,rd_rtc;
    162          	static uint8_t calibrat_time_cnt=0;
    163          	gps_location_info_T temp_gps_location_info={0};
    164          	static float last_lati=182.0;
    165          	static float last_longi=182.0;
    166          	       float curr_lati=0;
    167          	       float curr_longi=0;
    168          	static uint8_t longi_shift_move_cnt=0;
    169          	static uint8_t lati_shift_move_cnt=0;
    170          
    171          	if(strncmp((char const *)buf, "$GPRMC", 6)==0)
    172          	{
    173          		DbgRmPrintf(GPS_RM,"%s",buf);
    174          		OSSemPend(&gps_lock,10000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    175          		
    176          		//-----------------------------------------------------------------
    177          		
    178          		//$GNRMC,004505.000,A,2241.001098,N,11416.656622,E,0.028,129.792,201015,,E,A*3F
    179          		//                               time      va   lati  NS    longi  EW    sp   sp-dr  date
    180          		n=sscanf((char const*)buf,"%*[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,]",
    181          				&temp_gps_location_info.time[0],
    182          				&temp_gps_location_info.location_valid,
    183          				&temp_gps_location_info.latitude[0],
    184          				&temp_gps_location_info.latitude_NS,
    185          				&temp_gps_location_info.longitude[0],
    186          				&temp_gps_location_info.longitude_EW,
    187          				&temp_gps_location_info.speed[0],
    188          				&temp_gps_location_info.speed_direction[0],
    189          				&temp_gps_location_info.date[0]
    190          			);
    191          		if(n<9)
    192          		{
    193          			//InfoPrintf("parse gps RMC fail\r\n");
    194          			temp_gps_location_info.location_valid = 'V';
    195          		}
    196                  if(strlen((const char*)&temp_gps_location_info.date[0])< 6 ||
    197                     strlen((const char*)&temp_gps_location_info.time[0])< 6)
    198                  {
    199                     // InfoPrintf("parse gps time fail\r\n");
    200          			temp_gps_location_info.location_valid = 'V';
    201                  }
    202          
    203          		/*{
    204          			float a;
    205          			a=atof(temp_gps_location_info.latitude);
    206          			
    207          			a-=1000.23;
    208          			if(a)InfoPrintf("--xss");
    209          		}*/
    210          		
    211          		if(temp_gps_location_info.location_valid == 'A')
    212          		{
    213          			curr_lati =atof(temp_gps_location_info.latitude);
    214          			curr_longi=atof(temp_gps_location_info.longitude);
    215          
    216          			//---lati------------------------------------------------------
    217          			if((last_lati!=182.0))
    218          			{
    219          				if(last_lati>curr_lati)
    220          				{
    221          					if(last_lati-curr_lati>0.15)	
    222          					{
    223          						InfoPrintf("纬度漂移A\r\n");
    224          						lati_shift_move_cnt++;
    225          					}
    226          					else
    227          					{
    228          						last_lati=curr_lati;
    229          						lati_shift_move_cnt=0;
    230          					}
    231          				}	
    232          				else
    233          				{
    234          					if(curr_lati-last_lati>0.15)	
    235          					{
    236          						InfoPrintf("纬度漂移B\r\n");
    237          						lati_shift_move_cnt++;
    238          					}
    239          					else
    240          					{
    241          						last_lati=curr_lati;
    242          						lati_shift_move_cnt=0;
    243          					}
    244          				}
    245          			}
    246          			else
    247          			{
    248          				last_lati=curr_lati;	
    249          				lati_shift_move_cnt=0;
    250          			}
    251          
    252          			//---longi------------------------------------------------------
    253          			if((last_longi!=182.0))
    254          			{
    255          				if(last_longi>curr_longi)
    256          				{
    257          					if(last_longi-curr_longi>0.15)	
    258          					{
    259          						InfoPrintf("经度漂移A\r\n");
    260          						longi_shift_move_cnt++;
    261          					}
    262          					else
    263          					{
    264          						last_longi=curr_longi;
    265          						longi_shift_move_cnt=0;
    266          					}
    267          				}	
    268          				else
    269          				{
    270          					if(curr_longi-last_longi>0.15)	
    271          					{
    272          						InfoPrintf("经度漂移B\r\n");
    273          						longi_shift_move_cnt++;
    274          					}
    275          					else
    276          					{
    277          						last_longi=curr_longi;
    278          						longi_shift_move_cnt=0;
    279          					}
    280          				}
    281          			}
    282          			else
    283          			{
    284          				last_longi=curr_longi;	
    285          				longi_shift_move_cnt=0;
    286          			}
    287          
    288          			if((lati_shift_move_cnt==0)&&(longi_shift_move_cnt==0))
    289          			{
    290          				gps_location_info.location_valid='A';
    291          			}
    292          			else if((lati_shift_move_cnt>=20)||(longi_shift_move_cnt>=20))
    293          			{
    294          				gps_location_info.location_valid='A';
    295          			}
    296          			else
    297          			{
    298          				gps_location_info.location_valid='V';
    299          			}
    300          
    301          			if(gps_location_info.location_valid=='A')
    302          			{
    303          				//copy lati longi
    304          				temp=GPS_TIMELEN+1 + 1 + GPS_LATLEN+1 +1 + GPS_LONGLEN+1 +1 +GPS_SPEEDLEN+1 +GPS_SPEEDFXLEN+1 +GPS_DATELEN+1;
    305          				memcpy((uint8_t *)&gps_location_info,(uint8_t *)&temp_gps_location_info,temp);	
    306          			}
    307          		}
    308          		else
    309          		{
    310          			//已确定当前不定位
    311          			last_lati=182.0;
    312          			last_longi=182.0;
    313          			gps_location_info.location_valid='V';
    314          		}
    315          		
    316          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    317          	}
    318          	else if(strncmp((char const*)buf, "$GPGGA", 6)==0 && gps_location_info.location_valid=='A')
    319          	{
    320          		DbgRmPrintf(GPS_RM,"%s",buf);
    321          		OSSemPend(&gps_lock,10000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    322          		//$GNGGA,032257.000,2241.003225,N,11416.657230,E,1,16,0.690,79.556,M,0,M,,*58
    323          		n = sscanf((char const*)buf,"%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%[^,],%*[^,],%[^,]",
    324          				&gps_location_info.numSV[0],
    325          				&gps_location_info.altitude[0]);
    326          		if(n<1)
    327          		{
    328          			gps_location_info.numSV[0] = '0';
    329          		}
    330          
    331          		#if 1
    332          		calibrat_time_cnt++;
    333          		if(calibrat_time_cnt>=30)//500ms接收一次,
    334          		{
    335          			calibrat_time_cnt=0;
    336          			
    337          			if(gps_location_info.location_valid=='A')
    338          			{
    339          				static uint8_t err_local_time_cnt=0;
    340          				
    341          				ReadRTC(&rd_rtc);
    342          				
    343          				get_localtime_from_gps(gps_location_info.date,gps_location_info.time,&rtc_time);
    344          
    345          				temp=abs(rtc_to_uint32(rd_rtc)-rtc_to_uint32(rtc_time));
    346          				if(temp>=2)
    347          				{
    348          					err_local_time_cnt++;
    349          					if(err_local_time_cnt>=2)//1分钟校时一次->10s
    350          					{
    351          						InfoPrintf("GPS定位校时:");
    352          						InfoPrintf("%u-%u-%u %u:%u:%u\r\n",rtc_time.year,rtc_time.month,rtc_time.day,\
    353          						rtc_time.hour,rtc_time.minute,rtc_time.second);
    354          						InfoPrintf("本地RTC时间:");
    355          						getnow();
    356          						WriteRTC(&rtc_time);
    357          						InfoPrintf("校时后读出RTC:");
    358          						getnow();
    359          						err_local_time_cnt=0;
    360          					}
    361          				}
    362          				else
    363          				{
    364          					err_local_time_cnt=0;
    365          				}
    366          			}
    367          		}
    368          		#endif
    369                 
    370          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    371          		
    372          		#if 0
    373          		InfoPrintf("\r\n时间:%s,  ",&gps_location_info.time[0]);
    374          		InfoPrintf("定位:%c\r\n",gps_location_info.location_valid);
    375          		InfoPrintf("纬度:%s, ",&gps_location_info.latitude[0]);
    376          		InfoPrintf("纬向:%c  ",gps_location_info.latitude_NS);
    377          		InfoPrintf("经度:%s,",&gps_location_info.longitude[0]);
    378          		InfoPrintf("经向:%c\r\n",gps_location_info.longitude_EW);
    379          		InfoPrintf("速度:%s,",&gps_location_info.speed[0]);
    380          		InfoPrintf("速向:%s  ",&gps_location_info.speed_direction[0]);
    381          		InfoPrintf("日期:%s,",&gps_location_info.date[0]);
    382          		InfoPrintf("海拔:%s\r\n",&gps_location_info.altitude[0]);
    383          		InfoPrintf("星数:%s\r\n",&gps_location_info.numSV[0]);
    384          		#endif
    385          	}
    386          	
    387          	return 0;
    388          }
    389          
    390          #endif
    391          
    392          #define ___GPS____MIDDLE__________________________________________________________
    393          static int parse_gps_frame_data(uint8_t *buf)
    394          {
    395          	#define USE_QUECEL_GPS 1
    396          
    397          	OS_ERR os_err;
    398          	int n;
    399          	uint32_t temp;
    400          	static uint8_t cnt=0;
    401          
    402          	//static uint32_t last_rx_gps_time=0xFFFFFFFF;
    403          	//static float last_lati=0;
    404          	//static float last_longi=0;
    405          	//float  current_value;
    406          
    407          	BEIJING_TIME_T gps_time;
    408          	BEIJING_TIME_T current_time;
    409          	static uint8_t calibrat_time_cnt=0;
    410          	//uint8_t temp_flag='V';	
    411          	static uint8_t err_local_time_cnt=0;
    412          	uint8_t error_move_flag=0;
    413          	gps_location_info_T temp_gps_info={0};
    414          
    415          	//InfoPrintf("%s",buf);
    416          	OSSemPend(&gps_lock,10000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    417          	#if USE_QUECEL_GPS
    418          	if(strncmp((char const *)buf, "$GNRMC", 6)==0)
    419          	#else
    420          	if(strncmp((char const *)buf, "$GPRMC", 6)==0)
    421          	#endif
    422          	{
    423          		if(cnt++%5==0)
    424          		InfoPrintf("%s",buf);
    425          		
    426          		//$GNRMC,004505.000,A,2241.001098,N,11416.656622,E,0.028,129.792,201015,,E,A*3F
    427          		//                               time      va   lati  NS    longi  EW    sp   sp-dr  date
    428          		n=sscanf((char const*)buf,"%*[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%[^,]",
    429          				&temp_gps_info.time[0],
    430          				&temp_gps_info.location_valid,
    431          				&temp_gps_info.latitude[0],
    432          				&temp_gps_info.latitude_NS,
    433          				&temp_gps_info.longitude[0],
    434          				&temp_gps_info.longitude_EW,
    435          				&temp_gps_info.speed[0],
    436          				&temp_gps_info.speed_direction[0],
    437          				&temp_gps_info.date[0]
    438          				);
    439          		
    440          		if(n<9)
    441          		{
    442          			//InfoPrintf("parse gps RMC fail\r\n");
    443          			temp_gps_info.location_valid = 'V';
    444          		}
    445          		
    446                  if(strlen((const char*)&temp_gps_info.date[0])< 6 ||
    447                     strlen((const char*)&temp_gps_info.time[0])< 6)
    448                  {
    449                     // InfoPrintf("parse gps time fail\r\n");
    450          			temp_gps_info.location_valid = 'V';
    451                  }
    452          
    453          		if(temp_gps_info.location_valid =='A')
    454          		{
    455          			if(error_move_flag==0)
    456          			{
    457          				memcpy(gps_location_info.time,temp_gps_info.time,GPS_TIMELEN);
    458          				gps_location_info.location_valid=temp_gps_info.location_valid;
    459          				
    460          				memcpy(gps_location_info.latitude,temp_gps_info.latitude,GPS_LATLEN);
    461          				gps_location_info.latitude_NS=temp_gps_info.latitude_NS;
    462          					
    463          				memcpy(gps_location_info.longitude,temp_gps_info.longitude,GPS_LONGLEN);
    464          				gps_location_info.longitude_EW=temp_gps_info.longitude_EW;
    465          				
    466          				memcpy(gps_location_info.speed,temp_gps_info.speed,GPS_SPEEDLEN);
    467          				memcpy(gps_location_info.speed_direction,temp_gps_info.speed_direction,GPS_SPEEDFXLEN);
    468          				memcpy(gps_location_info.date,temp_gps_info.date,GPS_DATELEN);
    469          			}
    470          			
    471          			//last_rx_gps_time=time();
    472          
    473          			if(gps_location_info.location_valid=='A')
    474          			{
    475          				calibrat_time_cnt++;
    476          				if(calibrat_time_cnt>=20)
    477          				{
    478          					calibrat_time_cnt=0;
    479          					get_current_time(&current_time);
    480          					get_localtime_from_gps((char *)(gps_location_info.date),(char *)(gps_location_info.time),&gps_time);
    481          					temp=abs(rtc_to_uint32(current_time)-rtc_to_uint32(gps_time));
    482          					
    483          					if(temp>=2)
    484          					{
    485          						err_local_time_cnt++;
    486          						if(err_local_time_cnt>=2)//在间隔20*1秒内,连续2次相差超过2秒,则校时.
    487          						{
    488          							InfoPrintf("GPS定位校时:");
    489          							InfoPrintf("%u-%02d-%02d %02d:%02d:%02d\r\n",gps_time.year,gps_time.month,gps_time.day,\
    490          															gps_time.hour,gps_time.minute,gps_time.second);
    491          							InfoPrintf("本地RTC时间:");
    492          							printf_time_now();
    493          							write_rtc(gps_time);
    494          							InfoPrintf("校时后读出RTC:");
    495          							printf_time_now();
    496          							err_local_time_cnt=0;
    497          						}
    498          					}
    499          					else
    500          					{
    501          						err_local_time_cnt=0;
    502          					}
    503          				}
    504          			}
    505          			else
    506          			{
    507          				calibrat_time_cnt=0;
    508          				err_local_time_cnt=0;
    509          			}
    510          		}
    511          		else
    512          		{
    513          			InfoPrintf("#");
    514          			//InfoPrintf("##\r\n");
    515          		}
    516          	}
    517          	#if 0
    518          	else if(strncmp((char const*)buf, "$GPGGA", 6)==0 && gps_location_info.location_valid=='A')
    519          	{
    520          		//$GNGGA,032257.000,2241.003225,N,11416.657230,E,1,16,0.690,79.556,M,0,M,,*58
    521          		n = sscanf((char const*)buf,"%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%*[^,],%[^,],%*[^,],%[^,]",
    522          				&temp_gps_info.numSV[0],
    523          				&temp_gps_info.altitude[0]);
    524          		if(n<1)
    525          		{
    526          			temp_gps_info.numSV[0] = '0';
    527          			temp_gps_info.location_valid = 'V';
    528          		}
    529          
    530          		if(gps_location_info.location_valid == 'A')
    531          		{
    532          			memcpy(gps_location_info.altitude,temp_gps_info.altitude,strlen((char const *)(temp_gps_info.altitude)));
    533          			memcpy(gps_location_info.numSV,temp_gps_info.numSV,strlen((char const *)(temp_gps_info.numSV)));
    534          		}
    535          
    536          		#if 0
    537          		if(gps_location_info.location_valid=='A'){
    538          		InfoPrintf("\r\n时间:%s,  ",&gps_location_info.time[0]);
    539          		InfoPrintf("定位:%c\r\n",gps_location_info.location_valid);
    540          		InfoPrintf("纬度:%s, ",&gps_location_info.latitude[0]);
    541          		InfoPrintf("纬向:%c  ",gps_location_info.latitude_NS);
    542          		InfoPrintf("经度:%s,",&gps_location_info.longitude[0]);
    543          		InfoPrintf("经向:%c\r\n",gps_location_info.longitude_EW);
    544          		InfoPrintf("速度:%s,",&gps_location_info.speed[0]);
    545          		InfoPrintf("速向:%s  ",&gps_location_info.speed_direction[0]);
    546          		InfoPrintf("日期:%s,",&gps_location_info.date[0]);
    547          		InfoPrintf("海拔:%s\r\n",&gps_location_info.altitude[0]);
    548          		InfoPrintf("星数:%s\r\n",&gps_location_info.numSV[0]);}
    549          		#endif
    550          	}
    551          	#endif
    552          
    553          	#if 0
    554          	else if(strncmp((char const*)buf, "$GPGSV", 6)==0)
    555          	{
    556          		InfoPrintf("%s",buf);
    557          
    558          	}
    559          	#endif
    560          	
    561          	OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    562          	return 0;
    563          }
    564          
    565          /*
    566          	brief:
    567          		(1)extract one gps frame from the link buf
    568          		(2)get gps location info from the extraced frame
    569          */
    570          static uint16_t read_data_from_linkbuf(void)
    571          {
    572          	static enum gps_check_frame_stp step=step_search_head;
    573          	static int i=0;	
    574          	int read_len; 	//从link buffer读出的字节数
    575          	uint16_t ret;
    576          	int ptr;			//已处理的read_from_link_buf中的position
    577          	uint8_t temp_byte;
    578          
    579          	//read_len = uart_read(GPS_UART_PORT, read_from_link_buf, READ_FROM_LINK_BUF_LEN);
    580          	read_len = uart2_receive_data(read_from_link_buf,READ_FROM_LINK_BUF_LEN);
    581          	if(read_len<=0)
    582          	{
    583          		return 0;
    584          	}
    585          	
    586          	ret=read_len;
    587          	ptr=0;	
    588          
    589          	while(read_len--)
    590          	{
    591          		temp_byte=read_from_link_buf[ptr++];
    592          		//InfoPrintf("%c",temp_byte);
    593          		switch(step)
    594          		{
    595          			case step_search_head:
    596          				i=0;
    597          				memset(extracted_frame_buf,EXTRACTED_FRAME_BUF_LEN,0);
    598          				if(temp_byte=='$')
    599          				{
    600          					step=step_search_tail;
    601          					extracted_frame_buf[i++]=temp_byte;
    602          				}
    603          				break;
    604          				
    605          			case step_search_tail:
    606          				if((temp_byte!='$') && (i<EXTRACTED_FRAME_BUF_LEN))
    607          				{
    608          					if(extracted_frame_buf[i-1]==',' && temp_byte==',' )
    609          					{
    610          						extracted_frame_buf[i++]='0';
    611          					}
    612          					
    613          					extracted_frame_buf[i++]=temp_byte;	
    614          					
    615          					if(temp_byte==0x0A)				// '\n'
    616          					{
    617          						if(extracted_frame_buf[i-2]==0x0D)	// '\r'
    618          						{//extract one frame now !!!
    619          							parse_gps_frame_data(extracted_frame_buf);							
    620          							step=step_search_head;
    621          						}
    622          						else
    623          						{//error
    624          							//InfoPrintf("错误 tail\r\n");
    625          							step=step_search_head;
    626          						}
    627          					}
    628          				}
    629          				else
    630          				{
    631          					//error
    632          					i=0;
    633          					if(temp_byte=='$')
    634          					{
    635          						//InfoPrintf("错误 $\r\n");
    636          						memset(extracted_frame_buf,EXTRACTED_FRAME_BUF_LEN,0);
    637          						extracted_frame_buf[i++]=temp_byte;
    638          						step=step_search_tail;
    639          					}
    640          					else if(i>=EXTRACTED_FRAME_BUF_LEN)
    641          					{
    642          						//InfoPrintf("超长错误%d\r\n",i);
    643          						step=step_search_head;
    644          					}
    645          				}
    646          				break;
    647          				
    648          			default:
    649          				break;
    650          		}
    651          	}
    652          	
    653          	return ret;
    654          }
    655          
    656          #define ___GPS_APP__________________________________________________________________________
    657          
    658          int gps_check_lacation_state(void)
    659          {
    660          	OS_ERR os_err;
    661          
    662          	OSSemPend(&gps_lock,1000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    663          
    664          	if('A'==gps_location_info.location_valid)
    665          	{	
    666          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    667          		return 1;
    668          	}
    669          	else
    670          	{
    671          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    672          		return 0;
    673          	}
    674          }
    675          
    676          /*
    677          	return :
    678          			0 :north latitude
    679          			1 :south latitude
    680          */
    681          uint8_t gps_get_south_north(void)
    682          {
    683          	OS_ERR os_err;
    684          
    685          	OSSemPend(&gps_lock,1000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    686          	if('N'==gps_location_info.latitude_NS)
    687          	{	
    688          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    689          		return 0;
    690          	}
    691          	else
    692          	{
    693          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    694          		return 1;
    695          	}
    696          }
    697          
    698          /*
    699          	return :
    700          			0 :east longitude
    701          			1 :west longitude
    702          */
    703          uint8_t gps_get_east_west(void)
    704          {
    705          	OS_ERR os_err;
    706          
    707          	OSSemPend(&gps_lock,1000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    708          	if('E'==gps_location_info.longitude_EW)
    709          	{	
    710          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    711          		return 0;
    712          	}
    713          	else
    714          	{
    715          		OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    716          		return 1;
    717          	}
    718          }
    719          
    720          
    721          
    722          void gps_get_location_info(gps_location_info_T *ptr)
    723          {
    724          	OS_ERR os_err;
    725          
    726          	OSSemPend(&gps_lock,1000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    727          	memcpy((uint8_t *)ptr,(uint8_t *)(&gps_location_info),sizeof(gps_location_info_T));
    728          	OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    729          }
    730          
    731          //获得GPS可见星数
    732          uint8_t  Get_GPS_Number(void)  //qdhai add
    733          {
    734          	uint8_t len=0;   
    735          	uint8_t  gps_num=0;
    736          	OS_ERR os_err;
    737          	
    738          	OSSemPend(&gps_lock,1000,OS_OPT_PEND_BLOCKING,NULL,&os_err);
    739          	len = strlen((char const*)gps_location_info.numSV);
    740          	if(len==1)
    741          	{
    742          		gps_num=gps_location_info.numSV[0]-'0';
    743          	}
    744          	else if(len==2)
    745          	{ 
    746          		gps_num=(gps_location_info.numSV[0]-'0')*10+gps_location_info.numSV[1]-'0';
    747          	}
    748          	OSSemPost(&gps_lock,OS_OPT_POST_1,&os_err);
    749          	return gps_num;
    750          }
    751          
    752          static void gps_led_ctl(void)
    753          {
    754          	OS_ERR os_err;
    755          	static uint32_t last=0;
    756          	static uint8_t flag=0;	
    757          	
    758          	/*if(gps_location_info.location_valid!='A')
    759          	{
    760          
    761          		if(OSTimeGet(&os_err)-last>500)
    762          		{
    763          			last=OSTimeGet(&os_err);
    764          			if(flag++%2==0)
    765          			GPIO_OutputValue(0, (1<<13),1);
    766          			else
    767          			GPIO_OutputValue(0, (1<<13),0);
    768          		}
    769          	}
    770          	else
    771          	{
    772          		GPIO_OutputValue(0, (1<<13), 0);
    773          	}*/
    774          }
    775          
    776          
    777          void GpsTaskMsg_handle(TASK_MSG_T *p_msg)
    778          {
    779          
    780          	switch (p_msg->msg_src_id)
    781          	{
    782          		case DEV_MANAGE_TASK_ID:
    783          			switch (p_msg->msg_father_type)
    784          			{
    785          				case FATHER_MSG_T_TASK_POWER_CTRL:
    786          					if(p_msg->msg_son_type==POWER_CTRL_PWR_ON)
    787          					{
    788          						gps_open_module();
    789          					}
    790          					else if(p_msg->msg_son_type==POWER_CTRL_WAKEUP)
    791          					{
    792          
    793          					}
    794          					else if(p_msg->msg_son_type==POWER_CTRL_SLEEP)
    795          					{
    796          
    797          					}
    798          					else if(p_msg->msg_son_type==POWER_CTRL_PWR_OFF)
    799          					{
    800          
    801          					}
    802          					break;
    803          				default:
    804          					break;
    805          			}
    806          			break;
    807          		case MODEM_MANAGE_TASK_ID:
    808          			break;
    809          		default:
    810          			break;
    811          	}		
    812          }
    813          
    814          void GpsTask(void *p_arg)
    815          {
    816          	TASK_MSG_T *task_msg;
    817          	OS_MSG_SIZE msg_size;
    818          	uint32_t last_time=0;
    819          	//uart3_data_package_t test_buf[100]={0};
    820          	//int len,i;
    821          	OS_ERR os_err;
    822          	p_arg=p_arg;
    823          
    824          	//gps led
    825          	/*PINSEL_ConfigPin(0, 13, 0);
    826          	GPIO_SetDir(0, (1<<13), GPIO_DIRECTION_OUTPUT);
    827          	GPIO_OutputValue(0, (1<<13), 1);*/
    828          
    829          	OSSemCreate(&gps_lock,"gps_lock",1,&os_err);
    830          	if(os_err != OS_ERR_NONE)
    831          	{
    832          		InfoPrintf ("create gps_lock failed !!\r\n");
    833          	}
    834          
    835          	#if 1
    836          	{
    837          	BEIJING_TIME_T current_time;
    838          	current_time.year=2016;
    839          	current_time.month=6;
    840          	current_time.day=19;
    841          	current_time.hour=23;
    842          	current_time.minute=00;
    843          	current_time.second=20;
    844          	write_rtc(current_time);
    845          	}
    846          	#endif
    847          
    848          	
    849          	while(1)
    850          	{
    851          		task_msg = OSTaskQPend(0,OS_OPT_PEND_NON_BLOCKING,&msg_size,NULL,&os_err);
    852          		if(NULL != task_msg)
    853          		{
    854          			GpsTaskMsg_handle(task_msg);
    855          			user_free(task_msg,__FUNCTION__);
    856          		}
    857          
    858          		
    859          		//user_delay_ms(TIME_10ms);
    860          
    861          		read_data_from_linkbuf();
    862          		gps_led_ctl();
    863          		
    864          		
    865          		if(user_get_os_time()-last_time>T_3S)
    866          		{
    867          			last_time=user_get_os_time();
    868          			InfoPrintf("GpsTask loop...\r\n");
    869          		}
    870          		
    871          		OSSchedRoundRobinYield(&os_err);
    872          	}
    873          
    874          }
    875          
    876          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   Get_GPS_Number
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> strlen
      72   GpsTask
        56   -> GpsTaskMsg_handle
        56   -> InfoPrintf
        56   -> OSSchedRoundRobinYield
        56   -> OSSemCreate
        56   -> OSTaskQPend
        72   -> __aeabi_memcpy4
        56   -> gps_led_ctl
        56   -> read_data_from_linkbuf
        56   -> user_free
        56   -> user_get_os_time
        56   -> write_rtc
       0   GpsTaskMsg_handle
         0   -> gps_open_module
      16   gps_check_lacation_state
        16   -> OSSemPend
        16   -> OSSemPost
       8   gps_close_module
         0   -> gps_power_ctl
         8   -> user_uart2_close
      16   gps_get_east_west
        16   -> OSSemPend
        16   -> OSSemPost
      24   gps_get_location_info
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> __aeabi_memcpy
      16   gps_get_south_north
        16   -> OSSemPend
        16   -> OSSemPost
       0   gps_led_ctl
       0   gps_open_module
         0   -> user_uart2_open
       0   gps_power_ctl
     200   parse_gps_frame_data
       184   -> InfoPrintf
       184   -> OSSemPend
       184   -> OSSemPost
       184   -> __aeabi_memclr4
       184   -> __aeabi_memcpy
       184   -> __aeabi_memcpy4
       200   -> __aeabi_memcpy4
       184   -> abs
       184   -> get_current_time
       184   -> get_localtime_from_gps
       184   -> printf_time_now
       184   -> rtc_to_uint32
       184   -> sscanf
       184   -> strlen
       184   -> strncmp
       184   -> write_rtc
      24   read_data_from_linkbuf
        24   -> __aeabi_memset4
        24   -> parse_gps_frame_data
        24   -> uart2_receive_data


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
      72  ?_0
       8  ?_1
      28  ?_10
      20  ?_11
       4  ?_2
      64  ?_3
      16  ?_4
      32  ?_5
      16  ?_6
      16  ?_7
       2  ?_8
      12  ?_9
      88  Get_GPS_Number
     162  GpsTask
      22  GpsTaskMsg_handle
       3  cnt
          calibrat_time_cnt
          err_local_time_cnt
      60  gps_check_lacation_state
      14  gps_close_module
      62  gps_get_east_west
      52  gps_get_location_info
      60  gps_get_south_north
       2  gps_led_ctl
     112  gps_location_info
          gps_lock
       4  gps_open_module
       2  gps_power_ctl
      84  gpsbuf
     504  parse_gps_frame_data
     246  read_data_from_linkbuf
     292  step
          read_from_link_buf
          extracted_frame_buf
          i
       8  -- Other

 
   407 bytes in section .bss
   162 bytes in section .rodata
 1 522 bytes in section .text
 
 1 522 bytes of CODE  memory
   162 bytes of CONST memory
   407 bytes of DATA  memory

Errors: none
Warnings: 8
