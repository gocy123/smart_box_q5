###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\os_cpu_c.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\os_cpu_c.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-III
      4          *                                          The Real-Time Kernel
      5          *
      6          *
      7          *                           (c) Copyright 2009-2010; Micrium, Inc.; Weston, FL
      8          *                    All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                                           ARM Cortex-M3 Port
     11          *
     12          * File      : OS_CPU_C.C
     13          * Version   : V3.01.2
     14          * By        : JJL
     15          *             BAN
     16          *
     17          * LICENSING TERMS:
     18          * ---------------
     19          *             uC/OS-III is provided in source form to registered licensees ONLY.  It is 
     20          *             illegal to distribute this source code to any third party unless you receive 
     21          *             written permission by an authorized Micrium representative.  Knowledge of 
     22          *             the source code may NOT be used to develop a similar product.
     23          *
     24          *             Please help us continue to provide the Embedded community with the finest
     25          *             software available.  Your honesty is greatly appreciated.
     26          *
     27          *             You can contact us at www.micrium.com.
     28          *
     29          * For       : ARMv7M Cortex-M3
     30          * Mode      : Thumb2
     31          * Toolchain : IAR EWARM
     32          *********************************************************************************************************
     33          */
     34          
     35          #define   OS_CPU_GLOBALS
     36          
     37          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     38          const  CPU_CHAR  *os_cpu_c__c = "$Id: $";
     39          #endif
     40          
     41          /*$PAGE*/
     42          /*
     43          *********************************************************************************************************
     44          *                                             INCLUDE FILES
     45          *********************************************************************************************************
     46          */
     47          
     48          #include  <os.h>
     49          
     50          /*
     51          *********************************************************************************************************
     52          *                                           IDLE TASK HOOK
     53          *
     54          * Description: This function is called by the idle task.  This hook has been added to allow you to do
     55          *              such things as STOP the CPU to conserve power.
     56          *
     57          * Arguments  : None.
     58          *
     59          * Note(s)    : None.
     60          *********************************************************************************************************
     61          */
     62          
     63          void  OSIdleTaskHook (void)
     64          {
     65          #if OS_CFG_APP_HOOKS_EN > 0u
     66              if (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)0) {
     67                  (*OS_AppIdleTaskHookPtr)();
     68              }
     69          #endif
     70          }
     71          
     72          
     73          /*$PAGE*/
     74          /*
     75          *********************************************************************************************************
     76          *                                       OS INITIALIZATION HOOK
     77          *
     78          * Description: This function is called by OSInit() at the beginning of OSInit().
     79          *
     80          * Arguments  : None.
     81          *
     82          * Note(s)    : None.
     83          *********************************************************************************************************
     84          */
     85          
     86          void  OSInitHook (void)
     87          {
     88              OS_CPU_ExceptStkBase = (CPU_STK *)(OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u);
     89          }
     90          
     91          
     92          /*$PAGE*/
     93          /*
     94          *********************************************************************************************************
     95          *                                         STATISTIC TASK HOOK
     96          *
     97          * Description: This function is called every second by uC/OS-III's statistics task.  This allows your
     98          *              application to add functionality to the statistics task.
     99          *
    100          * Arguments  : None.
    101          *
    102          * Note(s)    : None.
    103          *********************************************************************************************************
    104          */
    105          
    106          void  OSStatTaskHook (void)
    107          {
    108          #if OS_CFG_APP_HOOKS_EN > 0u
    109              if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
    110                  (*OS_AppStatTaskHookPtr)();
    111              }
    112          #endif
    113          }
    114          
    115          
    116          /*$PAGE*/
    117          /*
    118          *********************************************************************************************************
    119          *                                          TASK CREATION HOOK
    120          *
    121          * Description: This function is called when a task is created.
    122          *
    123          * Arguments  : p_tcb        Pointer to the task control block of the task being created.
    124          *
    125          * Note(s)    : None.
    126          *********************************************************************************************************
    127          */
    128          
    129          void  OSTaskCreateHook (OS_TCB  *p_tcb)
    130          {
    131          #if OS_CFG_APP_HOOKS_EN > 0u
    132              if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
    133                  (*OS_AppTaskCreateHookPtr)(p_tcb);
    134              }
    135          #else
    136              (void)p_tcb;                                            /* Prevent compiler warning                               */
    137          #endif
    138          }
    139          
    140          
    141          /*$PAGE*/
    142          /*
    143          *********************************************************************************************************
    144          *                                           TASK DELETION HOOK
    145          *
    146          * Description: This function is called when a task is deleted.
    147          *
    148          * Arguments  : p_tcb        Pointer to the task control block of the task being deleted.
    149          *
    150          * Note(s)    : None.
    151          *********************************************************************************************************
    152          */
    153          
    154          void  OSTaskDelHook (OS_TCB  *p_tcb)
    155          {
    156          #if OS_CFG_APP_HOOKS_EN > 0u
    157              if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
    158                  (*OS_AppTaskDelHookPtr)(p_tcb);
    159              }
    160          #else
    161              (void)p_tcb;                                            /* Prevent compiler warning                               */
    162          #endif
    163          }
    164          
    165          
    166          /*$PAGE*/
    167          /*
    168          *********************************************************************************************************
    169          *                                            TASK RETURN HOOK
    170          *
    171          * Description: This function is called if a task accidentally returns.  In other words, a task should
    172          *              either be an infinite loop or delete itself when done.
    173          *
    174          * Arguments  : p_tcb        Pointer to the task control block of the task that is returning.
    175          *
    176          * Note(s)    : None.
    177          *********************************************************************************************************
    178          */
    179          
    180          void  OSTaskReturnHook (OS_TCB  *p_tcb)
    181          {
    182          #if OS_CFG_APP_HOOKS_EN > 0u
    183              if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
    184                  (*OS_AppTaskReturnHookPtr)(p_tcb);
    185              }
    186          #else
    187              (void)p_tcb;                                            /* Prevent compiler warning                               */
    188          #endif
    189          }
    190          
    191          
    192          /*$PAGE*/
    193          /*
    194          **********************************************************************************************************
    195          *                                       INITIALIZE A TASK'S STACK
    196          *
    197          * Description: This function is called by OS_Task_Create() or OSTaskCreateExt() to initialize the stack
    198          *              frame of the task being created. This function is highly processor specific.
    199          *
    200          * Arguments  : p_task       Pointer to the task entry point address.
    201          *
    202          *              p_arg        Pointer to a user supplied data area that will be passed to the task
    203          *                               when the task first executes.
    204          *
    205          *              p_stk_base   Pointer to the base address of the stack.
    206          *
    207          *              stk_size     Size of the stack, in number of CPU_STK elements.
    208          *
    209          *              opt          Options used to alter the behavior of OS_Task_StkInit().
    210          *                            (see OS.H for OS_TASK_OPT_xxx).
    211          *
    212          * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
    213          *              been placed on the stack in the proper order.
    214          *
    215          * Note(s)    : 1) Interrupts are enabled when task starts executing.
    216          *
    217          *              2) All tasks run in Thread mode, using process stack.
    218          **********************************************************************************************************
    219          */
    220          
    221          CPU_STK  *OSTaskStkInit (OS_TASK_PTR    p_task,
    222                                   void          *p_arg,
    223                                   CPU_STK       *p_stk_base,
    224                                   CPU_STK       *p_stk_limit,
    225                                   CPU_STK_SIZE   stk_size,
    226                                   OS_OPT         opt)
    227          {
    228              CPU_STK  *p_stk;
    229          
    230          
    231              (void)opt;                                              /* Prevent compiler warning                               */
    232          
    233              p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
    234                                                                      /* Registers stacked as if auto-saved on exception        */
    235              *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
    236              *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
    237              *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
    238              *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
    239              *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
    240              *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
    241              *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
    242              *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
    243                                                                      /* Remaining registers saved on process stack             */
    244              *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
    245              *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
    246              *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
    247              *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
    248              *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
    249              *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
    250              *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
    251              *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
    252          
    253              return (p_stk);
    254          }
    255          
    256          
    257          /*$PAGE*/
    258          /*
    259          *********************************************************************************************************
    260          *                                           TASK SWITCH HOOK
    261          *
    262          * Description: This function is called when a task switch is performed.  This allows you to perform other
    263          *              operations during a context switch.
    264          *
    265          * Arguments  : None.
    266          *
    267          * Note(s)    : 1) Interrupts are disabled during this call.
    268          *              2) It is assumed that the global pointer 'OSTCBHighRdyPtr' points to the TCB of the task
    269          *                 that will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCurPtr' points
    270          *                 to the task being switched out (i.e. the preempted task).
    271          *********************************************************************************************************
    272          */
    273          
    274          void  OSTaskSwHook (void)
    275          {
    276          #if OS_CFG_TASK_PROFILE_EN > 0u
    277              CPU_TS  ts;
    278          #endif
    279          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    280              CPU_TS  int_dis_time;
    281          #endif
    282          
    283          
    284          
    285          #if OS_CFG_APP_HOOKS_EN > 0u
    286              if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
    287                  (*OS_AppTaskSwHookPtr)();
    288              }
    289          #endif
    290          
    291          #if OS_CFG_TASK_PROFILE_EN > 0u
    292              ts = OS_TS_GET();
    293              if (OSTCBCurPtr != OSTCBHighRdyPtr) {
    294                  OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
    295                  OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
    296              }
    297          
    298              OSTCBHighRdyPtr->CyclesStart = ts;
    299          #endif
    300          
    301          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    302              int_dis_time = CPU_IntDisMeasMaxCurReset();             /* Keep track of per-task interrupt disable time          */
    303              if (OSTCBCurPtr->IntDisTimeMax < int_dis_time) {
    304                  OSTCBCurPtr->IntDisTimeMax = int_dis_time;
    305              }
    306          #endif
    307          
    308          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    309                                                                      /* Keep track of per-task scheduler lock time             */
    310              if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
    311                  OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
    312              }
    313              OSSchedLockTimeMaxCur = (CPU_TS)0;                      /* Reset the per-task value                               */
    314          #endif
    315          }
    316          
    317          
    318          /*$PAGE*/
    319          /*
    320          *********************************************************************************************************
    321          *                                              TICK HOOK
    322          *
    323          * Description: This function is called every tick.
    324          *
    325          * Arguments  : None.
    326          *
    327          * Note(s)    : 1) This function is assumed to be called from the Tick ISR.
    328          *********************************************************************************************************
    329          */
    330          
    331          void  OSTimeTickHook (void)
    332          {
    333          #if OS_CFG_APP_HOOKS_EN > 0u
    334              if (OS_AppTimeTickHookPtr != (OS_APP_HOOK_VOID)0) {
    335                  (*OS_AppTimeTickHookPtr)();
    336              }
    337          #endif
    338          }
    339          
    340          
    341          /*$PAGE*/
    342          /*
    343          *********************************************************************************************************
    344          *                                          SYS TICK HANDLER
    345          *
    346          * Description: Handle the system tick (SysTick) interrupt, which is used to generate the uC/OS-II tick
    347          *              interrupt.
    348          *
    349          * Arguments  : None.
    350          *
    351          * Note(s)    : 1) This function MUST be placed on entry 15 of the Cortex-M3 vector table.
    352          *********************************************************************************************************
    353          */
    354          
    355          void  OS_CPU_SysTickHandler (void)
    356          {
    357              CPU_SR_ALLOC();
    358          
    359          
    360              CPU_CRITICAL_ENTER();
    361              OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
    362              CPU_CRITICAL_EXIT();
    363          
    364              OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */
    365          
    366              OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
    367          }
    368          
    369          
    370          /*$PAGE*/
    371          /*
    372          *********************************************************************************************************
    373          *                                         INITIALIZE SYS TICK
    374          *
    375          * Description: Initialize the SysTick.
    376          *
    377          * Arguments  : cnts         Number of SysTick counts between two OS tick interrupts.
    378          *
    379          * Note(s)    : 1) This function MUST be called after OSStart() & after processor initialization.
    380          *********************************************************************************************************
    381          */
    382          
    383          void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
    384          {
    385              CPU_INT32U  prio;
    386          
    387          
    388              CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
    389          
    390                                                                      /* Set SysTick handler prio.                              */
    391              prio  = CPU_REG_NVIC_SHPRI3;
    392              prio &= DEF_BIT_FIELD(24, 0);
    393              prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);
    394          
    395              CPU_REG_NVIC_SHPRI3 = prio;
    396          
    397                                                                      /* Enable timer.                                          */
    398              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
    399                                      CPU_REG_NVIC_ST_CTRL_ENABLE;
    400                                                                      /* Enable timer interrupt.                                */
    401              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_TICKINT;
    402          }
    403          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   OSIdleTaskHook
         0   -- Indirect call
       0   OSInitHook
       0   OSStatTaskHook
         0   -- Indirect call
       0   OSTaskCreateHook
         0   -- Indirect call
       0   OSTaskDelHook
         0   -- Indirect call
       0   OSTaskReturnHook
         0   -- Indirect call
       4   OSTaskStkInit
      24   OSTaskSwHook
        24   -- Indirect call
        24   -> CPU_IntDisMeasMaxCurReset
        24   -> CPU_TS_TmrRd
       0   OSTimeTickHook
         0   -- Indirect call
       8   OS_CPU_SysTickHandler
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         0   -> OSIntExit
         8   -> OSTimeTick
       0   OS_CPU_SysTickInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      12  OSIdleTaskHook
      20  OSInitHook
      12  OSStatTaskHook
      12  OSTaskCreateHook
      12  OSTaskDelHook
      12  OSTaskReturnHook
     128  OSTaskStkInit
     110  OSTaskSwHook
      12  OSTimeTickHook
       4  OS_CPU_ExceptStkBase
      42  OS_CPU_SysTickHandler
      34  OS_CPU_SysTickInit

 
   4 bytes in section .bss
 474 bytes in section .text
 
 474 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
