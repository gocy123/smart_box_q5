###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.7.9843/W32 for ARM        05/Feb/2018  13:40:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\Utility\Common.c
#    Command line =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\Utility\Common.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_MD -D USE_STM3210B_EVAL -lcN
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List
#        -o
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Full.h" -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\BSP\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-CPU\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uC-LIB\Ports\ARM-Cortex-M3\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Source\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\OS\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\Utility\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart1\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart2\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\user_debug\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\dev_manage\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\sim800\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\protocol_communication\protocol_jt808\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rtc\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\gps\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\network_layer\nwl_uart3\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\modem\quecelMC20\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\rf\
#        -I
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\..\..\App\internal_flash\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\List\Common.lst
#    Object file  =  
#        D:\GitHub2\smart_box_q5\SMART_CARD\Project\STM32F10x_StdPeriph_Template\EWARM\STM3210B-EVAL\Obj\Common.o
#
###############################################################################

D:\GitHub2\smart_box_q5\SMART_CARD\Project\Utility\Common.c
      1          #include "Common.h"
      2          #include "user_rtc_app.h"
      3          
      4          
      5          void localtime(unsigned int time , BEIJING_TIME_T *prtc)//1970-2100之间能正确转换
      6          {
      7          	unsigned  int  n32_Pass4year;
      8          	int n32_hpery;
      9          	const char Days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
     10          	//计算时差
     11          	//  time=time-timezone;//无时差
     12          
     13          	//  if(time < 0)
     14          	//  {
     15          	//     time = 0;
     16          	//  }
     17          	//取秒时间
     18          	prtc->second = time % 60;
     19          	time /= 60;
     20          	//取分钟时间
     21          	prtc->minute = time % 60;
     22          	time /= 60;
     23          	//取过去多少个四年，每四年有 1461*24 小时
     24          	n32_Pass4year= time / (1461 * 24);
     25          	//计算年份
     26          	prtc->year = (n32_Pass4year << 2)+70;
     27          	//四年中剩下的小时数
     28          	time %= 1461 * 24;
     29          	//校正闰年影响的年份，计算一年中剩下的小时数
     30          	for (;;)
     31          	{
     32          		//一年的小时数
     33          		n32_hpery = 365 * 24;
     34          		//判断闰年
     35          		if ((prtc->year & 3) == 0)
     36          		{
     37                      //是闰年，一年则多24小时，即一天
     38                      n32_hpery += 24;
     39          		}
     40                  if (time < n32_hpery)
     41          		{
     42                      break;
     43          		}
     44                  prtc->year++;
     45                  time -= n32_hpery;
     46              }
     47              //小时数
     48              prtc->hour = time % 24;
     49              //一年中剩下的天数
     50              time /= 24;
     51              //假定为闰年
     52              time++;
     53              //校正润年的误差，计算月份，日期
     54              if ((prtc->year & 3) == 0)
     55              {
     56          		if (time > 60)
     57          		{
     58          			time--;
     59          		}
     60          		else
     61          		{
     62          			if (time == 60)
     63          			{
     64          				prtc->month = 1;
     65          				prtc->day = 29;
     66          				goto OVER;
     67          			}
     68          		}
     69          	}
     70          	
     71          	//计算月日
     72          	for (prtc->month = 0; Days[prtc->month] < time;prtc->month++)
     73          	{
     74          		time -= Days[prtc->month];
     75          	}
     76          
     77          	prtc->day = time;
     78          	
     79          	OVER:
     80          	prtc->year += 1900;
     81          	prtc->month++;
     82          
     83          }
     84          
     85          unsigned char *seg_sec_to_bcd_time(unsigned int sec, unsigned char *bcd_time, int time_zone)
     86          {
     87              BEIJING_TIME_T tm;
     88            
     89              if(NULL == bcd_time) 
     90                  return NULL;
     91              
     92              //sec += (time_zone * 3600);
     93              
     94              localtime(sec, &tm);
     95              
     96              bcd_time[0] = (((tm.year%100)/10) << 4) | (tm.year % 10);
     97              bcd_time[1] = (((tm.month%100)/10) << 4) | (tm.month % 10);
     98              bcd_time[2] = (((tm.day%100)/10) << 4) | (tm.day % 10);
     99              bcd_time[3] = (((tm.hour%100)/10) << 4) | (tm.hour % 10);
    100              bcd_time[4] = (((tm.minute %100)/10) << 4) | (tm.minute % 10);
    101              bcd_time[5] = (((tm.second %100)/10) << 4) | (tm.second % 10);
    102              
    103              return bcd_time;
    104          }
    105          
    106          
    107          unsigned long mktime (	unsigned int year, unsigned int mon,  
    108              					unsigned int day,  unsigned int hour,  
    109              					unsigned int min,  unsigned int sec)  
    110          {  
    111              if (0 >= (int) (mon -= 2))  /* 1..12 -> 11,12,1..10 */  
    112          	{   
    113                   mon += 12;      /* Puts Feb last since it has leap day */  
    114                   year -= 1;  
    115              }  
    116            
    117              return (((  
    118                       (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +  
    119                       year*365 - 719499  
    120                    )*24 + hour /* now have hours */  
    121                 )*60 + min /* now have minutes */  
    122              )*60 + sec; /* finally seconds */  
    123          }
    124          
    125          
    126          unsigned int time(void)
    127          {
    128          	BEIJING_TIME_T stNow;
    129          	unsigned long t;
    130          	int ret;
    131          
    132          	ret=get_current_time(&stNow);
    133          	  //把年月日转换成unix时间戳，秒
    134          	t = mktime(stNow.year,stNow.month,stNow.day,\
    135          		stNow.hour,stNow.minute,stNow.second);
    136          
    137          	return t;
    138          }
    139          
    140          int rtc_to_uint32(BEIJING_TIME_T stNow)
    141          {
    142          	int t;
    143          	  //把年月日转换成unix时间戳，秒
    144          	t = (int)mktime(stNow.year,stNow.month,stNow.day,\
    145          		stNow.hour,stNow.minute,stNow.second);
    146          
    147          	return t;
    148          }
    149          
    150          
    151          
    152          #define BEIJING_TINE_ZONE   (8*60*60)
    153          void LocalTime2UTC(BEIJING_TIME_T *LocalRtc , BEIJING_TIME_T *pUTCRtc)
    154          {
    155          	unsigned long tt;
    156          	tt = mktime(LocalRtc->year,LocalRtc->month,LocalRtc->day,\
    157          		LocalRtc->hour,LocalRtc->minute,LocalRtc->second);
    158          	tt -= BEIJING_TINE_ZONE;
    159          	localtime(tt,pUTCRtc);
    160          
    161          }
    162          unsigned int GpsTimeToUnix(char *GpsDate,char *GpsTime)
    163          {
    164          	unsigned int year;
    165          	unsigned int mon;  
    166              unsigned int day;
    167          	unsigned int hour;  
    168              unsigned int min;
    169          	unsigned int sec;
    170          	
    171          	year = (GpsDate[4]-'0') *10 +(GpsDate[5]-'0');
    172          	year += 2000;
    173          	mon = (GpsDate[2]-'0') *10 + (GpsDate[3]-'0');
    174          	day = (GpsDate[0]-'0') *10 + (GpsDate[1]-'0');
    175          
    176          	hour = (GpsTime[0]-'0')  *10 + (GpsTime[1]-'0');
    177          	min = (GpsTime[2]-'0')  *10 + (GpsTime[3]-'0');
    178          	sec = (GpsTime[4]-'0')  *10 + (GpsTime[5]-'0');
    179          
    180          	return mktime(year,mon,day,hour,min,sec);
    181          }
    182          
    183          void get_localtime_from_gps(char *gps_date,char *gps_time,BEIJING_TIME_T *rtc_time)
    184          {
    185          	localtime(GpsTimeToUnix(gps_date,gps_time) + BEIJING_TINE_ZONE,rtc_time);
    186          }
    187          
    188          uint8_t CharToInt(char c)
    189          {
    190              uint8_t ucRet = 0;
    191              
    192              if(c >= '0' && c <= '9')
    193                  ucRet = c - 0x30;
    194              else if(c >= 'a' && c <= 'f')
    195                  ucRet = c - 0x61 + 10;
    196              else if(c >= 'A' && c <= 'F')
    197                  ucRet = c - 0x41 + 10;
    198              
    199              return ucRet;
    200          }
    201          
    202          void StringToHex(char *pStr, uint8_t *pHexBuf)
    203          {
    204              uint8_t ucLen, i;
    205              
    206              ucLen = strlen((const char *)pStr);
    207              
    208              for(i = 0; i < ucLen/2; i++)
    209              {
    210                  pHexBuf[i] = CharToInt((char)pStr[2*i])*16 + CharToInt((char)pStr[2*i + 1]);
    211              }
    212          }
    213          
    214          
    215          
    216          
    217          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CharToInt
      24   GpsTimeToUnix
        24   -> mktime
      16   LocalTime2UTC
         0   -> localtime
        16   -> mktime
      24   StringToHex
        24   -> CharToInt
        24   -> strlen
       8   get_localtime_from_gps
         8   -> GpsTimeToUnix
         0   -> localtime
      24   localtime
      12   mktime
      32   rtc_to_uint32
        32   -> mktime
      40   seg_sec_to_bcd_time
        40   -> localtime
      40   time
        40   -> get_current_time
        40   -> mktime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      12  ?_0
      48  CharToInt
      88  GpsTimeToUnix
      36  LocalTime2UTC
      64  StringToHex
      20  get_localtime_from_gps
     176  localtime
      86  mktime
      26  rtc_to_uint32
     222  seg_sec_to_bcd_time
      34  time

 
 816 bytes in section .text
 
 816 bytes of CODE memory

Errors: none
Warnings: 1
